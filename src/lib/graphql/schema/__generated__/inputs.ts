// @ts-nocheck
import { Prisma } from '@prisma/client';

import { builder } from '../builder';

type Filters = {
  string: Prisma.StringFieldUpdateOperationsInput;
  nullableString: Prisma.NullableStringFieldUpdateOperationsInput;
  dateTime: Prisma.DateTimeFieldUpdateOperationsInput;
  nullableDateTime: Prisma.NullableDateTimeFieldUpdateOperationsInput;
  int: Prisma.IntFieldUpdateOperationsInput;
  nullableInt: Prisma.NullableIntFieldUpdateOperationsInput;
  bool: Prisma.BoolFieldUpdateOperationsInput;
  nullableBool: Prisma.NullableBoolFieldUpdateOperationsInput;
  bigInt: Prisma.BigIntFieldUpdateOperationsInput;
  nullableBigInt: Prisma.NullableBigIntFieldUpdateOperationsInput;
  bytes: Prisma.BytesFieldUpdateOperationsInput;
  nullableBytes: Prisma.NullableBytesFieldUpdateOperationsInput;
  float: Prisma.FloatFieldUpdateOperationsInput;
  nullableFloat: Prisma.NullableFloatFieldUpdateOperationsInput;
  decimal: Prisma.DecimalFieldUpdateOperationsInput;
  nullableDecimal: Prisma.NullableDecimalFieldUpdateOperationsInput;
};

type ApplyFilters<InputField> = {
  [F in keyof Filters]: 0 extends 1 & Filters[F]
    ? never
    : Filters[F] extends InputField
    ? Filters[F]
    : never;
}[keyof Filters];

type PrismaUpdateOperationsInputFilter<T extends object> = {
  [K in keyof T]: [ApplyFilters<T[K]>] extends [never] ? T[K] : ApplyFilters<T[K]>
};

export const DateTime = builder.scalarType('DateTime', {
  parseValue: (value) => {
    try {
      const date = new Date(value)
      if (date.toString() === 'Invalid Date') throw new Error('Invalid Date')
      return date
    } catch (error) {
      throw new Error('Invalid Date');
    }
  },
  serialize: (value) => value ? new Date(value) : null,
});

export const Json = builder.scalarType('Json', {
  serialize: (value) => value,
});

export const NEVER = builder.scalarType('NEVER', {
  serialize: (value) => value,
  description: 'Never fill this, its created for inputs that dont have fields',
});

export const TransactionIsolationLevel = builder.enumType('TransactionIsolationLevel', {
  values: ["ReadUncommitted","ReadCommitted","RepeatableRead","Serializable"] as const,
});

export const UserScalarFieldEnum = builder.enumType('UserScalarFieldEnum', {
  values: ["id","name","email","emailVerified","image","password","phone","firstName","lastName","preferredLanguage","timeformat24","timezone","weekStartDate","photoId","featureDiscovery","emailProviders","theme","notifications","createdAt","updatedAt","userRole"] as const,
});

export const AccountScalarFieldEnum = builder.enumType('AccountScalarFieldEnum', {
  values: ["id","userId","type","provider","providerAccountId","refresh_token","access_token","expires_at","token_type","scope","id_token","session_state"] as const,
});

export const SessionScalarFieldEnum = builder.enumType('SessionScalarFieldEnum', {
  values: ["id","sessionToken","userId","expires"] as const,
});

export const VerificationTokenScalarFieldEnum = builder.enumType('VerificationTokenScalarFieldEnum', {
  values: ["identifier","token","expires"] as const,
});

export const AttachmentScalarFieldEnum = builder.enumType('AttachmentScalarFieldEnum', {
  values: ["id","contentType","filename","path","size","uploaderId","createdAt","updatedAt","companyId"] as const,
});

export const HiringRoleScalarFieldEnum = builder.enumType('HiringRoleScalarFieldEnum', {
  values: ["id","userId","roleId","companyId","extraAbilities","createdAt","updatedAt"] as const,
});

export const RoleScalarFieldEnum = builder.enumType('RoleScalarFieldEnum', {
  values: ["id","name","abilities","companyId","createdAt","updatedAt"] as const,
});

export const CompanyScalarFieldEnum = builder.enumType('CompanyScalarFieldEnum', {
  values: ["id","name","phone","address","city","state","country","companyInbox","subdomain","gdprEnable","gdprRetention","gdprPrivacyPolicyLink","gdprEmailFooter","createdAt","updatedAt","ownerId","logoId"] as const,
});

export const SubscriptionDataScalarFieldEnum = builder.enumType('SubscriptionDataScalarFieldEnum', {
  values: ["id","active","currentPeriodStart","currentPeriodEnd","status","companyId"] as const,
});

export const CompanyMetadataScalarFieldEnum = builder.enumType('CompanyMetadataScalarFieldEnum', {
  values: ["id","companyId","key","value","settings","type"] as const,
});

export const DepartmentScalarFieldEnum = builder.enumType('DepartmentScalarFieldEnum', {
  values: ["id","name","companyId"] as const,
});

export const DisqualifyReasonScalarFieldEnum = builder.enumType('DisqualifyReasonScalarFieldEnum', {
  values: ["id","name","action","companyId"] as const,
});

export const TagSourceScalarFieldEnum = builder.enumType('TagSourceScalarFieldEnum', {
  values: ["id","name","type","companyId"] as const,
});

export const AuditLogScalarFieldEnum = builder.enumType('AuditLogScalarFieldEnum', {
  values: ["id","companyId","userId","offerId","candidateId","actor","actorType","ip","action","eventDetails","createdAt"] as const,
});

export const MeetingRoomScalarFieldEnum = builder.enumType('MeetingRoomScalarFieldEnum', {
  values: ["id","name","type","link","companyId"] as const,
});

export const EventScheduleScalarFieldEnum = builder.enumType('EventScheduleScalarFieldEnum', {
  values: ["id","name","dateRange","expiresAfter","inviteAll","bufferTime","ignoreDayEvents","meetingLimit","duration","Interval","type","timezone","location","note","privateNote","link","companyId"] as const,
});

export const EventScheduleInterviewerScalarFieldEnum = builder.enumType('EventScheduleInterviewerScalarFieldEnum', {
  values: ["id","eventScheduleId","teamMemberId","availability"] as const,
});

export const EventScheduleEvaluationScalarFieldEnum = builder.enumType('EventScheduleEvaluationScalarFieldEnum', {
  values: ["id","eventScheduleId","evaluationId"] as const,
});

export const EventScalarFieldEnum = builder.enumType('EventScalarFieldEnum', {
  values: ["id","date","duration","type","location","note","privateNote","companyId","createdAt","updatedAt","createdById"] as const,
});

export const EventInterviewerScalarFieldEnum = builder.enumType('EventInterviewerScalarFieldEnum', {
  values: ["id","eventId","teamMemberId"] as const,
});

export const OfferScalarFieldEnum = builder.enumType('OfferScalarFieldEnum', {
  values: ["id","name","companyId","departmentId","recruiterId","hiringManagerId","description","requirements","locationCountry","locationState","locationCity","locationStreet","zipcode","remote","jobType","jobCategory","jobReqEducation","jobReqExperience","jobHoursMin","jobHoursMax","jobSalaryMin","jobSalaryMax","jobSalaryPeriod","jobSalaryCurrency","personalInfoCv","personalInfoCoverLetter","personalInfoPhoto","personalInfoPhone","screeningQuestionsTemplateId","pipelineTemplateId","autoConfirmationEmailId","isPublished","createdAt","updatedAt"] as const,
});

export const OfferFileScalarFieldEnum = builder.enumType('OfferFileScalarFieldEnum', {
  values: ["id","offerId","attachmentId"] as const,
});

export const MatchScalarFieldEnum = builder.enumType('MatchScalarFieldEnum', {
  values: ["id","offerId","candidateId","stageId","isHired","disqualifyReasonId"] as const,
});

export const OfferTagScalarFieldEnum = builder.enumType('OfferTagScalarFieldEnum', {
  values: ["offerId","tagId"] as const,
});

export const MembershipScalarFieldEnum = builder.enumType('MembershipScalarFieldEnum', {
  values: ["id","type","teamMemberId","roleId","offerId"] as const,
});

export const TalentPoolScalarFieldEnum = builder.enumType('TalentPoolScalarFieldEnum', {
  values: ["id","name","description","companyId","createdAt","updatedAt"] as const,
});

export const TalentPoolFileScalarFieldEnum = builder.enumType('TalentPoolFileScalarFieldEnum', {
  values: ["id","talentPoolId","attachmentId"] as const,
});

export const TalentPoolMatchScalarFieldEnum = builder.enumType('TalentPoolMatchScalarFieldEnum', {
  values: ["id","talentPoolId","candidateId"] as const,
});

export const TemplateScalarFieldEnum = builder.enumType('TemplateScalarFieldEnum', {
  values: ["id","companyId","isCompanyWide","type","name","category"] as const,
});

export const StageScalarFieldEnum = builder.enumType('StageScalarFieldEnum', {
  values: ["id","position","category","inputType","value","templateId","isProtected"] as const,
});

export const StageVisibilityScalarFieldEnum = builder.enumType('StageVisibilityScalarFieldEnum', {
  values: ["id","type","teamMemberId","roleId","stageId"] as const,
});

export const StageMetadataScalarFieldEnum = builder.enumType('StageMetadataScalarFieldEnum', {
  values: ["id","metaKey","metaValue","stageId"] as const,
});

export const CandidateScalarFieldEnum = builder.enumType('CandidateScalarFieldEnum', {
  values: ["id","firstName","lastName","email","phone","skills","mainLanguage","languages","coverLetterText","birthday","referrerId","cvId","avatarId","coverLetterId","educationLevel","socials","links","salaryExpectation","hiredAtId","hiredById","companyId","createdAt","updatedAt"] as const,
});

export const CandidateTagScalarFieldEnum = builder.enumType('CandidateTagScalarFieldEnum', {
  values: ["candidateId","tagId"] as const,
});

export const CandidateCustomFieldScalarFieldEnum = builder.enumType('CandidateCustomFieldScalarFieldEnum', {
  values: ["candidateId","customFieldId","value"] as const,
});

export const CustomFieldScalarFieldEnum = builder.enumType('CustomFieldScalarFieldEnum', {
  values: ["id","type","key","defaultValue","settings","companyId"] as const,
});

export const EvaluationScalarFieldEnum = builder.enumType('EvaluationScalarFieldEnum', {
  values: ["id","templateId","offerId","candidateId","teamMemberId","isQuickEval","description","score","eventId","createdAt","updatedAt"] as const,
});

export const EvaluationQuestionScalarFieldEnum = builder.enumType('EvaluationQuestionScalarFieldEnum', {
  values: ["id","evaluationId","inputType","settings","question","answer"] as const,
});

export const SharedCandidateLinkScalarFieldEnum = builder.enumType('SharedCandidateLinkScalarFieldEnum', {
  values: ["id","name","visibleSections","editModelSections","link","expiration","candidateId"] as const,
});

export const TaskScalarFieldEnum = builder.enumType('TaskScalarFieldEnum', {
  values: ["id","companyId","name","status","dueDate","note","candidateId"] as const,
});

export const TaskMemberScalarFieldEnum = builder.enumType('TaskMemberScalarFieldEnum', {
  values: ["id","taskId","teamMemberId"] as const,
});

export const FollowScalarFieldEnum = builder.enumType('FollowScalarFieldEnum', {
  values: ["id","offerId","candidateId","talentPoolId","teamMemberId"] as const,
});

export const SortOrder = builder.enumType('SortOrder', {
  values: ["asc","desc"] as const,
});

export const NullableJsonNullValueInput = builder.enumType('NullableJsonNullValueInput', {
  values: ["DbNull","JsonNull"] as const,
});

export const JsonNullValueInput = builder.enumType('JsonNullValueInput', {
  values: ["JsonNull"] as const,
});

export const QueryMode = builder.enumType('QueryMode', {
  values: ["default","insensitive"] as const,
});

export const JsonNullValueFilter = builder.enumType('JsonNullValueFilter', {
  values: ["DbNull","JsonNull","AnyNull"] as const,
});

export const NullsOrder = builder.enumType('NullsOrder', {
  values: ["first","last"] as const,
});

export const UserRoles = builder.enumType('UserRoles', {
  values: ["SUPERADMIN","DEFAULT"] as const,
});

export const TagSourceType = builder.enumType('TagSourceType', {
  values: ["TAG_OFFER","TAG_CANDIDATE","SOURCE"] as const,
});

export const OfferPersonalItems = builder.enumType('OfferPersonalItems', {
  values: ["REQUIRED","OPTIONAL","NONE"] as const,
});

export const MembershipTypes = builder.enumType('MembershipTypes', {
  values: ["MEMBER","ROLE"] as const,
});

export const TemplateTypes = builder.enumType('TemplateTypes', {
  values: ["SCREENING_QUESTIONS","PIPELINE","AUTOCONFIRMATION_EMAIL","EVALUATION"] as const,
});

export const SCORE_TYPES = builder.enumType('SCORE_TYPES', {
  values: ["APPROVED","NEUTRAL","REJECTED"] as const,
});

export const UserWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[UserWhereInput]}),
  OR: t.field({"required":false,"type":[UserWhereInput]}),
  NOT: t.field({"required":false,"type":[UserWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringNullableFilter}),
  email: t.field({"required":false,"type":StringFilter}),
  emailVerified: t.field({"required":false,"type":DateTimeNullableFilter}),
  image: t.field({"required":false,"type":StringNullableFilter}),
  password: t.field({"required":false,"type":StringNullableFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  firstName: t.field({"required":false,"type":StringNullableFilter}),
  lastName: t.field({"required":false,"type":StringNullableFilter}),
  preferredLanguage: t.field({"required":false,"type":StringNullableFilter}),
  timeformat24: t.field({"required":false,"type":BoolFilter}),
  timezone: t.field({"required":false,"type":StringFilter}),
  weekStartDate: t.field({"required":false,"type":StringFilter}),
  photoId: t.field({"required":false,"type":IntNullableFilter}),
  featureDiscovery: t.field({"required":false,"type":StringNullableListFilter}),
  emailProviders: t.field({"required":false,"type":StringNullableListFilter}),
  theme: t.field({"required":false,"type":StringNullableFilter}),
  notifications: t.field({"required":false,"type":JsonNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  userRole: t.field({"required":false,"type":EnumUserRolesFilter}),
  photo: t.field({"required":false,"type":AttachmentWhereInput}),
  accounts: t.field({"required":false,"type":AccountListRelationFilter}),
  sessions: t.field({"required":false,"type":SessionListRelationFilter}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  companiesOwned: t.field({"required":false,"type":CompanyListRelationFilter}),
});
export const UserWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserWhereInput>>('UserWhereInput').implement({
  fields: UserWhereInputFields,
});

export const UserOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  emailVerified: t.field({"required":false,"type":SortOrder}),
  image: t.field({"required":false,"type":SortOrder}),
  password: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  preferredLanguage: t.field({"required":false,"type":SortOrder}),
  timeformat24: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  weekStartDate: t.field({"required":false,"type":SortOrder}),
  photoId: t.field({"required":false,"type":SortOrder}),
  featureDiscovery: t.field({"required":false,"type":SortOrder}),
  emailProviders: t.field({"required":false,"type":SortOrder}),
  theme: t.field({"required":false,"type":SortOrder}),
  notifications: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  userRole: t.field({"required":false,"type":SortOrder}),
  photo: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
  accounts: t.field({"required":false,"type":AccountOrderByRelationAggregateInput}),
  sessions: t.field({"required":false,"type":SessionOrderByRelationAggregateInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleOrderByRelationAggregateInput}),
  companiesOwned: t.field({"required":false,"type":CompanyOrderByRelationAggregateInput}),
});
export const UserOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserOrderByWithRelationInput>>('UserOrderByWithRelationInput').implement({
  fields: UserOrderByWithRelationInputFields,
});

export const UserWhereUniqueInputFields = (t: any) => ({
  id: t.string({"required":false}),
  email: t.string({"required":false}),
  photoId: t.int({"required":false}),
  AND: t.field({"required":false,"type":[UserWhereInput]}),
  OR: t.field({"required":false,"type":[UserWhereInput]}),
  NOT: t.field({"required":false,"type":[UserWhereInput]}),
  name: t.field({"required":false,"type":StringNullableFilter}),
  emailVerified: t.field({"required":false,"type":DateTimeNullableFilter}),
  image: t.field({"required":false,"type":StringNullableFilter}),
  password: t.field({"required":false,"type":StringNullableFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  firstName: t.field({"required":false,"type":StringNullableFilter}),
  lastName: t.field({"required":false,"type":StringNullableFilter}),
  preferredLanguage: t.field({"required":false,"type":StringNullableFilter}),
  timeformat24: t.field({"required":false,"type":BoolFilter}),
  timezone: t.field({"required":false,"type":StringFilter}),
  weekStartDate: t.field({"required":false,"type":StringFilter}),
  featureDiscovery: t.field({"required":false,"type":StringNullableListFilter}),
  emailProviders: t.field({"required":false,"type":StringNullableListFilter}),
  theme: t.field({"required":false,"type":StringNullableFilter}),
  notifications: t.field({"required":false,"type":JsonNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  userRole: t.field({"required":false,"type":EnumUserRolesFilter}),
  photo: t.field({"required":false,"type":AttachmentWhereInput}),
  accounts: t.field({"required":false,"type":AccountListRelationFilter}),
  sessions: t.field({"required":false,"type":SessionListRelationFilter}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  companiesOwned: t.field({"required":false,"type":CompanyListRelationFilter}),
});
export const UserWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserWhereUniqueInput>>('UserWhereUniqueInput').implement({
  fields: UserWhereUniqueInputFields,
});

export const UserOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  emailVerified: t.field({"required":false,"type":SortOrder}),
  image: t.field({"required":false,"type":SortOrder}),
  password: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  preferredLanguage: t.field({"required":false,"type":SortOrder}),
  timeformat24: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  weekStartDate: t.field({"required":false,"type":SortOrder}),
  photoId: t.field({"required":false,"type":SortOrder}),
  featureDiscovery: t.field({"required":false,"type":SortOrder}),
  emailProviders: t.field({"required":false,"type":SortOrder}),
  theme: t.field({"required":false,"type":SortOrder}),
  notifications: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  userRole: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":UserCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":UserAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":UserMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":UserMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":UserSumOrderByAggregateInput}),
});
export const UserOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserOrderByWithAggregationInput>>('UserOrderByWithAggregationInput').implement({
  fields: UserOrderByWithAggregationInputFields,
});

export const UserScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[UserScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[UserScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[UserScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":StringWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  email: t.field({"required":false,"type":StringWithAggregatesFilter}),
  emailVerified: t.field({"required":false,"type":DateTimeNullableWithAggregatesFilter}),
  image: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  password: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  phone: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  firstName: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  lastName: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  preferredLanguage: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  timeformat24: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  timezone: t.field({"required":false,"type":StringWithAggregatesFilter}),
  weekStartDate: t.field({"required":false,"type":StringWithAggregatesFilter}),
  photoId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  featureDiscovery: t.field({"required":false,"type":StringNullableListFilter}),
  emailProviders: t.field({"required":false,"type":StringNullableListFilter}),
  theme: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  notifications: t.field({"required":false,"type":JsonNullableWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  userRole: t.field({"required":false,"type":EnumUserRolesWithAggregatesFilter}),
});
export const UserScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserScalarWhereWithAggregatesInput>>('UserScalarWhereWithAggregatesInput').implement({
  fields: UserScalarWhereWithAggregatesInputFields,
});

export const AccountWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AccountWhereInput]}),
  OR: t.field({"required":false,"type":[AccountWhereInput]}),
  NOT: t.field({"required":false,"type":[AccountWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  provider: t.field({"required":false,"type":StringFilter}),
  providerAccountId: t.field({"required":false,"type":StringFilter}),
  refresh_token: t.field({"required":false,"type":StringNullableFilter}),
  access_token: t.field({"required":false,"type":StringNullableFilter}),
  expires_at: t.field({"required":false,"type":IntNullableFilter}),
  token_type: t.field({"required":false,"type":StringNullableFilter}),
  scope: t.field({"required":false,"type":StringNullableFilter}),
  id_token: t.field({"required":false,"type":StringNullableFilter}),
  session_state: t.field({"required":false,"type":StringNullableFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
});
export const AccountWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountWhereInput>>('AccountWhereInput').implement({
  fields: AccountWhereInputFields,
});

export const AccountOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  provider: t.field({"required":false,"type":SortOrder}),
  providerAccountId: t.field({"required":false,"type":SortOrder}),
  refresh_token: t.field({"required":false,"type":SortOrder}),
  access_token: t.field({"required":false,"type":SortOrder}),
  expires_at: t.field({"required":false,"type":SortOrder}),
  token_type: t.field({"required":false,"type":SortOrder}),
  scope: t.field({"required":false,"type":SortOrder}),
  id_token: t.field({"required":false,"type":SortOrder}),
  session_state: t.field({"required":false,"type":SortOrder}),
  user: t.field({"required":false,"type":UserOrderByWithRelationInput}),
});
export const AccountOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountOrderByWithRelationInput>>('AccountOrderByWithRelationInput').implement({
  fields: AccountOrderByWithRelationInputFields,
});

export const AccountWhereUniqueInputFields = (t: any) => ({
  id: t.string({"required":false}),
  provider_providerAccountId: t.field({"required":false,"type":AccountProviderProviderAccountIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[AccountWhereInput]}),
  OR: t.field({"required":false,"type":[AccountWhereInput]}),
  NOT: t.field({"required":false,"type":[AccountWhereInput]}),
  userId: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  provider: t.field({"required":false,"type":StringFilter}),
  providerAccountId: t.field({"required":false,"type":StringFilter}),
  refresh_token: t.field({"required":false,"type":StringNullableFilter}),
  access_token: t.field({"required":false,"type":StringNullableFilter}),
  expires_at: t.field({"required":false,"type":IntNullableFilter}),
  token_type: t.field({"required":false,"type":StringNullableFilter}),
  scope: t.field({"required":false,"type":StringNullableFilter}),
  id_token: t.field({"required":false,"type":StringNullableFilter}),
  session_state: t.field({"required":false,"type":StringNullableFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
});
export const AccountWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountWhereUniqueInput>>('AccountWhereUniqueInput').implement({
  fields: AccountWhereUniqueInputFields,
});

export const AccountOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  provider: t.field({"required":false,"type":SortOrder}),
  providerAccountId: t.field({"required":false,"type":SortOrder}),
  refresh_token: t.field({"required":false,"type":SortOrder}),
  access_token: t.field({"required":false,"type":SortOrder}),
  expires_at: t.field({"required":false,"type":SortOrder}),
  token_type: t.field({"required":false,"type":SortOrder}),
  scope: t.field({"required":false,"type":SortOrder}),
  id_token: t.field({"required":false,"type":SortOrder}),
  session_state: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":AccountCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":AccountAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":AccountMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":AccountMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":AccountSumOrderByAggregateInput}),
});
export const AccountOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountOrderByWithAggregationInput>>('AccountOrderByWithAggregationInput').implement({
  fields: AccountOrderByWithAggregationInputFields,
});

export const AccountScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AccountScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[AccountScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[AccountScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":StringWithAggregatesFilter}),
  userId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
  provider: t.field({"required":false,"type":StringWithAggregatesFilter}),
  providerAccountId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  refresh_token: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  access_token: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  expires_at: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  token_type: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  scope: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  id_token: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  session_state: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
});
export const AccountScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountScalarWhereWithAggregatesInput>>('AccountScalarWhereWithAggregatesInput').implement({
  fields: AccountScalarWhereWithAggregatesInputFields,
});

export const SessionWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SessionWhereInput]}),
  OR: t.field({"required":false,"type":[SessionWhereInput]}),
  NOT: t.field({"required":false,"type":[SessionWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  sessionToken: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  expires: t.field({"required":false,"type":DateTimeFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
});
export const SessionWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionWhereInput>>('SessionWhereInput').implement({
  fields: SessionWhereInputFields,
});

export const SessionOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  sessionToken: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
  user: t.field({"required":false,"type":UserOrderByWithRelationInput}),
});
export const SessionOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionOrderByWithRelationInput>>('SessionOrderByWithRelationInput').implement({
  fields: SessionOrderByWithRelationInputFields,
});

export const SessionWhereUniqueInputFields = (t: any) => ({
  id: t.string({"required":false}),
  sessionToken: t.string({"required":false}),
  AND: t.field({"required":false,"type":[SessionWhereInput]}),
  OR: t.field({"required":false,"type":[SessionWhereInput]}),
  NOT: t.field({"required":false,"type":[SessionWhereInput]}),
  userId: t.field({"required":false,"type":StringFilter}),
  expires: t.field({"required":false,"type":DateTimeFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
});
export const SessionWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionWhereUniqueInput>>('SessionWhereUniqueInput').implement({
  fields: SessionWhereUniqueInputFields,
});

export const SessionOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  sessionToken: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":SessionCountOrderByAggregateInput}),
  _max: t.field({"required":false,"type":SessionMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":SessionMinOrderByAggregateInput}),
});
export const SessionOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionOrderByWithAggregationInput>>('SessionOrderByWithAggregationInput').implement({
  fields: SessionOrderByWithAggregationInputFields,
});

export const SessionScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SessionScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[SessionScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[SessionScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":StringWithAggregatesFilter}),
  sessionToken: t.field({"required":false,"type":StringWithAggregatesFilter}),
  userId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  expires: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const SessionScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionScalarWhereWithAggregatesInput>>('SessionScalarWhereWithAggregatesInput').implement({
  fields: SessionScalarWhereWithAggregatesInputFields,
});

export const VerificationTokenWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  OR: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  NOT: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  identifier: t.field({"required":false,"type":StringFilter}),
  token: t.field({"required":false,"type":StringFilter}),
  expires: t.field({"required":false,"type":DateTimeFilter}),
});
export const VerificationTokenWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenWhereInput>>('VerificationTokenWhereInput').implement({
  fields: VerificationTokenWhereInputFields,
});

export const VerificationTokenOrderByWithRelationInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":SortOrder}),
  token: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const VerificationTokenOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenOrderByWithRelationInput>>('VerificationTokenOrderByWithRelationInput').implement({
  fields: VerificationTokenOrderByWithRelationInputFields,
});

export const VerificationTokenWhereUniqueInputFields = (t: any) => ({
  token: t.string({"required":false}),
  identifier_token: t.field({"required":false,"type":VerificationTokenIdentifierTokenCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  OR: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  NOT: t.field({"required":false,"type":[VerificationTokenWhereInput]}),
  identifier: t.field({"required":false,"type":StringFilter}),
  expires: t.field({"required":false,"type":DateTimeFilter}),
});
export const VerificationTokenWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenWhereUniqueInput>>('VerificationTokenWhereUniqueInput').implement({
  fields: VerificationTokenWhereUniqueInputFields,
});

export const VerificationTokenOrderByWithAggregationInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":SortOrder}),
  token: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":VerificationTokenCountOrderByAggregateInput}),
  _max: t.field({"required":false,"type":VerificationTokenMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":VerificationTokenMinOrderByAggregateInput}),
});
export const VerificationTokenOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenOrderByWithAggregationInput>>('VerificationTokenOrderByWithAggregationInput').implement({
  fields: VerificationTokenOrderByWithAggregationInputFields,
});

export const VerificationTokenScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[VerificationTokenScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[VerificationTokenScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[VerificationTokenScalarWhereWithAggregatesInput]}),
  identifier: t.field({"required":false,"type":StringWithAggregatesFilter}),
  token: t.field({"required":false,"type":StringWithAggregatesFilter}),
  expires: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const VerificationTokenScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenScalarWhereWithAggregatesInput>>('VerificationTokenScalarWhereWithAggregatesInput').implement({
  fields: VerificationTokenScalarWhereWithAggregatesInputFields,
});

export const AttachmentWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AttachmentWhereInput]}),
  OR: t.field({"required":false,"type":[AttachmentWhereInput]}),
  NOT: t.field({"required":false,"type":[AttachmentWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  contentType: t.field({"required":false,"type":StringFilter}),
  filename: t.field({"required":false,"type":StringFilter}),
  path: t.field({"required":false,"type":StringFilter}),
  size: t.field({"required":false,"type":IntNullableFilter}),
  uploaderId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  userProfilePhoto: t.field({"required":false,"type":UserWhereInput}),
  candidateCv: t.field({"required":false,"type":CandidateWhereInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateWhereInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateWhereInput}),
  companyLogo: t.field({"required":false,"type":CompanyWhereInput}),
  uploader: t.field({"required":false,"type":HiringRoleWhereInput}),
  offerFiles: t.field({"required":false,"type":OfferFileListRelationFilter}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const AttachmentWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentWhereInput>>('AttachmentWhereInput').implement({
  fields: AttachmentWhereInputFields,
});

export const AttachmentOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  contentType: t.field({"required":false,"type":SortOrder}),
  filename: t.field({"required":false,"type":SortOrder}),
  path: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userProfilePhoto: t.field({"required":false,"type":UserOrderByWithRelationInput}),
  candidateCv: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  companyLogo: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  uploader: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  offerFiles: t.field({"required":false,"type":OfferFileOrderByRelationAggregateInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileOrderByRelationAggregateInput}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
});
export const AttachmentOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentOrderByWithRelationInput>>('AttachmentOrderByWithRelationInput').implement({
  fields: AttachmentOrderByWithRelationInputFields,
});

export const AttachmentWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[AttachmentWhereInput]}),
  OR: t.field({"required":false,"type":[AttachmentWhereInput]}),
  NOT: t.field({"required":false,"type":[AttachmentWhereInput]}),
  contentType: t.field({"required":false,"type":StringFilter}),
  filename: t.field({"required":false,"type":StringFilter}),
  path: t.field({"required":false,"type":StringFilter}),
  size: t.field({"required":false,"type":IntNullableFilter}),
  uploaderId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  userProfilePhoto: t.field({"required":false,"type":UserWhereInput}),
  candidateCv: t.field({"required":false,"type":CandidateWhereInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateWhereInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateWhereInput}),
  companyLogo: t.field({"required":false,"type":CompanyWhereInput}),
  uploader: t.field({"required":false,"type":HiringRoleWhereInput}),
  offerFiles: t.field({"required":false,"type":OfferFileListRelationFilter}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const AttachmentWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentWhereUniqueInput>>('AttachmentWhereUniqueInput').implement({
  fields: AttachmentWhereUniqueInputFields,
});

export const AttachmentOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  contentType: t.field({"required":false,"type":SortOrder}),
  filename: t.field({"required":false,"type":SortOrder}),
  path: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":AttachmentCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":AttachmentAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":AttachmentMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":AttachmentMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":AttachmentSumOrderByAggregateInput}),
});
export const AttachmentOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentOrderByWithAggregationInput>>('AttachmentOrderByWithAggregationInput').implement({
  fields: AttachmentOrderByWithAggregationInputFields,
});

export const AttachmentScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AttachmentScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[AttachmentScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[AttachmentScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  contentType: t.field({"required":false,"type":StringWithAggregatesFilter}),
  filename: t.field({"required":false,"type":StringWithAggregatesFilter}),
  path: t.field({"required":false,"type":StringWithAggregatesFilter}),
  size: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  uploaderId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const AttachmentScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentScalarWhereWithAggregatesInput>>('AttachmentScalarWhereWithAggregatesInput').implement({
  fields: AttachmentScalarWhereWithAggregatesInputFields,
});

export const HiringRoleWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  OR: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  NOT: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  roleId: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  extraAbilities: t.field({"required":false,"type":StringNullableListFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  attachments: t.field({"required":false,"type":AttachmentListRelationFilter}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerListRelationFilter}),
  createdEvents: t.field({"required":false,"type":EventListRelationFilter}),
  offerRecruiter: t.field({"required":false,"type":OfferWhereInput}),
  offerHiringManager: t.field({"required":false,"type":OfferWhereInput}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
  hiredCandidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskMemberListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  interviewerEvents: t.field({"required":false,"type":EventListRelationFilter}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerListRelationFilter}),
});
export const HiringRoleWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleWhereInput>>('HiringRoleWhereInput').implement({
  fields: HiringRoleWhereInputFields,
});

export const HiringRoleOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  extraAbilities: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  user: t.field({"required":false,"type":UserOrderByWithRelationInput}),
  role: t.field({"required":false,"type":RoleOrderByWithRelationInput}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  attachments: t.field({"required":false,"type":AttachmentOrderByRelationAggregateInput}),
  auditLogs: t.field({"required":false,"type":AuditLogOrderByRelationAggregateInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerOrderByRelationAggregateInput}),
  createdEvents: t.field({"required":false,"type":EventOrderByRelationAggregateInput}),
  offerRecruiter: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  offerHiringManager: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  memberships: t.field({"required":false,"type":MembershipOrderByRelationAggregateInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityOrderByRelationAggregateInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateOrderByRelationAggregateInput}),
  evaluations: t.field({"required":false,"type":EvaluationOrderByRelationAggregateInput}),
  tasks: t.field({"required":false,"type":TaskMemberOrderByRelationAggregateInput}),
  follows: t.field({"required":false,"type":FollowOrderByRelationAggregateInput}),
  interviewerEvents: t.field({"required":false,"type":EventOrderByRelationAggregateInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerOrderByRelationAggregateInput}),
});
export const HiringRoleOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleOrderByWithRelationInput>>('HiringRoleOrderByWithRelationInput').implement({
  fields: HiringRoleOrderByWithRelationInputFields,
});

export const HiringRoleWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  userId_companyId: t.field({"required":false,"type":HiringRoleUserIdCompanyIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  OR: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  NOT: t.field({"required":false,"type":[HiringRoleWhereInput]}),
  userId: t.field({"required":false,"type":StringFilter}),
  roleId: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  extraAbilities: t.field({"required":false,"type":StringNullableListFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  user: t.field({"required":false,"type":UserWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  attachments: t.field({"required":false,"type":AttachmentListRelationFilter}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerListRelationFilter}),
  createdEvents: t.field({"required":false,"type":EventListRelationFilter}),
  offerRecruiter: t.field({"required":false,"type":OfferWhereInput}),
  offerHiringManager: t.field({"required":false,"type":OfferWhereInput}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
  hiredCandidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskMemberListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  interviewerEvents: t.field({"required":false,"type":EventListRelationFilter}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerListRelationFilter}),
});
export const HiringRoleWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleWhereUniqueInput>>('HiringRoleWhereUniqueInput').implement({
  fields: HiringRoleWhereUniqueInputFields,
});

export const HiringRoleOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  extraAbilities: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":HiringRoleCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":HiringRoleAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":HiringRoleMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":HiringRoleMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":HiringRoleSumOrderByAggregateInput}),
});
export const HiringRoleOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleOrderByWithAggregationInput>>('HiringRoleOrderByWithAggregationInput').implement({
  fields: HiringRoleOrderByWithAggregationInputFields,
});

export const HiringRoleScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[HiringRoleScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[HiringRoleScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[HiringRoleScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  userId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  roleId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  extraAbilities: t.field({"required":false,"type":StringNullableListFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const HiringRoleScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleScalarWhereWithAggregatesInput>>('HiringRoleScalarWhereWithAggregatesInput').implement({
  fields: HiringRoleScalarWhereWithAggregatesInputFields,
});

export const RoleWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[RoleWhereInput]}),
  OR: t.field({"required":false,"type":[RoleWhereInput]}),
  NOT: t.field({"required":false,"type":[RoleWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  abilities: t.field({"required":false,"type":StringNullableListFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
});
export const RoleWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleWhereInput>>('RoleWhereInput').implement({
  fields: RoleWhereInputFields,
});

export const RoleOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  abilities: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleOrderByRelationAggregateInput}),
  memberships: t.field({"required":false,"type":MembershipOrderByRelationAggregateInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityOrderByRelationAggregateInput}),
});
export const RoleOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleOrderByWithRelationInput>>('RoleOrderByWithRelationInput').implement({
  fields: RoleOrderByWithRelationInputFields,
});

export const RoleWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[RoleWhereInput]}),
  OR: t.field({"required":false,"type":[RoleWhereInput]}),
  NOT: t.field({"required":false,"type":[RoleWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  abilities: t.field({"required":false,"type":StringNullableListFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
});
export const RoleWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleWhereUniqueInput>>('RoleWhereUniqueInput').implement({
  fields: RoleWhereUniqueInputFields,
});

export const RoleOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  abilities: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":RoleCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":RoleAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":RoleMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":RoleMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":RoleSumOrderByAggregateInput}),
});
export const RoleOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleOrderByWithAggregationInput>>('RoleOrderByWithAggregationInput').implement({
  fields: RoleOrderByWithAggregationInputFields,
});

export const RoleScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[RoleScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[RoleScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[RoleScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  abilities: t.field({"required":false,"type":StringNullableListFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const RoleScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleScalarWhereWithAggregatesInput>>('RoleScalarWhereWithAggregatesInput').implement({
  fields: RoleScalarWhereWithAggregatesInputFields,
});

export const CompanyWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  address: t.field({"required":false,"type":StringNullableFilter}),
  city: t.field({"required":false,"type":StringNullableFilter}),
  state: t.field({"required":false,"type":StringNullableFilter}),
  country: t.field({"required":false,"type":StringNullableFilter}),
  companyInbox: t.field({"required":false,"type":StringNullableFilter}),
  subdomain: t.field({"required":false,"type":StringNullableFilter}),
  gdprEnable: t.field({"required":false,"type":BoolNullableFilter}),
  gdprRetention: t.field({"required":false,"type":IntNullableFilter}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":StringNullableFilter}),
  gdprEmailFooter: t.field({"required":false,"type":StringNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  ownerId: t.field({"required":false,"type":StringFilter}),
  logoId: t.field({"required":false,"type":IntNullableFilter}),
  roles: t.field({"required":false,"type":RoleListRelationFilter}),
  subscription: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomListRelationFilter}),
  metadata: t.field({"required":false,"type":CompanyMetadataListRelationFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleListRelationFilter}),
  events: t.field({"required":false,"type":EventListRelationFilter}),
  departments: t.field({"required":false,"type":DepartmentListRelationFilter}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonListRelationFilter}),
  tagSources: t.field({"required":false,"type":TagSourceListRelationFilter}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  offers: t.field({"required":false,"type":OfferListRelationFilter}),
  templates: t.field({"required":false,"type":TemplateListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskListRelationFilter}),
  owner: t.field({"required":false,"type":UserWhereInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  candidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  TalentPool: t.field({"required":false,"type":TalentPoolListRelationFilter}),
  CustomFields: t.field({"required":false,"type":CustomFieldListRelationFilter}),
  logo: t.field({"required":false,"type":AttachmentWhereInput}),
  attachments: t.field({"required":false,"type":AttachmentListRelationFilter}),
});
export const CompanyWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyWhereInput>>('CompanyWhereInput').implement({
  fields: CompanyWhereInputFields,
});

export const CompanyOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  address: t.field({"required":false,"type":SortOrder}),
  city: t.field({"required":false,"type":SortOrder}),
  state: t.field({"required":false,"type":SortOrder}),
  country: t.field({"required":false,"type":SortOrder}),
  companyInbox: t.field({"required":false,"type":SortOrder}),
  subdomain: t.field({"required":false,"type":SortOrder}),
  gdprEnable: t.field({"required":false,"type":SortOrder}),
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":SortOrder}),
  gdprEmailFooter: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  ownerId: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
  roles: t.field({"required":false,"type":RoleOrderByRelationAggregateInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataOrderByWithRelationInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomOrderByRelationAggregateInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataOrderByRelationAggregateInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleOrderByRelationAggregateInput}),
  events: t.field({"required":false,"type":EventOrderByRelationAggregateInput}),
  departments: t.field({"required":false,"type":DepartmentOrderByRelationAggregateInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonOrderByRelationAggregateInput}),
  tagSources: t.field({"required":false,"type":TagSourceOrderByRelationAggregateInput}),
  auditLogs: t.field({"required":false,"type":AuditLogOrderByRelationAggregateInput}),
  offers: t.field({"required":false,"type":OfferOrderByRelationAggregateInput}),
  templates: t.field({"required":false,"type":TemplateOrderByRelationAggregateInput}),
  tasks: t.field({"required":false,"type":TaskOrderByRelationAggregateInput}),
  owner: t.field({"required":false,"type":UserOrderByWithRelationInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleOrderByRelationAggregateInput}),
  candidates: t.field({"required":false,"type":CandidateOrderByRelationAggregateInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolOrderByRelationAggregateInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldOrderByRelationAggregateInput}),
  logo: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
  attachments: t.field({"required":false,"type":AttachmentOrderByRelationAggregateInput}),
});
export const CompanyOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyOrderByWithRelationInput>>('CompanyOrderByWithRelationInput').implement({
  fields: CompanyOrderByWithRelationInputFields,
});

export const CompanyWhereUniqueInputFields = (t: any) => ({
  id: t.string({"required":false}),
  logoId: t.int({"required":false}),
  AND: t.field({"required":false,"type":[CompanyWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  address: t.field({"required":false,"type":StringNullableFilter}),
  city: t.field({"required":false,"type":StringNullableFilter}),
  state: t.field({"required":false,"type":StringNullableFilter}),
  country: t.field({"required":false,"type":StringNullableFilter}),
  companyInbox: t.field({"required":false,"type":StringNullableFilter}),
  subdomain: t.field({"required":false,"type":StringNullableFilter}),
  gdprEnable: t.field({"required":false,"type":BoolNullableFilter}),
  gdprRetention: t.field({"required":false,"type":IntNullableFilter}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":StringNullableFilter}),
  gdprEmailFooter: t.field({"required":false,"type":StringNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  ownerId: t.field({"required":false,"type":StringFilter}),
  roles: t.field({"required":false,"type":RoleListRelationFilter}),
  subscription: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomListRelationFilter}),
  metadata: t.field({"required":false,"type":CompanyMetadataListRelationFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleListRelationFilter}),
  events: t.field({"required":false,"type":EventListRelationFilter}),
  departments: t.field({"required":false,"type":DepartmentListRelationFilter}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonListRelationFilter}),
  tagSources: t.field({"required":false,"type":TagSourceListRelationFilter}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  offers: t.field({"required":false,"type":OfferListRelationFilter}),
  templates: t.field({"required":false,"type":TemplateListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskListRelationFilter}),
  owner: t.field({"required":false,"type":UserWhereInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  candidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  TalentPool: t.field({"required":false,"type":TalentPoolListRelationFilter}),
  CustomFields: t.field({"required":false,"type":CustomFieldListRelationFilter}),
  logo: t.field({"required":false,"type":AttachmentWhereInput}),
  attachments: t.field({"required":false,"type":AttachmentListRelationFilter}),
});
export const CompanyWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyWhereUniqueInput>>('CompanyWhereUniqueInput').implement({
  fields: CompanyWhereUniqueInputFields,
});

export const CompanyOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  address: t.field({"required":false,"type":SortOrder}),
  city: t.field({"required":false,"type":SortOrder}),
  state: t.field({"required":false,"type":SortOrder}),
  country: t.field({"required":false,"type":SortOrder}),
  companyInbox: t.field({"required":false,"type":SortOrder}),
  subdomain: t.field({"required":false,"type":SortOrder}),
  gdprEnable: t.field({"required":false,"type":SortOrder}),
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":SortOrder}),
  gdprEmailFooter: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  ownerId: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CompanyCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CompanyAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CompanyMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CompanyMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CompanySumOrderByAggregateInput}),
});
export const CompanyOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyOrderByWithAggregationInput>>('CompanyOrderByWithAggregationInput').implement({
  fields: CompanyOrderByWithAggregationInputFields,
});

export const CompanyScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CompanyScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CompanyScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":StringWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  phone: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  address: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  city: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  state: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  country: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  companyInbox: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  subdomain: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  gdprEnable: t.field({"required":false,"type":BoolNullableWithAggregatesFilter}),
  gdprRetention: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  gdprEmailFooter: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  ownerId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  logoId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
});
export const CompanyScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyScalarWhereWithAggregatesInput>>('CompanyScalarWhereWithAggregatesInput').implement({
  fields: CompanyScalarWhereWithAggregatesInputFields,
});

export const SubscriptionDataWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  OR: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  NOT: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  active: t.field({"required":false,"type":BoolFilter}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeFilter}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeFilter}),
  status: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const SubscriptionDataWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataWhereInput>>('SubscriptionDataWhereInput').implement({
  fields: SubscriptionDataWhereInputFields,
});

export const SubscriptionDataOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  active: t.field({"required":false,"type":SortOrder}),
  currentPeriodStart: t.field({"required":false,"type":SortOrder}),
  currentPeriodEnd: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
});
export const SubscriptionDataOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataOrderByWithRelationInput>>('SubscriptionDataOrderByWithRelationInput').implement({
  fields: SubscriptionDataOrderByWithRelationInputFields,
});

export const SubscriptionDataWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":false}),
  AND: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  OR: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  NOT: t.field({"required":false,"type":[SubscriptionDataWhereInput]}),
  active: t.field({"required":false,"type":BoolFilter}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeFilter}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeFilter}),
  status: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const SubscriptionDataWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataWhereUniqueInput>>('SubscriptionDataWhereUniqueInput').implement({
  fields: SubscriptionDataWhereUniqueInputFields,
});

export const SubscriptionDataOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  active: t.field({"required":false,"type":SortOrder}),
  currentPeriodStart: t.field({"required":false,"type":SortOrder}),
  currentPeriodEnd: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":SubscriptionDataCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":SubscriptionDataAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":SubscriptionDataMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":SubscriptionDataMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":SubscriptionDataSumOrderByAggregateInput}),
});
export const SubscriptionDataOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataOrderByWithAggregationInput>>('SubscriptionDataOrderByWithAggregationInput').implement({
  fields: SubscriptionDataOrderByWithAggregationInputFields,
});

export const SubscriptionDataScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SubscriptionDataScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[SubscriptionDataScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[SubscriptionDataScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  active: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  status: t.field({"required":false,"type":StringWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const SubscriptionDataScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataScalarWhereWithAggregatesInput>>('SubscriptionDataScalarWhereWithAggregatesInput').implement({
  fields: SubscriptionDataScalarWhereWithAggregatesInputFields,
});

export const CompanyMetadataWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  value: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyMetadataWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataWhereInput>>('CompanyMetadataWhereInput').implement({
  fields: CompanyMetadataWhereInputFields,
});

export const CompanyMetadataOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
});
export const CompanyMetadataOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataOrderByWithRelationInput>>('CompanyMetadataOrderByWithRelationInput').implement({
  fields: CompanyMetadataOrderByWithRelationInputFields,
});

export const CompanyMetadataWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId_key: t.field({"required":false,"type":CompanyMetadataCompanyIdKeyCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyMetadataWhereInput]}),
  companyId: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  value: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyMetadataWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataWhereUniqueInput>>('CompanyMetadataWhereUniqueInput').implement({
  fields: CompanyMetadataWhereUniqueInputFields,
});

export const CompanyMetadataOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CompanyMetadataCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CompanyMetadataAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CompanyMetadataMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CompanyMetadataMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CompanyMetadataSumOrderByAggregateInput}),
});
export const CompanyMetadataOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataOrderByWithAggregationInput>>('CompanyMetadataOrderByWithAggregationInput').implement({
  fields: CompanyMetadataOrderByWithAggregationInputFields,
});

export const CompanyMetadataScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyMetadataScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CompanyMetadataScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CompanyMetadataScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  key: t.field({"required":false,"type":StringWithAggregatesFilter}),
  value: t.field({"required":false,"type":StringWithAggregatesFilter}),
  settings: t.field({"required":false,"type":JsonNullableWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const CompanyMetadataScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataScalarWhereWithAggregatesInput>>('CompanyMetadataScalarWhereWithAggregatesInput').implement({
  fields: CompanyMetadataScalarWhereWithAggregatesInputFields,
});

export const DepartmentWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DepartmentWhereInput]}),
  OR: t.field({"required":false,"type":[DepartmentWhereInput]}),
  NOT: t.field({"required":false,"type":[DepartmentWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  offers: t.field({"required":false,"type":OfferListRelationFilter}),
});
export const DepartmentWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentWhereInput>>('DepartmentWhereInput').implement({
  fields: DepartmentWhereInputFields,
});

export const DepartmentOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  offers: t.field({"required":false,"type":OfferOrderByRelationAggregateInput}),
});
export const DepartmentOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentOrderByWithRelationInput>>('DepartmentOrderByWithRelationInput').implement({
  fields: DepartmentOrderByWithRelationInputFields,
});

export const DepartmentWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[DepartmentWhereInput]}),
  OR: t.field({"required":false,"type":[DepartmentWhereInput]}),
  NOT: t.field({"required":false,"type":[DepartmentWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  offers: t.field({"required":false,"type":OfferListRelationFilter}),
});
export const DepartmentWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentWhereUniqueInput>>('DepartmentWhereUniqueInput').implement({
  fields: DepartmentWhereUniqueInputFields,
});

export const DepartmentOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":DepartmentCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":DepartmentAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":DepartmentMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":DepartmentMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":DepartmentSumOrderByAggregateInput}),
});
export const DepartmentOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentOrderByWithAggregationInput>>('DepartmentOrderByWithAggregationInput').implement({
  fields: DepartmentOrderByWithAggregationInputFields,
});

export const DepartmentScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DepartmentScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[DepartmentScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[DepartmentScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const DepartmentScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentScalarWhereWithAggregatesInput>>('DepartmentScalarWhereWithAggregatesInput').implement({
  fields: DepartmentScalarWhereWithAggregatesInputFields,
});

export const DisqualifyReasonWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  OR: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  NOT: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":JsonFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
});
export const DisqualifyReasonWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonWhereInput>>('DisqualifyReasonWhereInput').implement({
  fields: DisqualifyReasonWhereInputFields,
});

export const DisqualifyReasonOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  matches: t.field({"required":false,"type":MatchOrderByRelationAggregateInput}),
});
export const DisqualifyReasonOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonOrderByWithRelationInput>>('DisqualifyReasonOrderByWithRelationInput').implement({
  fields: DisqualifyReasonOrderByWithRelationInputFields,
});

export const DisqualifyReasonWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  OR: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  NOT: t.field({"required":false,"type":[DisqualifyReasonWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":JsonFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
});
export const DisqualifyReasonWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonWhereUniqueInput>>('DisqualifyReasonWhereUniqueInput').implement({
  fields: DisqualifyReasonWhereUniqueInputFields,
});

export const DisqualifyReasonOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":DisqualifyReasonCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":DisqualifyReasonAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":DisqualifyReasonMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":DisqualifyReasonMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":DisqualifyReasonSumOrderByAggregateInput}),
});
export const DisqualifyReasonOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonOrderByWithAggregationInput>>('DisqualifyReasonOrderByWithAggregationInput').implement({
  fields: DisqualifyReasonOrderByWithAggregationInputFields,
});

export const DisqualifyReasonScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DisqualifyReasonScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[DisqualifyReasonScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[DisqualifyReasonScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  action: t.field({"required":false,"type":JsonWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const DisqualifyReasonScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonScalarWhereWithAggregatesInput>>('DisqualifyReasonScalarWhereWithAggregatesInput').implement({
  fields: DisqualifyReasonScalarWhereWithAggregatesInputFields,
});

export const TagSourceWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TagSourceWhereInput]}),
  OR: t.field({"required":false,"type":[TagSourceWhereInput]}),
  NOT: t.field({"required":false,"type":[TagSourceWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  offerTags: t.field({"required":false,"type":OfferTagListRelationFilter}),
  candidateReferrer: t.field({"required":false,"type":CandidateListRelationFilter}),
  candidateTags: t.field({"required":false,"type":CandidateTagListRelationFilter}),
});
export const TagSourceWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceWhereInput>>('TagSourceWhereInput').implement({
  fields: TagSourceWhereInputFields,
});

export const TagSourceOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  offerTags: t.field({"required":false,"type":OfferTagOrderByRelationAggregateInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateOrderByRelationAggregateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagOrderByRelationAggregateInput}),
});
export const TagSourceOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceOrderByWithRelationInput>>('TagSourceOrderByWithRelationInput').implement({
  fields: TagSourceOrderByWithRelationInputFields,
});

export const TagSourceWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId_type_name: t.field({"required":false,"type":TagSourceCompanyIdTypeNameCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[TagSourceWhereInput]}),
  OR: t.field({"required":false,"type":[TagSourceWhereInput]}),
  NOT: t.field({"required":false,"type":[TagSourceWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  offerTags: t.field({"required":false,"type":OfferTagListRelationFilter}),
  candidateReferrer: t.field({"required":false,"type":CandidateListRelationFilter}),
  candidateTags: t.field({"required":false,"type":CandidateTagListRelationFilter}),
});
export const TagSourceWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceWhereUniqueInput>>('TagSourceWhereUniqueInput').implement({
  fields: TagSourceWhereUniqueInputFields,
});

export const TagSourceOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TagSourceCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TagSourceAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TagSourceMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TagSourceMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TagSourceSumOrderByAggregateInput}),
});
export const TagSourceOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceOrderByWithAggregationInput>>('TagSourceOrderByWithAggregationInput').implement({
  fields: TagSourceOrderByWithAggregationInputFields,
});

export const TagSourceScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TagSourceScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TagSourceScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TagSourceScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  type: t.field({"required":false,"type":EnumTagSourceTypeWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const TagSourceScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceScalarWhereWithAggregatesInput>>('TagSourceScalarWhereWithAggregatesInput').implement({
  fields: TagSourceScalarWhereWithAggregatesInputFields,
});

export const AuditLogWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AuditLogWhereInput]}),
  OR: t.field({"required":false,"type":[AuditLogWhereInput]}),
  NOT: t.field({"required":false,"type":[AuditLogWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  actor: t.field({"required":false,"type":StringFilter}),
  actorType: t.field({"required":false,"type":StringFilter}),
  ip: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":StringFilter}),
  eventDetails: t.field({"required":false,"type":JsonFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  user: t.field({"required":false,"type":HiringRoleWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const AuditLogWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogWhereInput>>('AuditLogWhereInput').implement({
  fields: AuditLogWhereInputFields,
});

export const AuditLogOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  actor: t.field({"required":false,"type":SortOrder}),
  actorType: t.field({"required":false,"type":SortOrder}),
  ip: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  eventDetails: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  user: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
});
export const AuditLogOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogOrderByWithRelationInput>>('AuditLogOrderByWithRelationInput').implement({
  fields: AuditLogOrderByWithRelationInputFields,
});

export const AuditLogWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[AuditLogWhereInput]}),
  OR: t.field({"required":false,"type":[AuditLogWhereInput]}),
  NOT: t.field({"required":false,"type":[AuditLogWhereInput]}),
  companyId: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  actor: t.field({"required":false,"type":StringFilter}),
  actorType: t.field({"required":false,"type":StringFilter}),
  ip: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":StringFilter}),
  eventDetails: t.field({"required":false,"type":JsonFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  user: t.field({"required":false,"type":HiringRoleWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const AuditLogWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogWhereUniqueInput>>('AuditLogWhereUniqueInput').implement({
  fields: AuditLogWhereUniqueInputFields,
});

export const AuditLogOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  actor: t.field({"required":false,"type":SortOrder}),
  actorType: t.field({"required":false,"type":SortOrder}),
  ip: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  eventDetails: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":AuditLogCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":AuditLogAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":AuditLogMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":AuditLogMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":AuditLogSumOrderByAggregateInput}),
});
export const AuditLogOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogOrderByWithAggregationInput>>('AuditLogOrderByWithAggregationInput').implement({
  fields: AuditLogOrderByWithAggregationInputFields,
});

export const AuditLogScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AuditLogScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[AuditLogScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[AuditLogScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  userId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  actor: t.field({"required":false,"type":StringWithAggregatesFilter}),
  actorType: t.field({"required":false,"type":StringWithAggregatesFilter}),
  ip: t.field({"required":false,"type":StringWithAggregatesFilter}),
  action: t.field({"required":false,"type":StringWithAggregatesFilter}),
  eventDetails: t.field({"required":false,"type":JsonWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const AuditLogScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogScalarWhereWithAggregatesInput>>('AuditLogScalarWhereWithAggregatesInput').implement({
  fields: AuditLogScalarWhereWithAggregatesInputFields,
});

export const MeetingRoomWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  OR: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  NOT: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const MeetingRoomWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomWhereInput>>('MeetingRoomWhereInput').implement({
  fields: MeetingRoomWhereInputFields,
});

export const MeetingRoomOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
});
export const MeetingRoomOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomOrderByWithRelationInput>>('MeetingRoomOrderByWithRelationInput').implement({
  fields: MeetingRoomOrderByWithRelationInputFields,
});

export const MeetingRoomWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  OR: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  NOT: t.field({"required":false,"type":[MeetingRoomWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const MeetingRoomWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomWhereUniqueInput>>('MeetingRoomWhereUniqueInput').implement({
  fields: MeetingRoomWhereUniqueInputFields,
});

export const MeetingRoomOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":MeetingRoomCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":MeetingRoomAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":MeetingRoomMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":MeetingRoomMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":MeetingRoomSumOrderByAggregateInput}),
});
export const MeetingRoomOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomOrderByWithAggregationInput>>('MeetingRoomOrderByWithAggregationInput').implement({
  fields: MeetingRoomOrderByWithAggregationInputFields,
});

export const MeetingRoomScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MeetingRoomScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[MeetingRoomScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[MeetingRoomScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
  link: t.field({"required":false,"type":StringWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const MeetingRoomScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomScalarWhereWithAggregatesInput>>('MeetingRoomScalarWhereWithAggregatesInput').implement({
  fields: MeetingRoomScalarWhereWithAggregatesInputFields,
});

export const EventScheduleWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  dateRange: t.field({"required":false,"type":IntFilter}),
  expiresAfter: t.field({"required":false,"type":IntFilter}),
  inviteAll: t.field({"required":false,"type":BoolFilter}),
  bufferTime: t.field({"required":false,"type":IntFilter}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFilter}),
  meetingLimit: t.field({"required":false,"type":IntFilter}),
  duration: t.field({"required":false,"type":IntFilter}),
  Interval: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  timezone: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  privateNote: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerListRelationFilter}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationListRelationFilter}),
});
export const EventScheduleWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleWhereInput>>('EventScheduleWhereInput').implement({
  fields: EventScheduleWhereInputFields,
});

export const EventScheduleOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  inviteAll: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  ignoreDayEvents: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerOrderByRelationAggregateInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationOrderByRelationAggregateInput}),
});
export const EventScheduleOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleOrderByWithRelationInput>>('EventScheduleOrderByWithRelationInput').implement({
  fields: EventScheduleOrderByWithRelationInputFields,
});

export const EventScheduleWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  dateRange: t.field({"required":false,"type":IntFilter}),
  expiresAfter: t.field({"required":false,"type":IntFilter}),
  inviteAll: t.field({"required":false,"type":BoolFilter}),
  bufferTime: t.field({"required":false,"type":IntFilter}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFilter}),
  meetingLimit: t.field({"required":false,"type":IntFilter}),
  duration: t.field({"required":false,"type":IntFilter}),
  Interval: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  timezone: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  privateNote: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerListRelationFilter}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationListRelationFilter}),
});
export const EventScheduleWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleWhereUniqueInput>>('EventScheduleWhereUniqueInput').implement({
  fields: EventScheduleWhereUniqueInputFields,
});

export const EventScheduleOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  inviteAll: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  ignoreDayEvents: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EventScheduleCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EventScheduleAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EventScheduleMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EventScheduleMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EventScheduleSumOrderByAggregateInput}),
});
export const EventScheduleOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleOrderByWithAggregationInput>>('EventScheduleOrderByWithAggregationInput').implement({
  fields: EventScheduleOrderByWithAggregationInputFields,
});

export const EventScheduleScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EventScheduleScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  dateRange: t.field({"required":false,"type":IntWithAggregatesFilter}),
  expiresAfter: t.field({"required":false,"type":IntWithAggregatesFilter}),
  inviteAll: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  bufferTime: t.field({"required":false,"type":IntWithAggregatesFilter}),
  ignoreDayEvents: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  meetingLimit: t.field({"required":false,"type":IntWithAggregatesFilter}),
  duration: t.field({"required":false,"type":IntWithAggregatesFilter}),
  Interval: t.field({"required":false,"type":IntWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
  timezone: t.field({"required":false,"type":StringWithAggregatesFilter}),
  location: t.field({"required":false,"type":StringWithAggregatesFilter}),
  note: t.field({"required":false,"type":StringWithAggregatesFilter}),
  privateNote: t.field({"required":false,"type":StringWithAggregatesFilter}),
  link: t.field({"required":false,"type":StringWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const EventScheduleScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleScalarWhereWithAggregatesInput>>('EventScheduleScalarWhereWithAggregatesInput').implement({
  fields: EventScheduleScalarWhereWithAggregatesInputFields,
});

export const EventScheduleInterviewerWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  availability: t.field({"required":false,"type":JsonFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const EventScheduleInterviewerWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerWhereInput>>('EventScheduleInterviewerWhereInput').implement({
  fields: EventScheduleInterviewerWhereInputFields,
});

export const EventScheduleInterviewerOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  availability: t.field({"required":false,"type":SortOrder}),
  eventSchedule: t.field({"required":false,"type":EventScheduleOrderByWithRelationInput}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
});
export const EventScheduleInterviewerOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerOrderByWithRelationInput>>('EventScheduleInterviewerOrderByWithRelationInput').implement({
  fields: EventScheduleInterviewerOrderByWithRelationInputFields,
});

export const EventScheduleInterviewerWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleInterviewerWhereInput]}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  availability: t.field({"required":false,"type":JsonFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const EventScheduleInterviewerWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerWhereUniqueInput>>('EventScheduleInterviewerWhereUniqueInput').implement({
  fields: EventScheduleInterviewerWhereUniqueInputFields,
});

export const EventScheduleInterviewerOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  availability: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EventScheduleInterviewerCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EventScheduleInterviewerAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EventScheduleInterviewerMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EventScheduleInterviewerMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EventScheduleInterviewerSumOrderByAggregateInput}),
});
export const EventScheduleInterviewerOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerOrderByWithAggregationInput>>('EventScheduleInterviewerOrderByWithAggregationInput').implement({
  fields: EventScheduleInterviewerOrderByWithAggregationInputFields,
});

export const EventScheduleInterviewerScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  eventScheduleId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  availability: t.field({"required":false,"type":JsonWithAggregatesFilter}),
});
export const EventScheduleInterviewerScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerScalarWhereWithAggregatesInput>>('EventScheduleInterviewerScalarWhereWithAggregatesInput').implement({
  fields: EventScheduleInterviewerScalarWhereWithAggregatesInputFields,
});

export const EventScheduleEvaluationWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleWhereInput}),
  evaluation: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EventScheduleEvaluationWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationWhereInput>>('EventScheduleEvaluationWhereInput').implement({
  fields: EventScheduleEvaluationWhereInputFields,
});

export const EventScheduleEvaluationOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  eventSchedule: t.field({"required":false,"type":EventScheduleOrderByWithRelationInput}),
  evaluation: t.field({"required":false,"type":EvaluationOrderByWithRelationInput}),
});
export const EventScheduleEvaluationOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationOrderByWithRelationInput>>('EventScheduleEvaluationOrderByWithRelationInput').implement({
  fields: EventScheduleEvaluationOrderByWithRelationInputFields,
});

export const EventScheduleEvaluationWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleEvaluationWhereInput]}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
  eventSchedule: t.field({"required":false,"type":EventScheduleWhereInput}),
  evaluation: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EventScheduleEvaluationWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationWhereUniqueInput>>('EventScheduleEvaluationWhereUniqueInput').implement({
  fields: EventScheduleEvaluationWhereUniqueInputFields,
});

export const EventScheduleEvaluationOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EventScheduleEvaluationCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EventScheduleEvaluationAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EventScheduleEvaluationMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EventScheduleEvaluationMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EventScheduleEvaluationSumOrderByAggregateInput}),
});
export const EventScheduleEvaluationOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationOrderByWithAggregationInput>>('EventScheduleEvaluationOrderByWithAggregationInput').implement({
  fields: EventScheduleEvaluationOrderByWithAggregationInputFields,
});

export const EventScheduleEvaluationScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  eventScheduleId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  evaluationId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const EventScheduleEvaluationScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationScalarWhereWithAggregatesInput>>('EventScheduleEvaluationScalarWhereWithAggregatesInput').implement({
  fields: EventScheduleEvaluationScalarWhereWithAggregatesInputFields,
});

export const EventWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventWhereInput]}),
  OR: t.field({"required":false,"type":[EventWhereInput]}),
  NOT: t.field({"required":false,"type":[EventWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  date: t.field({"required":false,"type":DateTimeFilter}),
  duration: t.field({"required":false,"type":IntNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringNullableFilter}),
  note: t.field({"required":false,"type":StringNullableFilter}),
  privateNote: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  createdById: t.field({"required":false,"type":IntFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  interviewers: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  candidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  createdBy: t.field({"required":false,"type":HiringRoleWhereInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerListRelationFilter}),
});
export const EventWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventWhereInput>>('EventWhereInput').implement({
  fields: EventWhereInputFields,
});

export const EventOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  date: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  interviewers: t.field({"required":false,"type":HiringRoleOrderByRelationAggregateInput}),
  evaluations: t.field({"required":false,"type":EvaluationOrderByRelationAggregateInput}),
  candidates: t.field({"required":false,"type":CandidateOrderByRelationAggregateInput}),
  createdBy: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerOrderByRelationAggregateInput}),
});
export const EventOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventOrderByWithRelationInput>>('EventOrderByWithRelationInput').implement({
  fields: EventOrderByWithRelationInputFields,
});

export const EventWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EventWhereInput]}),
  OR: t.field({"required":false,"type":[EventWhereInput]}),
  NOT: t.field({"required":false,"type":[EventWhereInput]}),
  date: t.field({"required":false,"type":DateTimeFilter}),
  duration: t.field({"required":false,"type":IntNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringNullableFilter}),
  note: t.field({"required":false,"type":StringNullableFilter}),
  privateNote: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  createdById: t.field({"required":false,"type":IntFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  interviewers: t.field({"required":false,"type":HiringRoleListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  candidates: t.field({"required":false,"type":CandidateListRelationFilter}),
  createdBy: t.field({"required":false,"type":HiringRoleWhereInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerListRelationFilter}),
});
export const EventWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventWhereUniqueInput>>('EventWhereUniqueInput').implement({
  fields: EventWhereUniqueInputFields,
});

export const EventOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  date: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EventCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EventAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EventMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EventMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EventSumOrderByAggregateInput}),
});
export const EventOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventOrderByWithAggregationInput>>('EventOrderByWithAggregationInput').implement({
  fields: EventOrderByWithAggregationInputFields,
});

export const EventScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EventScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EventScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  date: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  duration: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
  location: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  note: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  privateNote: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  createdById: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const EventScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScalarWhereWithAggregatesInput>>('EventScalarWhereWithAggregatesInput').implement({
  fields: EventScalarWhereWithAggregatesInputFields,
});

export const EventInterviewerWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  OR: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  NOT: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  event: t.field({"required":false,"type":EventWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const EventInterviewerWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerWhereInput>>('EventInterviewerWhereInput').implement({
  fields: EventInterviewerWhereInputFields,
});

export const EventInterviewerOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  event: t.field({"required":false,"type":EventOrderByWithRelationInput}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
});
export const EventInterviewerOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerOrderByWithRelationInput>>('EventInterviewerOrderByWithRelationInput').implement({
  fields: EventInterviewerOrderByWithRelationInputFields,
});

export const EventInterviewerWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  OR: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  NOT: t.field({"required":false,"type":[EventInterviewerWhereInput]}),
  eventId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  event: t.field({"required":false,"type":EventWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const EventInterviewerWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerWhereUniqueInput>>('EventInterviewerWhereUniqueInput').implement({
  fields: EventInterviewerWhereUniqueInputFields,
});

export const EventInterviewerOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EventInterviewerCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EventInterviewerAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EventInterviewerMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EventInterviewerMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EventInterviewerSumOrderByAggregateInput}),
});
export const EventInterviewerOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerOrderByWithAggregationInput>>('EventInterviewerOrderByWithAggregationInput').implement({
  fields: EventInterviewerOrderByWithAggregationInputFields,
});

export const EventInterviewerScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventInterviewerScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EventInterviewerScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EventInterviewerScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  eventId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const EventInterviewerScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerScalarWhereWithAggregatesInput>>('EventInterviewerScalarWhereWithAggregatesInput').implement({
  fields: EventInterviewerScalarWhereWithAggregatesInputFields,
});

export const OfferWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferWhereInput]}),
  OR: t.field({"required":false,"type":[OfferWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  departmentId: t.field({"required":false,"type":IntNullableFilter}),
  recruiterId: t.field({"required":false,"type":IntNullableFilter}),
  hiringManagerId: t.field({"required":false,"type":IntNullableFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  requirements: t.field({"required":false,"type":StringNullableFilter}),
  locationCountry: t.field({"required":false,"type":StringNullableFilter}),
  locationState: t.field({"required":false,"type":StringNullableFilter}),
  locationCity: t.field({"required":false,"type":StringNullableFilter}),
  locationStreet: t.field({"required":false,"type":StringNullableFilter}),
  zipcode: t.field({"required":false,"type":StringNullableFilter}),
  remote: t.field({"required":false,"type":BoolFilter}),
  jobType: t.field({"required":false,"type":StringNullableFilter}),
  jobCategory: t.field({"required":false,"type":StringNullableFilter}),
  jobReqEducation: t.field({"required":false,"type":StringNullableFilter}),
  jobReqExperience: t.field({"required":false,"type":StringNullableFilter}),
  jobHoursMin: t.field({"required":false,"type":IntNullableFilter}),
  jobHoursMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMin: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryPeriod: t.field({"required":false,"type":StringNullableFilter}),
  jobSalaryCurrency: t.field({"required":false,"type":StringNullableFilter}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  pipelineTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  autoConfirmationEmailId: t.field({"required":false,"type":IntNullableFilter}),
  isPublished: t.field({"required":false,"type":BoolFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  department: t.field({"required":false,"type":DepartmentWhereInput}),
  recruiter: t.field({"required":false,"type":HiringRoleWhereInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleWhereInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateWhereInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateWhereInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateWhereInput}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  files: t.field({"required":false,"type":OfferFileListRelationFilter}),
  offerTags: t.field({"required":false,"type":OfferTagListRelationFilter}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
  hired: t.field({"required":false,"type":CandidateListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
});
export const OfferWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferWhereInput>>('OfferWhereInput').implement({
  fields: OfferWhereInputFields,
});

export const OfferOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  requirements: t.field({"required":false,"type":SortOrder}),
  locationCountry: t.field({"required":false,"type":SortOrder}),
  locationState: t.field({"required":false,"type":SortOrder}),
  locationCity: t.field({"required":false,"type":SortOrder}),
  locationStreet: t.field({"required":false,"type":SortOrder}),
  zipcode: t.field({"required":false,"type":SortOrder}),
  remote: t.field({"required":false,"type":SortOrder}),
  jobType: t.field({"required":false,"type":SortOrder}),
  jobCategory: t.field({"required":false,"type":SortOrder}),
  jobReqEducation: t.field({"required":false,"type":SortOrder}),
  jobReqExperience: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryPeriod: t.field({"required":false,"type":SortOrder}),
  jobSalaryCurrency: t.field({"required":false,"type":SortOrder}),
  personalInfoCv: t.field({"required":false,"type":SortOrder}),
  personalInfoCoverLetter: t.field({"required":false,"type":SortOrder}),
  personalInfoPhoto: t.field({"required":false,"type":SortOrder}),
  personalInfoPhone: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
  isPublished: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  department: t.field({"required":false,"type":DepartmentOrderByWithRelationInput}),
  recruiter: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateOrderByWithRelationInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateOrderByWithRelationInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateOrderByWithRelationInput}),
  auditLogs: t.field({"required":false,"type":AuditLogOrderByRelationAggregateInput}),
  files: t.field({"required":false,"type":OfferFileOrderByRelationAggregateInput}),
  offerTags: t.field({"required":false,"type":OfferTagOrderByRelationAggregateInput}),
  memberships: t.field({"required":false,"type":MembershipOrderByRelationAggregateInput}),
  matches: t.field({"required":false,"type":MatchOrderByRelationAggregateInput}),
  hired: t.field({"required":false,"type":CandidateOrderByRelationAggregateInput}),
  evaluations: t.field({"required":false,"type":EvaluationOrderByRelationAggregateInput}),
  follows: t.field({"required":false,"type":FollowOrderByRelationAggregateInput}),
});
export const OfferOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferOrderByWithRelationInput>>('OfferOrderByWithRelationInput').implement({
  fields: OfferOrderByWithRelationInputFields,
});

export const OfferWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  AND: t.field({"required":false,"type":[OfferWhereInput]}),
  OR: t.field({"required":false,"type":[OfferWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  departmentId: t.field({"required":false,"type":IntNullableFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  requirements: t.field({"required":false,"type":StringNullableFilter}),
  locationCountry: t.field({"required":false,"type":StringNullableFilter}),
  locationState: t.field({"required":false,"type":StringNullableFilter}),
  locationCity: t.field({"required":false,"type":StringNullableFilter}),
  locationStreet: t.field({"required":false,"type":StringNullableFilter}),
  zipcode: t.field({"required":false,"type":StringNullableFilter}),
  remote: t.field({"required":false,"type":BoolFilter}),
  jobType: t.field({"required":false,"type":StringNullableFilter}),
  jobCategory: t.field({"required":false,"type":StringNullableFilter}),
  jobReqEducation: t.field({"required":false,"type":StringNullableFilter}),
  jobReqExperience: t.field({"required":false,"type":StringNullableFilter}),
  jobHoursMin: t.field({"required":false,"type":IntNullableFilter}),
  jobHoursMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMin: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryPeriod: t.field({"required":false,"type":StringNullableFilter}),
  jobSalaryCurrency: t.field({"required":false,"type":StringNullableFilter}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  pipelineTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  autoConfirmationEmailId: t.field({"required":false,"type":IntNullableFilter}),
  isPublished: t.field({"required":false,"type":BoolFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  department: t.field({"required":false,"type":DepartmentWhereInput}),
  recruiter: t.field({"required":false,"type":HiringRoleWhereInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleWhereInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateWhereInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateWhereInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateWhereInput}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  files: t.field({"required":false,"type":OfferFileListRelationFilter}),
  offerTags: t.field({"required":false,"type":OfferTagListRelationFilter}),
  memberships: t.field({"required":false,"type":MembershipListRelationFilter}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
  hired: t.field({"required":false,"type":CandidateListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
});
export const OfferWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferWhereUniqueInput>>('OfferWhereUniqueInput').implement({
  fields: OfferWhereUniqueInputFields,
});

export const OfferOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  requirements: t.field({"required":false,"type":SortOrder}),
  locationCountry: t.field({"required":false,"type":SortOrder}),
  locationState: t.field({"required":false,"type":SortOrder}),
  locationCity: t.field({"required":false,"type":SortOrder}),
  locationStreet: t.field({"required":false,"type":SortOrder}),
  zipcode: t.field({"required":false,"type":SortOrder}),
  remote: t.field({"required":false,"type":SortOrder}),
  jobType: t.field({"required":false,"type":SortOrder}),
  jobCategory: t.field({"required":false,"type":SortOrder}),
  jobReqEducation: t.field({"required":false,"type":SortOrder}),
  jobReqExperience: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryPeriod: t.field({"required":false,"type":SortOrder}),
  jobSalaryCurrency: t.field({"required":false,"type":SortOrder}),
  personalInfoCv: t.field({"required":false,"type":SortOrder}),
  personalInfoCoverLetter: t.field({"required":false,"type":SortOrder}),
  personalInfoPhoto: t.field({"required":false,"type":SortOrder}),
  personalInfoPhone: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
  isPublished: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":OfferCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":OfferAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":OfferMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":OfferMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":OfferSumOrderByAggregateInput}),
});
export const OfferOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferOrderByWithAggregationInput>>('OfferOrderByWithAggregationInput').implement({
  fields: OfferOrderByWithAggregationInputFields,
});

export const OfferScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[OfferScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[OfferScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  departmentId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  recruiterId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  hiringManagerId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  description: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  requirements: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  locationCountry: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  locationState: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  locationCity: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  locationStreet: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  zipcode: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  remote: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  jobType: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  jobCategory: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  jobReqEducation: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  jobReqExperience: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  jobHoursMin: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  jobHoursMax: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  jobSalaryMin: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  jobSalaryMax: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  jobSalaryPeriod: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  jobSalaryCurrency: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsWithAggregatesFilter}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsWithAggregatesFilter}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsWithAggregatesFilter}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsWithAggregatesFilter}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  pipelineTemplateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  autoConfirmationEmailId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  isPublished: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const OfferScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferScalarWhereWithAggregatesInput>>('OfferScalarWhereWithAggregatesInput').implement({
  fields: OfferScalarWhereWithAggregatesInputFields,
});

export const OfferFileWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferFileWhereInput]}),
  OR: t.field({"required":false,"type":[OfferFileWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferFileWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  attachment: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const OfferFileWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileWhereInput>>('OfferFileWhereInput').implement({
  fields: OfferFileWhereInputFields,
});

export const OfferFileOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  attachment: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
});
export const OfferFileOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileOrderByWithRelationInput>>('OfferFileOrderByWithRelationInput').implement({
  fields: OfferFileOrderByWithRelationInputFields,
});

export const OfferFileWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[OfferFileWhereInput]}),
  OR: t.field({"required":false,"type":[OfferFileWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferFileWhereInput]}),
  offerId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  attachment: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const OfferFileWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileWhereUniqueInput>>('OfferFileWhereUniqueInput').implement({
  fields: OfferFileWhereUniqueInputFields,
});

export const OfferFileOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":OfferFileCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":OfferFileAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":OfferFileMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":OfferFileMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":OfferFileSumOrderByAggregateInput}),
});
export const OfferFileOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileOrderByWithAggregationInput>>('OfferFileOrderByWithAggregationInput').implement({
  fields: OfferFileOrderByWithAggregationInputFields,
});

export const OfferFileScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferFileScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[OfferFileScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[OfferFileScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  attachmentId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const OfferFileScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileScalarWhereWithAggregatesInput>>('OfferFileScalarWhereWithAggregatesInput').implement({
  fields: OfferFileScalarWhereWithAggregatesInputFields,
});

export const MatchWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MatchWhereInput]}),
  OR: t.field({"required":false,"type":[MatchWhereInput]}),
  NOT: t.field({"required":false,"type":[MatchWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  stageId: t.field({"required":false,"type":IntNullableFilter}),
  isHired: t.field({"required":false,"type":BoolFilter}),
  disqualifyReasonId: t.field({"required":false,"type":IntNullableFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  stage: t.field({"required":false,"type":StageWhereInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
});
export const MatchWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchWhereInput>>('MatchWhereInput').implement({
  fields: MatchWhereInputFields,
});

export const MatchOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  isHired: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  stage: t.field({"required":false,"type":StageOrderByWithRelationInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonOrderByWithRelationInput}),
});
export const MatchOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchOrderByWithRelationInput>>('MatchOrderByWithRelationInput').implement({
  fields: MatchOrderByWithRelationInputFields,
});

export const MatchWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  candidateId_offerId: t.field({"required":false,"type":MatchCandidateIdOfferIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[MatchWhereInput]}),
  OR: t.field({"required":false,"type":[MatchWhereInput]}),
  NOT: t.field({"required":false,"type":[MatchWhereInput]}),
  offerId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  stageId: t.field({"required":false,"type":IntNullableFilter}),
  isHired: t.field({"required":false,"type":BoolFilter}),
  disqualifyReasonId: t.field({"required":false,"type":IntNullableFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  stage: t.field({"required":false,"type":StageWhereInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
});
export const MatchWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchWhereUniqueInput>>('MatchWhereUniqueInput').implement({
  fields: MatchWhereUniqueInputFields,
});

export const MatchOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  isHired: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":MatchCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":MatchAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":MatchMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":MatchMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":MatchSumOrderByAggregateInput}),
});
export const MatchOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchOrderByWithAggregationInput>>('MatchOrderByWithAggregationInput').implement({
  fields: MatchOrderByWithAggregationInputFields,
});

export const MatchScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MatchScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[MatchScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[MatchScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  stageId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  isHired: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  disqualifyReasonId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
});
export const MatchScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchScalarWhereWithAggregatesInput>>('MatchScalarWhereWithAggregatesInput').implement({
  fields: MatchScalarWhereWithAggregatesInputFields,
});

export const OfferTagWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferTagWhereInput]}),
  OR: t.field({"required":false,"type":[OfferTagWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferTagWhereInput]}),
  offerId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  tag: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const OfferTagWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagWhereInput>>('OfferTagWhereInput').implement({
  fields: OfferTagWhereInputFields,
});

export const OfferTagOrderByWithRelationInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  tag: t.field({"required":false,"type":TagSourceOrderByWithRelationInput}),
});
export const OfferTagOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagOrderByWithRelationInput>>('OfferTagOrderByWithRelationInput').implement({
  fields: OfferTagOrderByWithRelationInputFields,
});

export const OfferTagWhereUniqueInputFields = (t: any) => ({
  offerId_tagId: t.field({"required":false,"type":OfferTagOfferIdTagIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[OfferTagWhereInput]}),
  OR: t.field({"required":false,"type":[OfferTagWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferTagWhereInput]}),
  offerId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  tag: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const OfferTagWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagWhereUniqueInput>>('OfferTagWhereUniqueInput').implement({
  fields: OfferTagWhereUniqueInputFields,
});

export const OfferTagOrderByWithAggregationInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":OfferTagCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":OfferTagAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":OfferTagMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":OfferTagMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":OfferTagSumOrderByAggregateInput}),
});
export const OfferTagOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagOrderByWithAggregationInput>>('OfferTagOrderByWithAggregationInput').implement({
  fields: OfferTagOrderByWithAggregationInputFields,
});

export const OfferTagScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferTagScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[OfferTagScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[OfferTagScalarWhereWithAggregatesInput]}),
  offerId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  tagId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const OfferTagScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagScalarWhereWithAggregatesInput>>('OfferTagScalarWhereWithAggregatesInput').implement({
  fields: OfferTagScalarWhereWithAggregatesInputFields,
});

export const MembershipWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MembershipWhereInput]}),
  OR: t.field({"required":false,"type":[MembershipWhereInput]}),
  NOT: t.field({"required":false,"type":[MembershipWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
});
export const MembershipWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipWhereInput>>('MembershipWhereInput').implement({
  fields: MembershipWhereInputFields,
});

export const MembershipOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  role: t.field({"required":false,"type":RoleOrderByWithRelationInput}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
});
export const MembershipOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipOrderByWithRelationInput>>('MembershipOrderByWithRelationInput').implement({
  fields: MembershipOrderByWithRelationInputFields,
});

export const MembershipWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[MembershipWhereInput]}),
  OR: t.field({"required":false,"type":[MembershipWhereInput]}),
  NOT: t.field({"required":false,"type":[MembershipWhereInput]}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
});
export const MembershipWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipWhereUniqueInput>>('MembershipWhereUniqueInput').implement({
  fields: MembershipWhereUniqueInputFields,
});

export const MembershipOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":MembershipCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":MembershipAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":MembershipMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":MembershipMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":MembershipSumOrderByAggregateInput}),
});
export const MembershipOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipOrderByWithAggregationInput>>('MembershipOrderByWithAggregationInput').implement({
  fields: MembershipOrderByWithAggregationInputFields,
});

export const MembershipScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MembershipScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[MembershipScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[MembershipScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  roleId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const MembershipScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipScalarWhereWithAggregatesInput>>('MembershipScalarWhereWithAggregatesInput').implement({
  fields: MembershipScalarWhereWithAggregatesInputFields,
});

export const TalentPoolWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  files: t.field({"required":false,"type":TalentPoolFileListRelationFilter}),
  matches: t.field({"required":false,"type":TalentPoolMatchListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const TalentPoolWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolWhereInput>>('TalentPoolWhereInput').implement({
  fields: TalentPoolWhereInputFields,
});

export const TalentPoolOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  files: t.field({"required":false,"type":TalentPoolFileOrderByRelationAggregateInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchOrderByRelationAggregateInput}),
  follows: t.field({"required":false,"type":FollowOrderByRelationAggregateInput}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
});
export const TalentPoolOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolOrderByWithRelationInput>>('TalentPoolOrderByWithRelationInput').implement({
  fields: TalentPoolOrderByWithRelationInputFields,
});

export const TalentPoolWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  files: t.field({"required":false,"type":TalentPoolFileListRelationFilter}),
  matches: t.field({"required":false,"type":TalentPoolMatchListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
});
export const TalentPoolWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolWhereUniqueInput>>('TalentPoolWhereUniqueInput').implement({
  fields: TalentPoolWhereUniqueInputFields,
});

export const TalentPoolOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TalentPoolCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TalentPoolAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TalentPoolMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TalentPoolMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TalentPoolSumOrderByAggregateInput}),
});
export const TalentPoolOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolOrderByWithAggregationInput>>('TalentPoolOrderByWithAggregationInput').implement({
  fields: TalentPoolOrderByWithAggregationInputFields,
});

export const TalentPoolScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TalentPoolScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  description: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const TalentPoolScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolScalarWhereWithAggregatesInput>>('TalentPoolScalarWhereWithAggregatesInput').implement({
  fields: TalentPoolScalarWhereWithAggregatesInputFields,
});

export const TalentPoolFileWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  attachment: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const TalentPoolFileWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileWhereInput>>('TalentPoolFileWhereInput').implement({
  fields: TalentPoolFileWhereInputFields,
});

export const TalentPoolFileOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
  talentPool: t.field({"required":false,"type":TalentPoolOrderByWithRelationInput}),
  attachment: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
});
export const TalentPoolFileOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileOrderByWithRelationInput>>('TalentPoolFileOrderByWithRelationInput').implement({
  fields: TalentPoolFileOrderByWithRelationInputFields,
});

export const TalentPoolFileWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolFileWhereInput]}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  attachment: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const TalentPoolFileWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileWhereUniqueInput>>('TalentPoolFileWhereUniqueInput').implement({
  fields: TalentPoolFileWhereUniqueInputFields,
});

export const TalentPoolFileOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TalentPoolFileCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TalentPoolFileAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TalentPoolFileMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TalentPoolFileMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TalentPoolFileSumOrderByAggregateInput}),
});
export const TalentPoolFileOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileOrderByWithAggregationInput>>('TalentPoolFileOrderByWithAggregationInput').implement({
  fields: TalentPoolFileOrderByWithAggregationInputFields,
});

export const TalentPoolFileScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolFileScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TalentPoolFileScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolFileScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  talentPoolId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  attachmentId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const TalentPoolFileScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileScalarWhereWithAggregatesInput>>('TalentPoolFileScalarWhereWithAggregatesInput').implement({
  fields: TalentPoolFileScalarWhereWithAggregatesInputFields,
});

export const TalentPoolMatchWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const TalentPoolMatchWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchWhereInput>>('TalentPoolMatchWhereInput').implement({
  fields: TalentPoolMatchWhereInputFields,
});

export const TalentPoolMatchOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPool: t.field({"required":false,"type":TalentPoolOrderByWithRelationInput}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
});
export const TalentPoolMatchOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchOrderByWithRelationInput>>('TalentPoolMatchOrderByWithRelationInput').implement({
  fields: TalentPoolMatchOrderByWithRelationInputFields,
});

export const TalentPoolMatchWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolMatchWhereInput]}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const TalentPoolMatchWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchWhereUniqueInput>>('TalentPoolMatchWhereUniqueInput').implement({
  fields: TalentPoolMatchWhereUniqueInputFields,
});

export const TalentPoolMatchOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TalentPoolMatchCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TalentPoolMatchAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TalentPoolMatchMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TalentPoolMatchMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TalentPoolMatchSumOrderByAggregateInput}),
});
export const TalentPoolMatchOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchOrderByWithAggregationInput>>('TalentPoolMatchOrderByWithAggregationInput').implement({
  fields: TalentPoolMatchOrderByWithAggregationInputFields,
});

export const TalentPoolMatchScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolMatchScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TalentPoolMatchScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolMatchScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  talentPoolId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const TalentPoolMatchScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchScalarWhereWithAggregatesInput>>('TalentPoolMatchScalarWhereWithAggregatesInput').implement({
  fields: TalentPoolMatchScalarWhereWithAggregatesInputFields,
});

export const TemplateWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TemplateWhereInput]}),
  OR: t.field({"required":false,"type":[TemplateWhereInput]}),
  NOT: t.field({"required":false,"type":[TemplateWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  isCompanyWide: t.field({"required":false,"type":BoolNullableFilter}),
  type: t.field({"required":false,"type":EnumTemplateTypesFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  category: t.field({"required":false,"type":StringNullableFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferListRelationFilter}),
  pipelineTemplate: t.field({"required":false,"type":OfferListRelationFilter}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferListRelationFilter}),
  stages: t.field({"required":false,"type":StageListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
});
export const TemplateWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateWhereInput>>('TemplateWhereInput').implement({
  fields: TemplateWhereInputFields,
});

export const TemplateOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  isCompanyWide: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferOrderByRelationAggregateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferOrderByRelationAggregateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferOrderByRelationAggregateInput}),
  stages: t.field({"required":false,"type":StageOrderByRelationAggregateInput}),
  evaluations: t.field({"required":false,"type":EvaluationOrderByRelationAggregateInput}),
});
export const TemplateOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateOrderByWithRelationInput>>('TemplateOrderByWithRelationInput').implement({
  fields: TemplateOrderByWithRelationInputFields,
});

export const TemplateWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TemplateWhereInput]}),
  OR: t.field({"required":false,"type":[TemplateWhereInput]}),
  NOT: t.field({"required":false,"type":[TemplateWhereInput]}),
  companyId: t.field({"required":false,"type":StringFilter}),
  isCompanyWide: t.field({"required":false,"type":BoolNullableFilter}),
  type: t.field({"required":false,"type":EnumTemplateTypesFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  category: t.field({"required":false,"type":StringNullableFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferListRelationFilter}),
  pipelineTemplate: t.field({"required":false,"type":OfferListRelationFilter}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferListRelationFilter}),
  stages: t.field({"required":false,"type":StageListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
});
export const TemplateWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateWhereUniqueInput>>('TemplateWhereUniqueInput').implement({
  fields: TemplateWhereUniqueInputFields,
});

export const TemplateOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  isCompanyWide: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TemplateCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TemplateAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TemplateMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TemplateMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TemplateSumOrderByAggregateInput}),
});
export const TemplateOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateOrderByWithAggregationInput>>('TemplateOrderByWithAggregationInput').implement({
  fields: TemplateOrderByWithAggregationInputFields,
});

export const TemplateScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TemplateScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TemplateScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TemplateScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  isCompanyWide: t.field({"required":false,"type":BoolNullableWithAggregatesFilter}),
  type: t.field({"required":false,"type":EnumTemplateTypesWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  category: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
});
export const TemplateScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateScalarWhereWithAggregatesInput>>('TemplateScalarWhereWithAggregatesInput').implement({
  fields: TemplateScalarWhereWithAggregatesInputFields,
});

export const StageWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageWhereInput]}),
  OR: t.field({"required":false,"type":[StageWhereInput]}),
  NOT: t.field({"required":false,"type":[StageWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  position: t.field({"required":false,"type":IntNullableFilter}),
  category: t.field({"required":false,"type":StringFilter}),
  inputType: t.field({"required":false,"type":StringNullableFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
  templateId: t.field({"required":false,"type":IntFilter}),
  isProtected: t.field({"required":false,"type":BoolNullableFilter}),
  template: t.field({"required":false,"type":TemplateWhereInput}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
  visibility: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
  metadata: t.field({"required":false,"type":StageMetadataListRelationFilter}),
});
export const StageWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageWhereInput>>('StageWhereInput').implement({
  fields: StageWhereInputFields,
});

export const StageOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  isProtected: t.field({"required":false,"type":SortOrder}),
  template: t.field({"required":false,"type":TemplateOrderByWithRelationInput}),
  matches: t.field({"required":false,"type":MatchOrderByRelationAggregateInput}),
  visibility: t.field({"required":false,"type":StageVisibilityOrderByRelationAggregateInput}),
  metadata: t.field({"required":false,"type":StageMetadataOrderByRelationAggregateInput}),
});
export const StageOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageOrderByWithRelationInput>>('StageOrderByWithRelationInput').implement({
  fields: StageOrderByWithRelationInputFields,
});

export const StageWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[StageWhereInput]}),
  OR: t.field({"required":false,"type":[StageWhereInput]}),
  NOT: t.field({"required":false,"type":[StageWhereInput]}),
  position: t.field({"required":false,"type":IntNullableFilter}),
  category: t.field({"required":false,"type":StringFilter}),
  inputType: t.field({"required":false,"type":StringNullableFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
  templateId: t.field({"required":false,"type":IntFilter}),
  isProtected: t.field({"required":false,"type":BoolNullableFilter}),
  template: t.field({"required":false,"type":TemplateWhereInput}),
  matches: t.field({"required":false,"type":MatchListRelationFilter}),
  visibility: t.field({"required":false,"type":StageVisibilityListRelationFilter}),
  metadata: t.field({"required":false,"type":StageMetadataListRelationFilter}),
});
export const StageWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageWhereUniqueInput>>('StageWhereUniqueInput').implement({
  fields: StageWhereUniqueInputFields,
});

export const StageOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  isProtected: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":StageCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":StageAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":StageMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":StageMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":StageSumOrderByAggregateInput}),
});
export const StageOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageOrderByWithAggregationInput>>('StageOrderByWithAggregationInput').implement({
  fields: StageOrderByWithAggregationInputFields,
});

export const StageScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[StageScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[StageScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  position: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  category: t.field({"required":false,"type":StringWithAggregatesFilter}),
  inputType: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  value: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  templateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  isProtected: t.field({"required":false,"type":BoolNullableWithAggregatesFilter}),
});
export const StageScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageScalarWhereWithAggregatesInput>>('StageScalarWhereWithAggregatesInput').implement({
  fields: StageScalarWhereWithAggregatesInputFields,
});

export const StageVisibilityWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  OR: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  NOT: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  stage: t.field({"required":false,"type":StageWhereInput}),
});
export const StageVisibilityWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityWhereInput>>('StageVisibilityWhereInput').implement({
  fields: StageVisibilityWhereInputFields,
});

export const StageVisibilityOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  role: t.field({"required":false,"type":RoleOrderByWithRelationInput}),
  stage: t.field({"required":false,"type":StageOrderByWithRelationInput}),
});
export const StageVisibilityOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityOrderByWithRelationInput>>('StageVisibilityOrderByWithRelationInput').implement({
  fields: StageVisibilityOrderByWithRelationInputFields,
});

export const StageVisibilityWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  OR: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  NOT: t.field({"required":false,"type":[StageVisibilityWhereInput]}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  role: t.field({"required":false,"type":RoleWhereInput}),
  stage: t.field({"required":false,"type":StageWhereInput}),
});
export const StageVisibilityWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityWhereUniqueInput>>('StageVisibilityWhereUniqueInput').implement({
  fields: StageVisibilityWhereUniqueInputFields,
});

export const StageVisibilityOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":StageVisibilityCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":StageVisibilityAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":StageVisibilityMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":StageVisibilityMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":StageVisibilitySumOrderByAggregateInput}),
});
export const StageVisibilityOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityOrderByWithAggregationInput>>('StageVisibilityOrderByWithAggregationInput').implement({
  fields: StageVisibilityOrderByWithAggregationInputFields,
});

export const StageVisibilityScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageVisibilityScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[StageVisibilityScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[StageVisibilityScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  roleId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  stageId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const StageVisibilityScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityScalarWhereWithAggregatesInput>>('StageVisibilityScalarWhereWithAggregatesInput').implement({
  fields: StageVisibilityScalarWhereWithAggregatesInputFields,
});

export const StageMetadataWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  OR: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  NOT: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  metaKey: t.field({"required":false,"type":StringFilter}),
  metaValue: t.field({"required":false,"type":StringFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
  stage: t.field({"required":false,"type":StageWhereInput}),
});
export const StageMetadataWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataWhereInput>>('StageMetadataWhereInput').implement({
  fields: StageMetadataWhereInputFields,
});

export const StageMetadataOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  metaKey: t.field({"required":false,"type":SortOrder}),
  metaValue: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  stage: t.field({"required":false,"type":StageOrderByWithRelationInput}),
});
export const StageMetadataOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataOrderByWithRelationInput>>('StageMetadataOrderByWithRelationInput').implement({
  fields: StageMetadataOrderByWithRelationInputFields,
});

export const StageMetadataWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  OR: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  NOT: t.field({"required":false,"type":[StageMetadataWhereInput]}),
  metaKey: t.field({"required":false,"type":StringFilter}),
  metaValue: t.field({"required":false,"type":StringFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
  stage: t.field({"required":false,"type":StageWhereInput}),
});
export const StageMetadataWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataWhereUniqueInput>>('StageMetadataWhereUniqueInput').implement({
  fields: StageMetadataWhereUniqueInputFields,
});

export const StageMetadataOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  metaKey: t.field({"required":false,"type":SortOrder}),
  metaValue: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":StageMetadataCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":StageMetadataAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":StageMetadataMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":StageMetadataMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":StageMetadataSumOrderByAggregateInput}),
});
export const StageMetadataOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataOrderByWithAggregationInput>>('StageMetadataOrderByWithAggregationInput').implement({
  fields: StageMetadataOrderByWithAggregationInputFields,
});

export const StageMetadataScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageMetadataScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[StageMetadataScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[StageMetadataScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  metaKey: t.field({"required":false,"type":StringWithAggregatesFilter}),
  metaValue: t.field({"required":false,"type":StringWithAggregatesFilter}),
  stageId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const StageMetadataScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataScalarWhereWithAggregatesInput>>('StageMetadataScalarWhereWithAggregatesInput').implement({
  fields: StageMetadataScalarWhereWithAggregatesInputFields,
});

export const CandidateWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  firstName: t.field({"required":false,"type":StringFilter}),
  lastName: t.field({"required":false,"type":StringFilter}),
  email: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  skills: t.field({"required":false,"type":StringNullableListFilter}),
  mainLanguage: t.field({"required":false,"type":StringFilter}),
  languages: t.field({"required":false,"type":StringNullableListFilter}),
  coverLetterText: t.field({"required":false,"type":StringNullableFilter}),
  birthday: t.field({"required":false,"type":DateTimeNullableFilter}),
  referrerId: t.field({"required":false,"type":IntNullableFilter}),
  cvId: t.field({"required":false,"type":IntNullableFilter}),
  avatarId: t.field({"required":false,"type":IntNullableFilter}),
  coverLetterId: t.field({"required":false,"type":IntNullableFilter}),
  educationLevel: t.field({"required":false,"type":StringNullableFilter}),
  socials: t.field({"required":false,"type":StringNullableListFilter}),
  links: t.field({"required":false,"type":StringNullableListFilter}),
  salaryExpectation: t.field({"required":false,"type":IntNullableFilter}),
  hiredAtId: t.field({"required":false,"type":IntNullableFilter}),
  hiredById: t.field({"required":false,"type":IntNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  referrer: t.field({"required":false,"type":TagSourceWhereInput}),
  cv: t.field({"required":false,"type":AttachmentWhereInput}),
  avatar: t.field({"required":false,"type":AttachmentWhereInput}),
  coverLetter: t.field({"required":false,"type":AttachmentWhereInput}),
  hiredAt: t.field({"required":false,"type":OfferWhereInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleWhereInput}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  offers: t.field({"required":false,"type":MatchListRelationFilter}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchListRelationFilter}),
  candidateTags: t.field({"required":false,"type":CandidateTagListRelationFilter}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  events: t.field({"required":false,"type":EventListRelationFilter}),
});
export const CandidateWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateWhereInput>>('CandidateWhereInput').implement({
  fields: CandidateWhereInputFields,
});

export const CandidateOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  skills: t.field({"required":false,"type":SortOrder}),
  mainLanguage: t.field({"required":false,"type":SortOrder}),
  languages: t.field({"required":false,"type":SortOrder}),
  coverLetterText: t.field({"required":false,"type":SortOrder}),
  birthday: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  educationLevel: t.field({"required":false,"type":SortOrder}),
  socials: t.field({"required":false,"type":SortOrder}),
  links: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  referrer: t.field({"required":false,"type":TagSourceOrderByWithRelationInput}),
  cv: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
  avatar: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
  coverLetter: t.field({"required":false,"type":AttachmentOrderByWithRelationInput}),
  hiredAt: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  auditLogs: t.field({"required":false,"type":AuditLogOrderByRelationAggregateInput}),
  offers: t.field({"required":false,"type":MatchOrderByRelationAggregateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchOrderByRelationAggregateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagOrderByRelationAggregateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldOrderByRelationAggregateInput}),
  evaluations: t.field({"required":false,"type":EvaluationOrderByRelationAggregateInput}),
  tasks: t.field({"required":false,"type":TaskOrderByRelationAggregateInput}),
  follows: t.field({"required":false,"type":FollowOrderByRelationAggregateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkOrderByRelationAggregateInput}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  events: t.field({"required":false,"type":EventOrderByRelationAggregateInput}),
});
export const CandidateOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateOrderByWithRelationInput>>('CandidateOrderByWithRelationInput').implement({
  fields: CandidateOrderByWithRelationInputFields,
});

export const CandidateWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  email_companyId: t.field({"required":false,"type":CandidateEmailCompanyIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[CandidateWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateWhereInput]}),
  firstName: t.field({"required":false,"type":StringFilter}),
  lastName: t.field({"required":false,"type":StringFilter}),
  email: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  skills: t.field({"required":false,"type":StringNullableListFilter}),
  mainLanguage: t.field({"required":false,"type":StringFilter}),
  languages: t.field({"required":false,"type":StringNullableListFilter}),
  coverLetterText: t.field({"required":false,"type":StringNullableFilter}),
  birthday: t.field({"required":false,"type":DateTimeNullableFilter}),
  referrerId: t.field({"required":false,"type":IntNullableFilter}),
  educationLevel: t.field({"required":false,"type":StringNullableFilter}),
  socials: t.field({"required":false,"type":StringNullableListFilter}),
  links: t.field({"required":false,"type":StringNullableListFilter}),
  salaryExpectation: t.field({"required":false,"type":IntNullableFilter}),
  hiredAtId: t.field({"required":false,"type":IntNullableFilter}),
  hiredById: t.field({"required":false,"type":IntNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  referrer: t.field({"required":false,"type":TagSourceWhereInput}),
  cv: t.field({"required":false,"type":AttachmentWhereInput}),
  avatar: t.field({"required":false,"type":AttachmentWhereInput}),
  coverLetter: t.field({"required":false,"type":AttachmentWhereInput}),
  hiredAt: t.field({"required":false,"type":OfferWhereInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleWhereInput}),
  auditLogs: t.field({"required":false,"type":AuditLogListRelationFilter}),
  offers: t.field({"required":false,"type":MatchListRelationFilter}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchListRelationFilter}),
  candidateTags: t.field({"required":false,"type":CandidateTagListRelationFilter}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldListRelationFilter}),
  evaluations: t.field({"required":false,"type":EvaluationListRelationFilter}),
  tasks: t.field({"required":false,"type":TaskListRelationFilter}),
  follows: t.field({"required":false,"type":FollowListRelationFilter}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkListRelationFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  events: t.field({"required":false,"type":EventListRelationFilter}),
});
export const CandidateWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateWhereUniqueInput>>('CandidateWhereUniqueInput').implement({
  fields: CandidateWhereUniqueInputFields,
});

export const CandidateOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  skills: t.field({"required":false,"type":SortOrder}),
  mainLanguage: t.field({"required":false,"type":SortOrder}),
  languages: t.field({"required":false,"type":SortOrder}),
  coverLetterText: t.field({"required":false,"type":SortOrder}),
  birthday: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  educationLevel: t.field({"required":false,"type":SortOrder}),
  socials: t.field({"required":false,"type":SortOrder}),
  links: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CandidateCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CandidateAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CandidateMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CandidateMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CandidateSumOrderByAggregateInput}),
});
export const CandidateOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateOrderByWithAggregationInput>>('CandidateOrderByWithAggregationInput').implement({
  fields: CandidateOrderByWithAggregationInputFields,
});

export const CandidateScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CandidateScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CandidateScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  firstName: t.field({"required":false,"type":StringWithAggregatesFilter}),
  lastName: t.field({"required":false,"type":StringWithAggregatesFilter}),
  email: t.field({"required":false,"type":StringWithAggregatesFilter}),
  phone: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  skills: t.field({"required":false,"type":StringNullableListFilter}),
  mainLanguage: t.field({"required":false,"type":StringWithAggregatesFilter}),
  languages: t.field({"required":false,"type":StringNullableListFilter}),
  coverLetterText: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  birthday: t.field({"required":false,"type":DateTimeNullableWithAggregatesFilter}),
  referrerId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  cvId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  avatarId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  coverLetterId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  educationLevel: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  socials: t.field({"required":false,"type":StringNullableListFilter}),
  links: t.field({"required":false,"type":StringNullableListFilter}),
  salaryExpectation: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  hiredAtId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  hiredById: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const CandidateScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateScalarWhereWithAggregatesInput>>('CandidateScalarWhereWithAggregatesInput').implement({
  fields: CandidateScalarWhereWithAggregatesInputFields,
});

export const CandidateTagWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  tag: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const CandidateTagWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagWhereInput>>('CandidateTagWhereInput').implement({
  fields: CandidateTagWhereInputFields,
});

export const CandidateTagOrderByWithRelationInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  tag: t.field({"required":false,"type":TagSourceOrderByWithRelationInput}),
});
export const CandidateTagOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagOrderByWithRelationInput>>('CandidateTagOrderByWithRelationInput').implement({
  fields: CandidateTagOrderByWithRelationInputFields,
});

export const CandidateTagWhereUniqueInputFields = (t: any) => ({
  candidateId_tagId: t.field({"required":false,"type":CandidateTagCandidateIdTagIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateTagWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  tag: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const CandidateTagWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagWhereUniqueInput>>('CandidateTagWhereUniqueInput').implement({
  fields: CandidateTagWhereUniqueInputFields,
});

export const CandidateTagOrderByWithAggregationInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CandidateTagCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CandidateTagAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CandidateTagMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CandidateTagMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CandidateTagSumOrderByAggregateInput}),
});
export const CandidateTagOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagOrderByWithAggregationInput>>('CandidateTagOrderByWithAggregationInput').implement({
  fields: CandidateTagOrderByWithAggregationInputFields,
});

export const CandidateTagScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateTagScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CandidateTagScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CandidateTagScalarWhereWithAggregatesInput]}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  tagId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const CandidateTagScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagScalarWhereWithAggregatesInput>>('CandidateTagScalarWhereWithAggregatesInput').implement({
  fields: CandidateTagScalarWhereWithAggregatesInputFields,
});

export const CandidateCustomFieldWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  customFieldId: t.field({"required":false,"type":IntFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  customField: t.field({"required":false,"type":CustomFieldWhereInput}),
});
export const CandidateCustomFieldWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldWhereInput>>('CandidateCustomFieldWhereInput').implement({
  fields: CandidateCustomFieldWhereInputFields,
});

export const CandidateCustomFieldOrderByWithRelationInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  customField: t.field({"required":false,"type":CustomFieldOrderByWithRelationInput}),
});
export const CandidateCustomFieldOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldOrderByWithRelationInput>>('CandidateCustomFieldOrderByWithRelationInput').implement({
  fields: CandidateCustomFieldOrderByWithRelationInputFields,
});

export const CandidateCustomFieldWhereUniqueInputFields = (t: any) => ({
  candidateId_customFieldId: t.field({"required":false,"type":CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateCustomFieldWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  customFieldId: t.field({"required":false,"type":IntFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  customField: t.field({"required":false,"type":CustomFieldWhereInput}),
});
export const CandidateCustomFieldWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldWhereUniqueInput>>('CandidateCustomFieldWhereUniqueInput').implement({
  fields: CandidateCustomFieldWhereUniqueInputFields,
});

export const CandidateCustomFieldOrderByWithAggregationInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CandidateCustomFieldCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CandidateCustomFieldAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CandidateCustomFieldMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CandidateCustomFieldMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CandidateCustomFieldSumOrderByAggregateInput}),
});
export const CandidateCustomFieldOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldOrderByWithAggregationInput>>('CandidateCustomFieldOrderByWithAggregationInput').implement({
  fields: CandidateCustomFieldOrderByWithAggregationInputFields,
});

export const CandidateCustomFieldScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereWithAggregatesInput]}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  customFieldId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  value: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
});
export const CandidateCustomFieldScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldScalarWhereWithAggregatesInput>>('CandidateCustomFieldScalarWhereWithAggregatesInput').implement({
  fields: CandidateCustomFieldScalarWhereWithAggregatesInputFields,
});

export const CustomFieldWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  OR: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  NOT: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  defaultValue: t.field({"required":false,"type":StringNullableFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldListRelationFilter}),
});
export const CustomFieldWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldWhereInput>>('CustomFieldWhereInput').implement({
  fields: CustomFieldWhereInputFields,
});

export const CustomFieldOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  defaultValue: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldOrderByRelationAggregateInput}),
});
export const CustomFieldOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldOrderByWithRelationInput>>('CustomFieldOrderByWithRelationInput').implement({
  fields: CustomFieldOrderByWithRelationInputFields,
});

export const CustomFieldWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId_key: t.field({"required":false,"type":CustomFieldCompanyIdKeyCompoundUniqueInput}),
  AND: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  OR: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  NOT: t.field({"required":false,"type":[CustomFieldWhereInput]}),
  type: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  defaultValue: t.field({"required":false,"type":StringNullableFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldListRelationFilter}),
});
export const CustomFieldWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldWhereUniqueInput>>('CustomFieldWhereUniqueInput').implement({
  fields: CustomFieldWhereUniqueInputFields,
});

export const CustomFieldOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  defaultValue: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":CustomFieldCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":CustomFieldAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":CustomFieldMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":CustomFieldMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":CustomFieldSumOrderByAggregateInput}),
});
export const CustomFieldOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldOrderByWithAggregationInput>>('CustomFieldOrderByWithAggregationInput').implement({
  fields: CustomFieldOrderByWithAggregationInputFields,
});

export const CustomFieldScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CustomFieldScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[CustomFieldScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[CustomFieldScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  type: t.field({"required":false,"type":StringWithAggregatesFilter}),
  key: t.field({"required":false,"type":StringWithAggregatesFilter}),
  defaultValue: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  settings: t.field({"required":false,"type":JsonNullableWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const CustomFieldScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldScalarWhereWithAggregatesInput>>('CustomFieldScalarWhereWithAggregatesInput').implement({
  fields: CustomFieldScalarWhereWithAggregatesInputFields,
});

export const EvaluationWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  templateId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  isQuickEval: t.field({"required":false,"type":BoolFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFilter}),
  eventId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  template: t.field({"required":false,"type":TemplateWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationListRelationFilter}),
  event: t.field({"required":false,"type":EventWhereInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionListRelationFilter}),
});
export const EvaluationWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationWhereInput>>('EvaluationWhereInput').implement({
  fields: EvaluationWhereInputFields,
});

export const EvaluationOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  isQuickEval: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  score: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  template: t.field({"required":false,"type":TemplateOrderByWithRelationInput}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationOrderByRelationAggregateInput}),
  event: t.field({"required":false,"type":EventOrderByWithRelationInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionOrderByRelationAggregateInput}),
});
export const EvaluationOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationOrderByWithRelationInput>>('EvaluationOrderByWithRelationInput').implement({
  fields: EvaluationOrderByWithRelationInputFields,
});

export const EvaluationWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EvaluationWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationWhereInput]}),
  templateId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  isQuickEval: t.field({"required":false,"type":BoolFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFilter}),
  eventId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  template: t.field({"required":false,"type":TemplateWhereInput}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationListRelationFilter}),
  event: t.field({"required":false,"type":EventWhereInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionListRelationFilter}),
});
export const EvaluationWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationWhereUniqueInput>>('EvaluationWhereUniqueInput').implement({
  fields: EvaluationWhereUniqueInputFields,
});

export const EvaluationOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  isQuickEval: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  score: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EvaluationCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EvaluationAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EvaluationMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EvaluationMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EvaluationSumOrderByAggregateInput}),
});
export const EvaluationOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationOrderByWithAggregationInput>>('EvaluationOrderByWithAggregationInput').implement({
  fields: EvaluationOrderByWithAggregationInputFields,
});

export const EvaluationScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EvaluationScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EvaluationScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  templateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  isQuickEval: t.field({"required":false,"type":BoolWithAggregatesFilter}),
  description: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESWithAggregatesFilter}),
  eventId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  createdAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
});
export const EvaluationScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationScalarWhereWithAggregatesInput>>('EvaluationScalarWhereWithAggregatesInput').implement({
  fields: EvaluationScalarWhereWithAggregatesInputFields,
});

export const EvaluationQuestionWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
  inputType: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  question: t.field({"required":false,"type":StringNullableFilter}),
  answer: t.field({"required":false,"type":StringFilter}),
  evaluation: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationQuestionWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionWhereInput>>('EvaluationQuestionWhereInput').implement({
  fields: EvaluationQuestionWhereInputFields,
});

export const EvaluationQuestionOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  question: t.field({"required":false,"type":SortOrder}),
  answer: t.field({"required":false,"type":SortOrder}),
  evaluation: t.field({"required":false,"type":EvaluationOrderByWithRelationInput}),
});
export const EvaluationQuestionOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionOrderByWithRelationInput>>('EvaluationQuestionOrderByWithRelationInput').implement({
  fields: EvaluationQuestionOrderByWithRelationInputFields,
});

export const EvaluationQuestionWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationQuestionWhereInput]}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
  inputType: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  question: t.field({"required":false,"type":StringNullableFilter}),
  answer: t.field({"required":false,"type":StringFilter}),
  evaluation: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationQuestionWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionWhereUniqueInput>>('EvaluationQuestionWhereUniqueInput').implement({
  fields: EvaluationQuestionWhereUniqueInputFields,
});

export const EvaluationQuestionOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  question: t.field({"required":false,"type":SortOrder}),
  answer: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":EvaluationQuestionCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":EvaluationQuestionAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":EvaluationQuestionMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":EvaluationQuestionMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":EvaluationQuestionSumOrderByAggregateInput}),
});
export const EvaluationQuestionOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionOrderByWithAggregationInput>>('EvaluationQuestionOrderByWithAggregationInput').implement({
  fields: EvaluationQuestionOrderByWithAggregationInputFields,
});

export const EvaluationQuestionScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationQuestionScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[EvaluationQuestionScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[EvaluationQuestionScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  evaluationId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  inputType: t.field({"required":false,"type":StringWithAggregatesFilter}),
  settings: t.field({"required":false,"type":JsonNullableWithAggregatesFilter}),
  question: t.field({"required":false,"type":StringNullableWithAggregatesFilter}),
  answer: t.field({"required":false,"type":StringWithAggregatesFilter}),
});
export const EvaluationQuestionScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionScalarWhereWithAggregatesInput>>('EvaluationQuestionScalarWhereWithAggregatesInput').implement({
  fields: EvaluationQuestionScalarWhereWithAggregatesInputFields,
});

export const SharedCandidateLinkWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  OR: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  NOT: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  visibleSections: t.field({"required":false,"type":StringNullableListFilter}),
  editModelSections: t.field({"required":false,"type":StringNullableListFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  expiration: t.field({"required":false,"type":DateTimeFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const SharedCandidateLinkWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkWhereInput>>('SharedCandidateLinkWhereInput').implement({
  fields: SharedCandidateLinkWhereInputFields,
});

export const SharedCandidateLinkOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  visibleSections: t.field({"required":false,"type":SortOrder}),
  editModelSections: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  expiration: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
});
export const SharedCandidateLinkOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkOrderByWithRelationInput>>('SharedCandidateLinkOrderByWithRelationInput').implement({
  fields: SharedCandidateLinkOrderByWithRelationInputFields,
});

export const SharedCandidateLinkWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  OR: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  NOT: t.field({"required":false,"type":[SharedCandidateLinkWhereInput]}),
  name: t.field({"required":false,"type":StringFilter}),
  visibleSections: t.field({"required":false,"type":StringNullableListFilter}),
  editModelSections: t.field({"required":false,"type":StringNullableListFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  expiration: t.field({"required":false,"type":DateTimeFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const SharedCandidateLinkWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkWhereUniqueInput>>('SharedCandidateLinkWhereUniqueInput').implement({
  fields: SharedCandidateLinkWhereUniqueInputFields,
});

export const SharedCandidateLinkOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  visibleSections: t.field({"required":false,"type":SortOrder}),
  editModelSections: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  expiration: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":SharedCandidateLinkCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":SharedCandidateLinkAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":SharedCandidateLinkMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":SharedCandidateLinkMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":SharedCandidateLinkSumOrderByAggregateInput}),
});
export const SharedCandidateLinkOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkOrderByWithAggregationInput>>('SharedCandidateLinkOrderByWithAggregationInput').implement({
  fields: SharedCandidateLinkOrderByWithAggregationInputFields,
});

export const SharedCandidateLinkScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  visibleSections: t.field({"required":false,"type":StringNullableListFilter}),
  editModelSections: t.field({"required":false,"type":StringNullableListFilter}),
  link: t.field({"required":false,"type":StringWithAggregatesFilter}),
  expiration: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const SharedCandidateLinkScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkScalarWhereWithAggregatesInput>>('SharedCandidateLinkScalarWhereWithAggregatesInput').implement({
  fields: SharedCandidateLinkScalarWhereWithAggregatesInputFields,
});

export const TaskWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskWhereInput]}),
  OR: t.field({"required":false,"type":[TaskWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  status: t.field({"required":false,"type":StringFilter}),
  dueDate: t.field({"required":false,"type":DateTimeFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberListRelationFilter}),
  Candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const TaskWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskWhereInput>>('TaskWhereInput').implement({
  fields: TaskWhereInputFields,
});

export const TaskOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  dueDate: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  company: t.field({"required":false,"type":CompanyOrderByWithRelationInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberOrderByRelationAggregateInput}),
  Candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
});
export const TaskOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskOrderByWithRelationInput>>('TaskOrderByWithRelationInput').implement({
  fields: TaskOrderByWithRelationInputFields,
});

export const TaskWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TaskWhereInput]}),
  OR: t.field({"required":false,"type":[TaskWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskWhereInput]}),
  companyId: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  status: t.field({"required":false,"type":StringFilter}),
  dueDate: t.field({"required":false,"type":DateTimeFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  company: t.field({"required":false,"type":CompanyWhereInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberListRelationFilter}),
  Candidate: t.field({"required":false,"type":CandidateWhereInput}),
});
export const TaskWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskWhereUniqueInput>>('TaskWhereUniqueInput').implement({
  fields: TaskWhereUniqueInputFields,
});

export const TaskOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  dueDate: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TaskCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TaskAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TaskMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TaskMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TaskSumOrderByAggregateInput}),
});
export const TaskOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskOrderByWithAggregationInput>>('TaskOrderByWithAggregationInput').implement({
  fields: TaskOrderByWithAggregationInputFields,
});

export const TaskScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TaskScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TaskScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  companyId: t.field({"required":false,"type":StringWithAggregatesFilter}),
  name: t.field({"required":false,"type":StringWithAggregatesFilter}),
  status: t.field({"required":false,"type":StringWithAggregatesFilter}),
  dueDate: t.field({"required":false,"type":DateTimeWithAggregatesFilter}),
  note: t.field({"required":false,"type":StringWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
});
export const TaskScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskScalarWhereWithAggregatesInput>>('TaskScalarWhereWithAggregatesInput').implement({
  fields: TaskScalarWhereWithAggregatesInputFields,
});

export const TaskMemberWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  OR: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  taskId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  task: t.field({"required":false,"type":TaskWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const TaskMemberWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberWhereInput>>('TaskMemberWhereInput').implement({
  fields: TaskMemberWhereInputFields,
});

export const TaskMemberOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  task: t.field({"required":false,"type":TaskOrderByWithRelationInput}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
});
export const TaskMemberOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberOrderByWithRelationInput>>('TaskMemberOrderByWithRelationInput').implement({
  fields: TaskMemberOrderByWithRelationInputFields,
});

export const TaskMemberWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  OR: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskMemberWhereInput]}),
  taskId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  task: t.field({"required":false,"type":TaskWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const TaskMemberWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberWhereUniqueInput>>('TaskMemberWhereUniqueInput').implement({
  fields: TaskMemberWhereUniqueInputFields,
});

export const TaskMemberOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":TaskMemberCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":TaskMemberAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":TaskMemberMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":TaskMemberMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":TaskMemberSumOrderByAggregateInput}),
});
export const TaskMemberOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberOrderByWithAggregationInput>>('TaskMemberOrderByWithAggregationInput').implement({
  fields: TaskMemberOrderByWithAggregationInputFields,
});

export const TaskMemberScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskMemberScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[TaskMemberScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[TaskMemberScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  taskId: t.field({"required":false,"type":IntWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const TaskMemberScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberScalarWhereWithAggregatesInput>>('TaskMemberScalarWhereWithAggregatesInput').implement({
  fields: TaskMemberScalarWhereWithAggregatesInputFields,
});

export const FollowWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[FollowWhereInput]}),
  OR: t.field({"required":false,"type":[FollowWhereInput]}),
  NOT: t.field({"required":false,"type":[FollowWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  talentPoolId: t.field({"required":false,"type":IntNullableFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const FollowWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowWhereInput>>('FollowWhereInput').implement({
  fields: FollowWhereInputFields,
});

export const FollowOrderByWithRelationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  offer: t.field({"required":false,"type":OfferOrderByWithRelationInput}),
  candidate: t.field({"required":false,"type":CandidateOrderByWithRelationInput}),
  talentPool: t.field({"required":false,"type":TalentPoolOrderByWithRelationInput}),
  teamMember: t.field({"required":false,"type":HiringRoleOrderByWithRelationInput}),
});
export const FollowOrderByWithRelationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowOrderByWithRelationInput>>('FollowOrderByWithRelationInput').implement({
  fields: FollowOrderByWithRelationInputFields,
});

export const FollowWhereUniqueInputFields = (t: any) => ({
  id: t.int({"required":false}),
  AND: t.field({"required":false,"type":[FollowWhereInput]}),
  OR: t.field({"required":false,"type":[FollowWhereInput]}),
  NOT: t.field({"required":false,"type":[FollowWhereInput]}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  talentPoolId: t.field({"required":false,"type":IntNullableFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  offer: t.field({"required":false,"type":OfferWhereInput}),
  candidate: t.field({"required":false,"type":CandidateWhereInput}),
  talentPool: t.field({"required":false,"type":TalentPoolWhereInput}),
  teamMember: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const FollowWhereUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowWhereUniqueInput>>('FollowWhereUniqueInput').implement({
  fields: FollowWhereUniqueInputFields,
});

export const FollowOrderByWithAggregationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  _count: t.field({"required":false,"type":FollowCountOrderByAggregateInput}),
  _avg: t.field({"required":false,"type":FollowAvgOrderByAggregateInput}),
  _max: t.field({"required":false,"type":FollowMaxOrderByAggregateInput}),
  _min: t.field({"required":false,"type":FollowMinOrderByAggregateInput}),
  _sum: t.field({"required":false,"type":FollowSumOrderByAggregateInput}),
});
export const FollowOrderByWithAggregationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowOrderByWithAggregationInput>>('FollowOrderByWithAggregationInput').implement({
  fields: FollowOrderByWithAggregationInputFields,
});

export const FollowScalarWhereWithAggregatesInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[FollowScalarWhereWithAggregatesInput]}),
  OR: t.field({"required":false,"type":[FollowScalarWhereWithAggregatesInput]}),
  NOT: t.field({"required":false,"type":[FollowScalarWhereWithAggregatesInput]}),
  id: t.field({"required":false,"type":IntWithAggregatesFilter}),
  offerId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  candidateId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  talentPoolId: t.field({"required":false,"type":IntNullableWithAggregatesFilter}),
  teamMemberId: t.field({"required":false,"type":IntWithAggregatesFilter}),
});
export const FollowScalarWhereWithAggregatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowScalarWhereWithAggregatesInput>>('FollowScalarWhereWithAggregatesInput').implement({
  fields: FollowScalarWhereWithAggregatesInputFields,
});

export const UserCreateInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  photo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutUserProfilePhotoInput}),
  accounts: t.field({"required":false,"type":AccountCreateNestedManyWithoutUserInput}),
  sessions: t.field({"required":false,"type":SessionCreateNestedManyWithoutUserInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutUserInput}),
  companiesOwned: t.field({"required":false,"type":CompanyCreateNestedManyWithoutOwnerInput}),
});
export const UserCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateInput>>('UserCreateInput').implement({
  fields: UserCreateInputFields,
});

export const UserUpdateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  photo: t.field({"required":false,"type":AttachmentUpdateOneWithoutUserProfilePhotoNestedInput}),
  accounts: t.field({"required":false,"type":AccountUpdateManyWithoutUserNestedInput}),
  sessions: t.field({"required":false,"type":SessionUpdateManyWithoutUserNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutUserNestedInput}),
  companiesOwned: t.field({"required":false,"type":CompanyUpdateManyWithoutOwnerNestedInput}),
});
export const UserUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateInput>>('UserUpdateInput').implement({
  fields: UserUpdateInputFields,
});

export const UserCreateManyInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  photoId: t.int({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
});
export const UserCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateManyInput>>('UserCreateManyInput').implement({
  fields: UserCreateManyInputFields,
});

export const UserUpdateManyMutationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
});
export const UserUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateManyMutationInput>>('UserUpdateManyMutationInput').implement({
  fields: UserUpdateManyMutationInputFields,
});

export const AccountCreateInputFields = (t: any) => ({
  id: t.string({"required":false}),
  type: t.string({"required":true}),
  provider: t.string({"required":true}),
  providerAccountId: t.string({"required":true}),
  refresh_token: t.string({"required":false}),
  access_token: t.string({"required":false}),
  expires_at: t.int({"required":false}),
  token_type: t.string({"required":false}),
  scope: t.string({"required":false}),
  id_token: t.string({"required":false}),
  session_state: t.string({"required":false}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutAccountsInput}),
});
export const AccountCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateInput>>('AccountCreateInput').implement({
  fields: AccountCreateInputFields,
});

export const AccountUpdateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  provider: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  providerAccountId: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  refresh_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  access_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  expires_at: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  token_type: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  scope: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  id_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  session_state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutAccountsNestedInput}),
});
export const AccountUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateInput>>('AccountUpdateInput').implement({
  fields: AccountUpdateInputFields,
});

export const AccountCreateManyInputFields = (t: any) => ({
  id: t.string({"required":false}),
  userId: t.string({"required":true}),
  type: t.string({"required":true}),
  provider: t.string({"required":true}),
  providerAccountId: t.string({"required":true}),
  refresh_token: t.string({"required":false}),
  access_token: t.string({"required":false}),
  expires_at: t.int({"required":false}),
  token_type: t.string({"required":false}),
  scope: t.string({"required":false}),
  id_token: t.string({"required":false}),
  session_state: t.string({"required":false}),
});
export const AccountCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateManyInput>>('AccountCreateManyInput').implement({
  fields: AccountCreateManyInputFields,
});

export const AccountUpdateManyMutationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  provider: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  providerAccountId: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  refresh_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  access_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  expires_at: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  token_type: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  scope: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  id_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  session_state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
});
export const AccountUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateManyMutationInput>>('AccountUpdateManyMutationInput').implement({
  fields: AccountUpdateManyMutationInputFields,
});

export const SessionCreateInputFields = (t: any) => ({
  id: t.string({"required":false}),
  sessionToken: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutSessionsInput}),
});
export const SessionCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateInput>>('SessionCreateInput').implement({
  fields: SessionCreateInputFields,
});

export const SessionUpdateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  sessionToken: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expires: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutSessionsNestedInput}),
});
export const SessionUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateInput>>('SessionUpdateInput').implement({
  fields: SessionUpdateInputFields,
});

export const SessionCreateManyInputFields = (t: any) => ({
  id: t.string({"required":false}),
  sessionToken: t.string({"required":true}),
  userId: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
});
export const SessionCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateManyInput>>('SessionCreateManyInput').implement({
  fields: SessionCreateManyInputFields,
});

export const SessionUpdateManyMutationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  sessionToken: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expires: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const SessionUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateManyMutationInput>>('SessionUpdateManyMutationInput').implement({
  fields: SessionUpdateManyMutationInputFields,
});

export const VerificationTokenCreateInputFields = (t: any) => ({
  identifier: t.string({"required":true}),
  token: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
});
export const VerificationTokenCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenCreateInput>>('VerificationTokenCreateInput').implement({
  fields: VerificationTokenCreateInputFields,
});

export const VerificationTokenUpdateInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  token: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expires: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const VerificationTokenUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenUpdateInput>>('VerificationTokenUpdateInput').implement({
  fields: VerificationTokenUpdateInputFields,
});

export const VerificationTokenCreateManyInputFields = (t: any) => ({
  identifier: t.string({"required":true}),
  token: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
});
export const VerificationTokenCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenCreateManyInput>>('VerificationTokenCreateManyInput').implement({
  fields: VerificationTokenCreateManyInputFields,
});

export const VerificationTokenUpdateManyMutationInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  token: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expires: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const VerificationTokenUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenUpdateManyMutationInput>>('VerificationTokenUpdateManyMutationInput').implement({
  fields: VerificationTokenUpdateManyMutationInputFields,
});

export const AttachmentCreateInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateInput>>('AttachmentCreateInput').implement({
  fields: AttachmentCreateInputFields,
});

export const AttachmentUpdateInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateInput>>('AttachmentUpdateInput').implement({
  fields: AttachmentUpdateInputFields,
});

export const AttachmentCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  uploaderId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  companyId: t.string({"required":true}),
});
export const AttachmentCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateManyInput>>('AttachmentCreateManyInput').implement({
  fields: AttachmentCreateManyInputFields,
});

export const AttachmentUpdateManyMutationInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const AttachmentUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateManyMutationInput>>('AttachmentUpdateManyMutationInput').implement({
  fields: AttachmentUpdateManyMutationInputFields,
});

export const HiringRoleCreateInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateInput>>('HiringRoleCreateInput').implement({
  fields: HiringRoleCreateInputFields,
});

export const HiringRoleUpdateInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateInput>>('HiringRoleUpdateInput').implement({
  fields: HiringRoleUpdateInputFields,
});

export const HiringRoleCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  userId: t.string({"required":true}),
  roleId: t.int({"required":true}),
  companyId: t.string({"required":true}),
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const HiringRoleCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyInput>>('HiringRoleCreateManyInput').implement({
  fields: HiringRoleCreateManyInputFields,
});

export const HiringRoleUpdateManyMutationInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const HiringRoleUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyMutationInput>>('HiringRoleUpdateManyMutationInput').implement({
  fields: HiringRoleUpdateManyMutationInputFields,
});

export const RoleCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutRolesInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutRoleInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutRoleInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutRoleInput}),
});
export const RoleCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateInput>>('RoleCreateInput').implement({
  fields: RoleCreateInputFields,
});

export const RoleUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutRolesNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutRoleNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutRoleNestedInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutRoleNestedInput}),
});
export const RoleUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateInput>>('RoleUpdateInput').implement({
  fields: RoleUpdateInputFields,
});

export const RoleCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const RoleCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateManyInput>>('RoleCreateManyInput').implement({
  fields: RoleCreateManyInputFields,
});

export const RoleUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const RoleUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateManyMutationInput>>('RoleUpdateManyMutationInput').implement({
  fields: RoleUpdateManyMutationInputFields,
});

export const CompanyCreateInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateInput>>('CompanyCreateInput').implement({
  fields: CompanyCreateInputFields,
});

export const CompanyUpdateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateInput>>('CompanyUpdateInput').implement({
  fields: CompanyUpdateInputFields,
});

export const CompanyCreateManyInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  ownerId: t.string({"required":true}),
  logoId: t.int({"required":false}),
});
export const CompanyCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateManyInput>>('CompanyCreateManyInput').implement({
  fields: CompanyCreateManyInputFields,
});

export const CompanyUpdateManyMutationInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const CompanyUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateManyMutationInput>>('CompanyUpdateManyMutationInput').implement({
  fields: CompanyUpdateManyMutationInputFields,
});

export const SubscriptionDataCreateInputFields = (t: any) => ({
  active: t.boolean({"required":true}),
  currentPeriodStart: t.field({"required":true,"type":DateTime}),
  currentPeriodEnd: t.field({"required":true,"type":DateTime}),
  status: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutSubscriptionInput}),
});
export const SubscriptionDataCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCreateInput>>('SubscriptionDataCreateInput').implement({
  fields: SubscriptionDataCreateInputFields,
});

export const SubscriptionDataUpdateInputFields = (t: any) => ({
  active: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutSubscriptionNestedInput}),
});
export const SubscriptionDataUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpdateInput>>('SubscriptionDataUpdateInput').implement({
  fields: SubscriptionDataUpdateInputFields,
});

export const SubscriptionDataCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  active: t.boolean({"required":true}),
  currentPeriodStart: t.field({"required":true,"type":DateTime}),
  currentPeriodEnd: t.field({"required":true,"type":DateTime}),
  status: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const SubscriptionDataCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCreateManyInput>>('SubscriptionDataCreateManyInput').implement({
  fields: SubscriptionDataCreateManyInputFields,
});

export const SubscriptionDataUpdateManyMutationInputFields = (t: any) => ({
  active: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const SubscriptionDataUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpdateManyMutationInput>>('SubscriptionDataUpdateManyMutationInput').implement({
  fields: SubscriptionDataUpdateManyMutationInputFields,
});

export const CompanyMetadataCreateInputFields = (t: any) => ({
  key: t.string({"required":true}),
  value: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  type: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutMetadataInput}),
});
export const CompanyMetadataCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateInput>>('CompanyMetadataCreateInput').implement({
  fields: CompanyMetadataCreateInputFields,
});

export const CompanyMetadataUpdateInputFields = (t: any) => ({
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutMetadataNestedInput}),
});
export const CompanyMetadataUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateInput>>('CompanyMetadataUpdateInput').implement({
  fields: CompanyMetadataUpdateInputFields,
});

export const CompanyMetadataCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  key: t.string({"required":true}),
  value: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  type: t.string({"required":false}),
});
export const CompanyMetadataCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateManyInput>>('CompanyMetadataCreateManyInput').implement({
  fields: CompanyMetadataCreateManyInputFields,
});

export const CompanyMetadataUpdateManyMutationInputFields = (t: any) => ({
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const CompanyMetadataUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateManyMutationInput>>('CompanyMetadataUpdateManyMutationInput').implement({
  fields: CompanyMetadataUpdateManyMutationInputFields,
});

export const DepartmentCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutDepartmentsInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutDepartmentInput}),
});
export const DepartmentCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateInput>>('DepartmentCreateInput').implement({
  fields: DepartmentCreateInputFields,
});

export const DepartmentUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutDepartmentsNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutDepartmentNestedInput}),
});
export const DepartmentUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateInput>>('DepartmentUpdateInput').implement({
  fields: DepartmentUpdateInputFields,
});

export const DepartmentCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const DepartmentCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateManyInput>>('DepartmentCreateManyInput').implement({
  fields: DepartmentCreateManyInputFields,
});

export const DepartmentUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const DepartmentUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateManyMutationInput>>('DepartmentUpdateManyMutationInput').implement({
  fields: DepartmentUpdateManyMutationInputFields,
});

export const DisqualifyReasonCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  action: t.field({"required":true,"type":Json}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutDisqualifyReasonsInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutDisqualifyReasonInput}),
});
export const DisqualifyReasonCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateInput>>('DisqualifyReasonCreateInput').implement({
  fields: DisqualifyReasonCreateInputFields,
});

export const DisqualifyReasonUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":Json}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutDisqualifyReasonNestedInput}),
});
export const DisqualifyReasonUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateInput>>('DisqualifyReasonUpdateInput').implement({
  fields: DisqualifyReasonUpdateInputFields,
});

export const DisqualifyReasonCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  action: t.field({"required":true,"type":Json}),
  companyId: t.string({"required":true}),
});
export const DisqualifyReasonCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateManyInput>>('DisqualifyReasonCreateManyInput').implement({
  fields: DisqualifyReasonCreateManyInputFields,
});

export const DisqualifyReasonUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":Json}),
});
export const DisqualifyReasonUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateManyMutationInput>>('DisqualifyReasonUpdateManyMutationInput').implement({
  fields: DisqualifyReasonUpdateManyMutationInputFields,
});

export const TagSourceCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTagSourcesInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutTagInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateCreateNestedManyWithoutReferrerInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutTagInput}),
});
export const TagSourceCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateInput>>('TagSourceCreateInput').implement({
  fields: TagSourceCreateInputFields,
});

export const TagSourceUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTagSourcesNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutTagNestedInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateUpdateManyWithoutReferrerNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutTagNestedInput}),
});
export const TagSourceUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateInput>>('TagSourceUpdateInput').implement({
  fields: TagSourceUpdateInputFields,
});

export const TagSourceCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  companyId: t.string({"required":true}),
});
export const TagSourceCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateManyInput>>('TagSourceCreateManyInput').implement({
  fields: TagSourceCreateManyInputFields,
});

export const TagSourceUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
});
export const TagSourceUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateManyMutationInput>>('TagSourceUpdateManyMutationInput').implement({
  fields: TagSourceUpdateManyMutationInputFields,
});

export const AuditLogCreateInputFields = (t: any) => ({
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAuditLogsInput}),
  user: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAuditLogsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutAuditLogsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAuditLogsInput}),
});
export const AuditLogCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateInput>>('AuditLogCreateInput').implement({
  fields: AuditLogCreateInputFields,
});

export const AuditLogUpdateInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAuditLogsNestedInput}),
  user: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAuditLogsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutAuditLogsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutAuditLogsNestedInput}),
});
export const AuditLogUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateInput>>('AuditLogUpdateInput').implement({
  fields: AuditLogUpdateInputFields,
});

export const AuditLogCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  userId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
});
export const AuditLogCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyInput>>('AuditLogCreateManyInput').implement({
  fields: AuditLogCreateManyInputFields,
});

export const AuditLogUpdateManyMutationInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const AuditLogUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyMutationInput>>('AuditLogUpdateManyMutationInput').implement({
  fields: AuditLogUpdateManyMutationInputFields,
});

export const MeetingRoomCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.string({"required":true}),
  link: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutMeetingRoomsInput}),
});
export const MeetingRoomCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateInput>>('MeetingRoomCreateInput').implement({
  fields: MeetingRoomCreateInputFields,
});

export const MeetingRoomUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInput}),
});
export const MeetingRoomUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateInput>>('MeetingRoomUpdateInput').implement({
  fields: MeetingRoomUpdateInputFields,
});

export const MeetingRoomCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  type: t.string({"required":true}),
  link: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const MeetingRoomCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateManyInput>>('MeetingRoomCreateManyInput').implement({
  fields: MeetingRoomCreateManyInputFields,
});

export const MeetingRoomUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const MeetingRoomUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateManyMutationInput>>('MeetingRoomUpdateManyMutationInput').implement({
  fields: MeetingRoomUpdateManyMutationInputFields,
});

export const EventScheduleCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventScheduleInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput}),
});
export const EventScheduleCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateInput>>('EventScheduleCreateInput').implement({
  fields: EventScheduleCreateInputFields,
});

export const EventScheduleUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dateRange: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  expiresAfter: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  inviteAll: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  bufferTime: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  meetingLimit: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  Interval: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventScheduleNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput}),
});
export const EventScheduleUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateInput>>('EventScheduleUpdateInput').implement({
  fields: EventScheduleUpdateInputFields,
});

export const EventScheduleCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const EventScheduleCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateManyInput>>('EventScheduleCreateManyInput').implement({
  fields: EventScheduleCreateManyInputFields,
});

export const EventScheduleUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dateRange: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  expiresAfter: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  inviteAll: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  bufferTime: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  meetingLimit: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  Interval: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const EventScheduleUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateManyMutationInput>>('EventScheduleUpdateManyMutationInput').implement({
  fields: EventScheduleUpdateManyMutationInputFields,
});

export const EventScheduleInterviewerCreateInputFields = (t: any) => ({
  availability: t.field({"required":true,"type":Json}),
  eventSchedule: t.field({"required":true,"type":EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleInterviewerCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateInput>>('EventScheduleInterviewerCreateInput').implement({
  fields: EventScheduleInterviewerCreateInputFields,
});

export const EventScheduleInterviewerUpdateInputFields = (t: any) => ({
  availability: t.field({"required":false,"type":Json}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput}),
});
export const EventScheduleInterviewerUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateInput>>('EventScheduleInterviewerUpdateInput').implement({
  fields: EventScheduleInterviewerUpdateInputFields,
});

export const EventScheduleInterviewerCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventScheduleId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
  availability: t.field({"required":true,"type":Json}),
});
export const EventScheduleInterviewerCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateManyInput>>('EventScheduleInterviewerCreateManyInput').implement({
  fields: EventScheduleInterviewerCreateManyInputFields,
});

export const EventScheduleInterviewerUpdateManyMutationInputFields = (t: any) => ({
  availability: t.field({"required":false,"type":Json}),
});
export const EventScheduleInterviewerUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateManyMutationInput>>('EventScheduleInterviewerUpdateManyMutationInput').implement({
  fields: EventScheduleInterviewerUpdateManyMutationInputFields,
});

export const EventScheduleEvaluationCreateInputFields = (t: any) => ({
  eventSchedule: t.field({"required":true,"type":EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInput}),
  evaluation: t.field({"required":true,"type":EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleEvaluationCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateInput>>('EventScheduleEvaluationCreateInput').implement({
  fields: EventScheduleEvaluationCreateInputFields,
});

export const EventScheduleEvaluationUpdateInputFields = (t: any) => ({
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput}),
  evaluation: t.field({"required":false,"type":EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput}),
});
export const EventScheduleEvaluationUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateInput>>('EventScheduleEvaluationUpdateInput').implement({
  fields: EventScheduleEvaluationUpdateInputFields,
});

export const EventScheduleEvaluationCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventScheduleId: t.int({"required":true}),
  evaluationId: t.int({"required":true}),
});
export const EventScheduleEvaluationCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateManyInput>>('EventScheduleEvaluationCreateManyInput').implement({
  fields: EventScheduleEvaluationCreateManyInputFields,
});

export const EventScheduleEvaluationUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const EventScheduleEvaluationUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateManyMutationInput>>('EventScheduleEvaluationUpdateManyMutationInput').implement({
  fields: EventScheduleEvaluationUpdateManyMutationInputFields,
});

export const EventCreateInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateInput>>('EventCreateInput').implement({
  fields: EventCreateInputFields,
});

export const EventUpdateInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateInput>>('EventUpdateInput').implement({
  fields: EventUpdateInputFields,
});

export const EventCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  createdById: t.int({"required":true}),
});
export const EventCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateManyInput>>('EventCreateManyInput').implement({
  fields: EventCreateManyInputFields,
});

export const EventUpdateManyMutationInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const EventUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyMutationInput>>('EventUpdateManyMutationInput').implement({
  fields: EventUpdateManyMutationInputFields,
});

export const EventInterviewerCreateInputFields = (t: any) => ({
  event: t.field({"required":true,"type":EventCreateNestedOneWithoutEventInterviewerInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEventInterviewerInput}),
});
export const EventInterviewerCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateInput>>('EventInterviewerCreateInput').implement({
  fields: EventInterviewerCreateInputFields,
});

export const EventInterviewerUpdateInputFields = (t: any) => ({
  event: t.field({"required":false,"type":EventUpdateOneRequiredWithoutEventInterviewerNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInput}),
});
export const EventInterviewerUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateInput>>('EventInterviewerUpdateInput').implement({
  fields: EventInterviewerUpdateInputFields,
});

export const EventInterviewerCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
});
export const EventInterviewerCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateManyInput>>('EventInterviewerCreateManyInput').implement({
  fields: EventInterviewerCreateManyInputFields,
});

export const EventInterviewerUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const EventInterviewerUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateManyMutationInput>>('EventInterviewerUpdateManyMutationInput').implement({
  fields: EventInterviewerUpdateManyMutationInputFields,
});

export const OfferCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateInput>>('OfferCreateInput').implement({
  fields: OfferCreateInputFields,
});

export const OfferUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateInput>>('OfferUpdateInput').implement({
  fields: OfferUpdateInputFields,
});

export const OfferCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
  departmentId: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  screeningQuestionsTemplateId: t.int({"required":false}),
  pipelineTemplateId: t.int({"required":false}),
  autoConfirmationEmailId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyInput>>('OfferCreateManyInput').implement({
  fields: OfferCreateManyInputFields,
});

export const OfferUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const OfferUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyMutationInput>>('OfferUpdateManyMutationInput').implement({
  fields: OfferUpdateManyMutationInputFields,
});

export const OfferFileCreateInputFields = (t: any) => ({
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutFilesInput}),
  attachment: t.field({"required":true,"type":AttachmentCreateNestedOneWithoutOfferFilesInput}),
});
export const OfferFileCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateInput>>('OfferFileCreateInput').implement({
  fields: OfferFileCreateInputFields,
});

export const OfferFileUpdateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutFilesNestedInput}),
  attachment: t.field({"required":false,"type":AttachmentUpdateOneRequiredWithoutOfferFilesNestedInput}),
});
export const OfferFileUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateInput>>('OfferFileUpdateInput').implement({
  fields: OfferFileUpdateInputFields,
});

export const OfferFileCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
  attachmentId: t.int({"required":true}),
});
export const OfferFileCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateManyInput>>('OfferFileCreateManyInput').implement({
  fields: OfferFileCreateManyInputFields,
});

export const OfferFileUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const OfferFileUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateManyMutationInput>>('OfferFileUpdateManyMutationInput').implement({
  fields: OfferFileUpdateManyMutationInputFields,
});

export const MatchCreateInputFields = (t: any) => ({
  isHired: t.boolean({"required":false}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMatchesInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutOffersInput}),
  stage: t.field({"required":false,"type":StageCreateNestedOneWithoutMatchesInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonCreateNestedOneWithoutMatchesInput}),
});
export const MatchCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateInput>>('MatchCreateInput').implement({
  fields: MatchCreateInputFields,
});

export const MatchUpdateInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMatchesNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutOffersNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneWithoutMatchesNestedInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonUpdateOneWithoutMatchesNestedInput}),
});
export const MatchUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateInput>>('MatchUpdateInput').implement({
  fields: MatchUpdateInputFields,
});

export const MatchCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
  candidateId: t.int({"required":true}),
  stageId: t.int({"required":false}),
  isHired: t.boolean({"required":false}),
  disqualifyReasonId: t.int({"required":false}),
});
export const MatchCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyInput>>('MatchCreateManyInput').implement({
  fields: MatchCreateManyInputFields,
});

export const MatchUpdateManyMutationInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
});
export const MatchUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyMutationInput>>('MatchUpdateManyMutationInput').implement({
  fields: MatchUpdateManyMutationInputFields,
});

export const OfferTagCreateInputFields = (t: any) => ({
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutOfferTagsInput}),
  tag: t.field({"required":true,"type":TagSourceCreateNestedOneWithoutOfferTagsInput}),
});
export const OfferTagCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateInput>>('OfferTagCreateInput').implement({
  fields: OfferTagCreateInputFields,
});

export const OfferTagUpdateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutOfferTagsNestedInput}),
  tag: t.field({"required":false,"type":TagSourceUpdateOneRequiredWithoutOfferTagsNestedInput}),
});
export const OfferTagUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateInput>>('OfferTagUpdateInput').implement({
  fields: OfferTagUpdateInputFields,
});

export const OfferTagCreateManyInputFields = (t: any) => ({
  offerId: t.int({"required":true}),
  tagId: t.int({"required":true}),
});
export const OfferTagCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateManyInput>>('OfferTagCreateManyInput').implement({
  fields: OfferTagCreateManyInputFields,
});

export const OfferTagUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const OfferTagUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateManyMutationInput>>('OfferTagUpdateManyMutationInput').implement({
  fields: OfferTagUpdateManyMutationInputFields,
});

export const MembershipCreateInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutMembershipsInput}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutMembershipsInput}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMembershipsInput}),
});
export const MembershipCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateInput>>('MembershipCreateInput').implement({
  fields: MembershipCreateInputFields,
});

export const MembershipUpdateInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutMembershipsNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutMembershipsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMembershipsNestedInput}),
});
export const MembershipUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateInput>>('MembershipUpdateInput').implement({
  fields: MembershipUpdateInputFields,
});

export const MembershipCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  roleId: t.int({"required":false}),
  offerId: t.int({"required":true}),
});
export const MembershipCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyInput>>('MembershipCreateManyInput').implement({
  fields: MembershipCreateManyInputFields,
});

export const MembershipUpdateManyMutationInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
});
export const MembershipUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyMutationInput>>('MembershipUpdateManyMutationInput').implement({
  fields: MembershipUpdateManyMutationInputFields,
});

export const TalentPoolCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  files: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutTalentPoolInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutTalentPoolInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTalentPoolInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTalentPoolInput}),
});
export const TalentPoolCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateInput>>('TalentPoolCreateInput').implement({
  fields: TalentPoolCreateInputFields,
});

export const TalentPoolUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  files: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutTalentPoolNestedInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTalentPoolNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTalentPoolNestedInput}),
});
export const TalentPoolUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateInput>>('TalentPoolUpdateInput').implement({
  fields: TalentPoolUpdateInputFields,
});

export const TalentPoolCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const TalentPoolCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateManyInput>>('TalentPoolCreateManyInput').implement({
  fields: TalentPoolCreateManyInputFields,
});

export const TalentPoolUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const TalentPoolUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateManyMutationInput>>('TalentPoolUpdateManyMutationInput').implement({
  fields: TalentPoolUpdateManyMutationInputFields,
});

export const TalentPoolFileCreateInputFields = (t: any) => ({
  talentPool: t.field({"required":true,"type":TalentPoolCreateNestedOneWithoutFilesInput}),
  attachment: t.field({"required":true,"type":AttachmentCreateNestedOneWithoutTalentPoolFilesInput}),
});
export const TalentPoolFileCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateInput>>('TalentPoolFileCreateInput').implement({
  fields: TalentPoolFileCreateInputFields,
});

export const TalentPoolFileUpdateInputFields = (t: any) => ({
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneRequiredWithoutFilesNestedInput}),
  attachment: t.field({"required":false,"type":AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInput}),
});
export const TalentPoolFileUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateInput>>('TalentPoolFileUpdateInput').implement({
  fields: TalentPoolFileUpdateInputFields,
});

export const TalentPoolFileCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  talentPoolId: t.int({"required":true}),
  attachmentId: t.int({"required":true}),
});
export const TalentPoolFileCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateManyInput>>('TalentPoolFileCreateManyInput').implement({
  fields: TalentPoolFileCreateManyInputFields,
});

export const TalentPoolFileUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const TalentPoolFileUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateManyMutationInput>>('TalentPoolFileUpdateManyMutationInput').implement({
  fields: TalentPoolFileUpdateManyMutationInputFields,
});

export const TalentPoolMatchCreateInputFields = (t: any) => ({
  talentPool: t.field({"required":true,"type":TalentPoolCreateNestedOneWithoutMatchesInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutTalentPoolsInput}),
});
export const TalentPoolMatchCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateInput>>('TalentPoolMatchCreateInput').implement({
  fields: TalentPoolMatchCreateInputFields,
});

export const TalentPoolMatchUpdateInputFields = (t: any) => ({
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneRequiredWithoutMatchesNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutTalentPoolsNestedInput}),
});
export const TalentPoolMatchUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateInput>>('TalentPoolMatchUpdateInput').implement({
  fields: TalentPoolMatchUpdateInputFields,
});

export const TalentPoolMatchCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  talentPoolId: t.int({"required":true}),
  candidateId: t.int({"required":true}),
});
export const TalentPoolMatchCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateManyInput>>('TalentPoolMatchCreateManyInput').implement({
  fields: TalentPoolMatchCreateManyInputFields,
});

export const TalentPoolMatchUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const TalentPoolMatchUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateManyMutationInput>>('TalentPoolMatchUpdateManyMutationInput').implement({
  fields: TalentPoolMatchUpdateManyMutationInputFields,
});

export const TemplateCreateInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateInput>>('TemplateCreateInput').implement({
  fields: TemplateCreateInputFields,
});

export const TemplateUpdateInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateInput>>('TemplateUpdateInput').implement({
  fields: TemplateUpdateInputFields,
});

export const TemplateCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
});
export const TemplateCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateManyInput>>('TemplateCreateManyInput').implement({
  fields: TemplateCreateManyInputFields,
});

export const TemplateUpdateManyMutationInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
});
export const TemplateUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateManyMutationInput>>('TemplateUpdateManyMutationInput').implement({
  fields: TemplateUpdateManyMutationInputFields,
});

export const StageCreateInputFields = (t: any) => ({
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
  template: t.field({"required":true,"type":TemplateCreateNestedOneWithoutStagesInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutStageInput}),
  visibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutStageInput}),
  metadata: t.field({"required":false,"type":StageMetadataCreateNestedManyWithoutStageInput}),
});
export const StageCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateInput>>('StageCreateInput').implement({
  fields: StageCreateInputFields,
});

export const StageUpdateInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneRequiredWithoutStagesNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutStageNestedInput}),
  visibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutStageNestedInput}),
  metadata: t.field({"required":false,"type":StageMetadataUpdateManyWithoutStageNestedInput}),
});
export const StageUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateInput>>('StageUpdateInput').implement({
  fields: StageUpdateInputFields,
});

export const StageCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  templateId: t.int({"required":true}),
  isProtected: t.boolean({"required":false}),
});
export const StageCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateManyInput>>('StageCreateManyInput').implement({
  fields: StageCreateManyInputFields,
});

export const StageUpdateManyMutationInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
});
export const StageUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateManyMutationInput>>('StageUpdateManyMutationInput').implement({
  fields: StageUpdateManyMutationInputFields,
});

export const StageVisibilityCreateInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutStageVisibilitiesInput}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutStageVisibilityInput}),
  stage: t.field({"required":true,"type":StageCreateNestedOneWithoutVisibilityInput}),
});
export const StageVisibilityCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateInput>>('StageVisibilityCreateInput').implement({
  fields: StageVisibilityCreateInputFields,
});

export const StageVisibilityUpdateInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutStageVisibilityNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneRequiredWithoutVisibilityNestedInput}),
});
export const StageVisibilityUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateInput>>('StageVisibilityUpdateInput').implement({
  fields: StageVisibilityUpdateInputFields,
});

export const StageVisibilityCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  roleId: t.int({"required":false}),
  stageId: t.int({"required":true}),
});
export const StageVisibilityCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyInput>>('StageVisibilityCreateManyInput').implement({
  fields: StageVisibilityCreateManyInputFields,
});

export const StageVisibilityUpdateManyMutationInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
});
export const StageVisibilityUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyMutationInput>>('StageVisibilityUpdateManyMutationInput').implement({
  fields: StageVisibilityUpdateManyMutationInputFields,
});

export const StageMetadataCreateInputFields = (t: any) => ({
  metaKey: t.string({"required":true}),
  metaValue: t.string({"required":true}),
  stage: t.field({"required":true,"type":StageCreateNestedOneWithoutMetadataInput}),
});
export const StageMetadataCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateInput>>('StageMetadataCreateInput').implement({
  fields: StageMetadataCreateInputFields,
});

export const StageMetadataUpdateInputFields = (t: any) => ({
  metaKey: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  metaValue: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  stage: t.field({"required":false,"type":StageUpdateOneRequiredWithoutMetadataNestedInput}),
});
export const StageMetadataUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateInput>>('StageMetadataUpdateInput').implement({
  fields: StageMetadataUpdateInputFields,
});

export const StageMetadataCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  metaKey: t.string({"required":true}),
  metaValue: t.string({"required":true}),
  stageId: t.int({"required":true}),
});
export const StageMetadataCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateManyInput>>('StageMetadataCreateManyInput').implement({
  fields: StageMetadataCreateManyInputFields,
});

export const StageMetadataUpdateManyMutationInputFields = (t: any) => ({
  metaKey: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  metaValue: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const StageMetadataUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateManyMutationInput>>('StageMetadataUpdateManyMutationInput').implement({
  fields: StageMetadataUpdateManyMutationInputFields,
});

export const CandidateCreateInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateInput>>('CandidateCreateInput').implement({
  fields: CandidateCreateInputFields,
});

export const CandidateUpdateInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateInput>>('CandidateUpdateInput').implement({
  fields: CandidateUpdateInputFields,
});

export const CandidateCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  referrerId: t.int({"required":false}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  hiredAtId: t.int({"required":false}),
  hiredById: t.int({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const CandidateCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyInput>>('CandidateCreateManyInput').implement({
  fields: CandidateCreateManyInputFields,
});

export const CandidateUpdateManyMutationInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const CandidateUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyMutationInput>>('CandidateUpdateManyMutationInput').implement({
  fields: CandidateUpdateManyMutationInputFields,
});

export const CandidateTagCreateInputFields = (t: any) => ({
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutCandidateTagsInput}),
  tag: t.field({"required":true,"type":TagSourceCreateNestedOneWithoutCandidateTagsInput}),
});
export const CandidateTagCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateInput>>('CandidateTagCreateInput').implement({
  fields: CandidateTagCreateInputFields,
});

export const CandidateTagUpdateInputFields = (t: any) => ({
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutCandidateTagsNestedInput}),
  tag: t.field({"required":false,"type":TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInput}),
});
export const CandidateTagUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateInput>>('CandidateTagUpdateInput').implement({
  fields: CandidateTagUpdateInputFields,
});

export const CandidateTagCreateManyInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  tagId: t.int({"required":true}),
});
export const CandidateTagCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateManyInput>>('CandidateTagCreateManyInput').implement({
  fields: CandidateTagCreateManyInputFields,
});

export const CandidateTagUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const CandidateTagUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateManyMutationInput>>('CandidateTagUpdateManyMutationInput').implement({
  fields: CandidateTagUpdateManyMutationInputFields,
});

export const CandidateCustomFieldCreateInputFields = (t: any) => ({
  value: t.string({"required":false}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutCandidateCustomFieldsInput}),
  customField: t.field({"required":true,"type":CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInput}),
});
export const CandidateCustomFieldCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateInput>>('CandidateCustomFieldCreateInput').implement({
  fields: CandidateCustomFieldCreateInputFields,
});

export const CandidateCustomFieldUpdateInputFields = (t: any) => ({
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput}),
  customField: t.field({"required":false,"type":CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput}),
});
export const CandidateCustomFieldUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateInput>>('CandidateCustomFieldUpdateInput').implement({
  fields: CandidateCustomFieldUpdateInputFields,
});

export const CandidateCustomFieldCreateManyInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  customFieldId: t.int({"required":true}),
  value: t.string({"required":false}),
});
export const CandidateCustomFieldCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateManyInput>>('CandidateCustomFieldCreateManyInput').implement({
  fields: CandidateCustomFieldCreateManyInputFields,
});

export const CandidateCustomFieldUpdateManyMutationInputFields = (t: any) => ({
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
});
export const CandidateCustomFieldUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateManyMutationInput>>('CandidateCustomFieldUpdateManyMutationInput').implement({
  fields: CandidateCustomFieldUpdateManyMutationInputFields,
});

export const CustomFieldCreateInputFields = (t: any) => ({
  type: t.string({"required":false}),
  key: t.string({"required":true}),
  defaultValue: t.string({"required":false}),
  settings: t.field({"required":false,"type":Json}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCustomFieldsInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCustomFieldInput}),
});
export const CustomFieldCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateInput>>('CustomFieldCreateInput').implement({
  fields: CustomFieldCreateInputFields,
});

export const CustomFieldUpdateInputFields = (t: any) => ({
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  defaultValue: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCustomFieldsNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInput}),
});
export const CustomFieldUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateInput>>('CustomFieldUpdateInput').implement({
  fields: CustomFieldUpdateInputFields,
});

export const CustomFieldCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.string({"required":false}),
  key: t.string({"required":true}),
  defaultValue: t.string({"required":false}),
  settings: t.field({"required":false,"type":Json}),
  companyId: t.string({"required":true}),
});
export const CustomFieldCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateManyInput>>('CustomFieldCreateManyInput').implement({
  fields: CustomFieldCreateManyInputFields,
});

export const CustomFieldUpdateManyMutationInputFields = (t: any) => ({
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  defaultValue: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
});
export const CustomFieldUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateManyMutationInput>>('CustomFieldUpdateManyMutationInput').implement({
  fields: CustomFieldUpdateManyMutationInputFields,
});

export const EvaluationCreateInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateInput>>('EvaluationCreateInput').implement({
  fields: EvaluationCreateInputFields,
});

export const EvaluationUpdateInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateInput>>('EvaluationUpdateInput').implement({
  fields: EvaluationUpdateInputFields,
});

export const EvaluationCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  templateId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  eventId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyInput>>('EvaluationCreateManyInput').implement({
  fields: EvaluationCreateManyInputFields,
});

export const EvaluationUpdateManyMutationInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const EvaluationUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyMutationInput>>('EvaluationUpdateManyMutationInput').implement({
  fields: EvaluationUpdateManyMutationInputFields,
});

export const EvaluationQuestionCreateInputFields = (t: any) => ({
  inputType: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  question: t.string({"required":false}),
  answer: t.string({"required":true}),
  evaluation: t.field({"required":true,"type":EvaluationCreateNestedOneWithoutAnswersInput}),
});
export const EvaluationQuestionCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateInput>>('EvaluationQuestionCreateInput').implement({
  fields: EvaluationQuestionCreateInputFields,
});

export const EvaluationQuestionUpdateInputFields = (t: any) => ({
  inputType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  question: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  answer: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  evaluation: t.field({"required":false,"type":EvaluationUpdateOneRequiredWithoutAnswersNestedInput}),
});
export const EvaluationQuestionUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateInput>>('EvaluationQuestionUpdateInput').implement({
  fields: EvaluationQuestionUpdateInputFields,
});

export const EvaluationQuestionCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  evaluationId: t.int({"required":true}),
  inputType: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  question: t.string({"required":false}),
  answer: t.string({"required":true}),
});
export const EvaluationQuestionCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateManyInput>>('EvaluationQuestionCreateManyInput').implement({
  fields: EvaluationQuestionCreateManyInputFields,
});

export const EvaluationQuestionUpdateManyMutationInputFields = (t: any) => ({
  inputType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  question: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  answer: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const EvaluationQuestionUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateManyMutationInput>>('EvaluationQuestionUpdateManyMutationInput').implement({
  fields: EvaluationQuestionUpdateManyMutationInputFields,
});

export const SharedCandidateLinkCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.string({"required":true}),
  expiration: t.field({"required":true,"type":DateTime}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutSharedCandidateLinkInput}),
});
export const SharedCandidateLinkCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateInput>>('SharedCandidateLinkCreateInput').implement({
  fields: SharedCandidateLinkCreateInputFields,
});

export const SharedCandidateLinkUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expiration: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInput}),
});
export const SharedCandidateLinkUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateInput>>('SharedCandidateLinkUpdateInput').implement({
  fields: SharedCandidateLinkUpdateInputFields,
});

export const SharedCandidateLinkCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.string({"required":true}),
  expiration: t.field({"required":true,"type":DateTime}),
  candidateId: t.int({"required":true}),
});
export const SharedCandidateLinkCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateManyInput>>('SharedCandidateLinkCreateManyInput').implement({
  fields: SharedCandidateLinkCreateManyInputFields,
});

export const SharedCandidateLinkUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expiration: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const SharedCandidateLinkUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateManyMutationInput>>('SharedCandidateLinkUpdateManyMutationInput').implement({
  fields: SharedCandidateLinkUpdateManyMutationInputFields,
});

export const TaskCreateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTasksInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTaskInput}),
  Candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutTasksInput}),
});
export const TaskCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateInput>>('TaskCreateInput').implement({
  fields: TaskCreateInputFields,
});

export const TaskUpdateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dueDate: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTasksNestedInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTaskNestedInput}),
  Candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutTasksNestedInput}),
});
export const TaskUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateInput>>('TaskUpdateInput').implement({
  fields: TaskUpdateInputFields,
});

export const TaskCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  candidateId: t.int({"required":false}),
});
export const TaskCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateManyInput>>('TaskCreateManyInput').implement({
  fields: TaskCreateManyInputFields,
});

export const TaskUpdateManyMutationInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dueDate: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const TaskUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateManyMutationInput>>('TaskUpdateManyMutationInput').implement({
  fields: TaskUpdateManyMutationInputFields,
});

export const TaskMemberCreateInputFields = (t: any) => ({
  task: t.field({"required":true,"type":TaskCreateNestedOneWithoutTaskMembersInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutTasksInput}),
});
export const TaskMemberCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateInput>>('TaskMemberCreateInput').implement({
  fields: TaskMemberCreateInputFields,
});

export const TaskMemberUpdateInputFields = (t: any) => ({
  task: t.field({"required":false,"type":TaskUpdateOneRequiredWithoutTaskMembersNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutTasksNestedInput}),
});
export const TaskMemberUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateInput>>('TaskMemberUpdateInput').implement({
  fields: TaskMemberUpdateInputFields,
});

export const TaskMemberCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  taskId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
});
export const TaskMemberCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateManyInput>>('TaskMemberCreateManyInput').implement({
  fields: TaskMemberCreateManyInputFields,
});

export const TaskMemberUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const TaskMemberUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateManyMutationInput>>('TaskMemberUpdateManyMutationInput').implement({
  fields: TaskMemberUpdateManyMutationInputFields,
});

export const FollowCreateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutFollowsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutFollowsInput}),
  talentPool: t.field({"required":false,"type":TalentPoolCreateNestedOneWithoutFollowsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutFollowsInput}),
});
export const FollowCreateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateInput>>('FollowCreateInput').implement({
  fields: FollowCreateInputFields,
});

export const FollowUpdateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutFollowsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutFollowsNestedInput}),
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneWithoutFollowsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutFollowsNestedInput}),
});
export const FollowUpdateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateInput>>('FollowUpdateInput').implement({
  fields: FollowUpdateInputFields,
});

export const FollowCreateManyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  talentPoolId: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const FollowCreateManyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyInput>>('FollowCreateManyInput').implement({
  fields: FollowCreateManyInputFields,
});

export const FollowUpdateManyMutationInputFields = (t: any) => ({
  _: t.field({ type: NEVER }),
});
export const FollowUpdateManyMutationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyMutationInput>>('FollowUpdateManyMutationInput').implement({
  fields: FollowUpdateManyMutationInputFields,
});

export const StringFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  mode: t.field({"required":false,"type":QueryMode}),
  not: t.field({"required":false,"type":NestedStringFilter}),
});
export const StringFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringFilter>>('StringFilter').implement({
  fields: StringFilterFields,
});

export const StringNullableFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  mode: t.field({"required":false,"type":QueryMode}),
  not: t.field({"required":false,"type":NestedStringNullableFilter}),
});
export const StringNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringNullableFilter>>('StringNullableFilter').implement({
  fields: StringNullableFilterFields,
});

export const DateTimeNullableFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
});
export const DateTimeNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DateTimeNullableFilter>>('DateTimeNullableFilter').implement({
  fields: DateTimeNullableFilterFields,
});

export const BoolFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolFilter}),
});
export const BoolFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.BoolFilter>>('BoolFilter').implement({
  fields: BoolFilterFields,
});

export const IntNullableFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntNullableFilter}),
});
export const IntNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.IntNullableFilter>>('IntNullableFilter').implement({
  fields: IntNullableFilterFields,
});

export const StringNullableListFilterFields = (t: any) => ({
  equals: t.stringList({"required":false}),
  has: t.string({"required":false}),
  hasEvery: t.stringList({"required":false}),
  hasSome: t.stringList({"required":false}),
  isEmpty: t.boolean({"required":false}),
});
export const StringNullableListFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringNullableListFilter>>('StringNullableListFilter').implement({
  fields: StringNullableListFilterFields,
});

export const JsonNullableFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
});
export const JsonNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.JsonNullableFilter>>('JsonNullableFilter').implement({
  fields: JsonNullableFilterFields,
});

export const DateTimeFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeFilter}),
});
export const DateTimeFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DateTimeFilter>>('DateTimeFilter').implement({
  fields: DateTimeFilterFields,
});

export const EnumUserRolesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":UserRoles}),
  in: t.field({"required":false,"type":[UserRoles]}),
  notIn: t.field({"required":false,"type":[UserRoles]}),
  not: t.field({"required":false,"type":UserRoles}),
});
export const EnumUserRolesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumUserRolesFilter>>('EnumUserRolesFilter').implement({
  fields: EnumUserRolesFilterFields,
});

export const AttachmentNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":AttachmentWhereInput}),
  isNot: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentNullableRelationFilter>>('AttachmentNullableRelationFilter').implement({
  fields: AttachmentNullableRelationFilterFields,
});

export const AccountListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":AccountWhereInput}),
  some: t.field({"required":false,"type":AccountWhereInput}),
  none: t.field({"required":false,"type":AccountWhereInput}),
});
export const AccountListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountListRelationFilter>>('AccountListRelationFilter').implement({
  fields: AccountListRelationFilterFields,
});

export const SessionListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":SessionWhereInput}),
  some: t.field({"required":false,"type":SessionWhereInput}),
  none: t.field({"required":false,"type":SessionWhereInput}),
});
export const SessionListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionListRelationFilter>>('SessionListRelationFilter').implement({
  fields: SessionListRelationFilterFields,
});

export const HiringRoleListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":HiringRoleWhereInput}),
  some: t.field({"required":false,"type":HiringRoleWhereInput}),
  none: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleListRelationFilter>>('HiringRoleListRelationFilter').implement({
  fields: HiringRoleListRelationFilterFields,
});

export const CompanyListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CompanyWhereInput}),
  some: t.field({"required":false,"type":CompanyWhereInput}),
  none: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyListRelationFilter>>('CompanyListRelationFilter').implement({
  fields: CompanyListRelationFilterFields,
});

export const AccountOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const AccountOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountOrderByRelationAggregateInput>>('AccountOrderByRelationAggregateInput').implement({
  fields: AccountOrderByRelationAggregateInputFields,
});

export const SessionOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const SessionOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionOrderByRelationAggregateInput>>('SessionOrderByRelationAggregateInput').implement({
  fields: SessionOrderByRelationAggregateInputFields,
});

export const HiringRoleOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleOrderByRelationAggregateInput>>('HiringRoleOrderByRelationAggregateInput').implement({
  fields: HiringRoleOrderByRelationAggregateInputFields,
});

export const CompanyOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CompanyOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyOrderByRelationAggregateInput>>('CompanyOrderByRelationAggregateInput').implement({
  fields: CompanyOrderByRelationAggregateInputFields,
});

export const UserCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  emailVerified: t.field({"required":false,"type":SortOrder}),
  image: t.field({"required":false,"type":SortOrder}),
  password: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  preferredLanguage: t.field({"required":false,"type":SortOrder}),
  timeformat24: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  weekStartDate: t.field({"required":false,"type":SortOrder}),
  photoId: t.field({"required":false,"type":SortOrder}),
  featureDiscovery: t.field({"required":false,"type":SortOrder}),
  emailProviders: t.field({"required":false,"type":SortOrder}),
  theme: t.field({"required":false,"type":SortOrder}),
  notifications: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  userRole: t.field({"required":false,"type":SortOrder}),
});
export const UserCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCountOrderByAggregateInput>>('UserCountOrderByAggregateInput').implement({
  fields: UserCountOrderByAggregateInputFields,
});

export const UserAvgOrderByAggregateInputFields = (t: any) => ({
  photoId: t.field({"required":false,"type":SortOrder}),
});
export const UserAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserAvgOrderByAggregateInput>>('UserAvgOrderByAggregateInput').implement({
  fields: UserAvgOrderByAggregateInputFields,
});

export const UserMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  emailVerified: t.field({"required":false,"type":SortOrder}),
  image: t.field({"required":false,"type":SortOrder}),
  password: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  preferredLanguage: t.field({"required":false,"type":SortOrder}),
  timeformat24: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  weekStartDate: t.field({"required":false,"type":SortOrder}),
  photoId: t.field({"required":false,"type":SortOrder}),
  theme: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  userRole: t.field({"required":false,"type":SortOrder}),
});
export const UserMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserMaxOrderByAggregateInput>>('UserMaxOrderByAggregateInput').implement({
  fields: UserMaxOrderByAggregateInputFields,
});

export const UserMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  emailVerified: t.field({"required":false,"type":SortOrder}),
  image: t.field({"required":false,"type":SortOrder}),
  password: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  preferredLanguage: t.field({"required":false,"type":SortOrder}),
  timeformat24: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  weekStartDate: t.field({"required":false,"type":SortOrder}),
  photoId: t.field({"required":false,"type":SortOrder}),
  theme: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  userRole: t.field({"required":false,"type":SortOrder}),
});
export const UserMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserMinOrderByAggregateInput>>('UserMinOrderByAggregateInput').implement({
  fields: UserMinOrderByAggregateInputFields,
});

export const UserSumOrderByAggregateInputFields = (t: any) => ({
  photoId: t.field({"required":false,"type":SortOrder}),
});
export const UserSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserSumOrderByAggregateInput>>('UserSumOrderByAggregateInput').implement({
  fields: UserSumOrderByAggregateInputFields,
});

export const StringWithAggregatesFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  mode: t.field({"required":false,"type":QueryMode}),
  not: t.field({"required":false,"type":NestedStringWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedStringFilter}),
  _max: t.field({"required":false,"type":NestedStringFilter}),
});
export const StringWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringWithAggregatesFilter>>('StringWithAggregatesFilter').implement({
  fields: StringWithAggregatesFilterFields,
});

export const StringNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  mode: t.field({"required":false,"type":QueryMode}),
  not: t.field({"required":false,"type":NestedStringNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedStringNullableFilter}),
  _max: t.field({"required":false,"type":NestedStringNullableFilter}),
});
export const StringNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringNullableWithAggregatesFilter>>('StringNullableWithAggregatesFilter').implement({
  fields: StringNullableWithAggregatesFilterFields,
});

export const DateTimeNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
  _max: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
});
export const DateTimeNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DateTimeNullableWithAggregatesFilter>>('DateTimeNullableWithAggregatesFilter').implement({
  fields: DateTimeNullableWithAggregatesFilterFields,
});

export const BoolWithAggregatesFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedBoolFilter}),
  _max: t.field({"required":false,"type":NestedBoolFilter}),
});
export const BoolWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.BoolWithAggregatesFilter>>('BoolWithAggregatesFilter').implement({
  fields: BoolWithAggregatesFilterFields,
});

export const IntNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _avg: t.field({"required":false,"type":NestedFloatNullableFilter}),
  _sum: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedIntNullableFilter}),
  _max: t.field({"required":false,"type":NestedIntNullableFilter}),
});
export const IntNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.IntNullableWithAggregatesFilter>>('IntNullableWithAggregatesFilter').implement({
  fields: IntNullableWithAggregatesFilterFields,
});

export const JsonNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedJsonNullableFilter}),
  _max: t.field({"required":false,"type":NestedJsonNullableFilter}),
});
export const JsonNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.JsonNullableWithAggregatesFilter>>('JsonNullableWithAggregatesFilter').implement({
  fields: JsonNullableWithAggregatesFilterFields,
});

export const DateTimeWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedDateTimeFilter}),
  _max: t.field({"required":false,"type":NestedDateTimeFilter}),
});
export const DateTimeWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DateTimeWithAggregatesFilter>>('DateTimeWithAggregatesFilter').implement({
  fields: DateTimeWithAggregatesFilterFields,
});

export const EnumUserRolesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":UserRoles}),
  in: t.field({"required":false,"type":[UserRoles]}),
  notIn: t.field({"required":false,"type":[UserRoles]}),
  not: t.field({"required":false,"type":UserRoles}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumUserRolesFilter}),
  _max: t.field({"required":false,"type":NestedEnumUserRolesFilter}),
});
export const EnumUserRolesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumUserRolesWithAggregatesFilter>>('EnumUserRolesWithAggregatesFilter').implement({
  fields: EnumUserRolesWithAggregatesFilterFields,
});

export const UserRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":UserWhereInput}),
  isNot: t.field({"required":false,"type":UserWhereInput}),
});
export const UserRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserRelationFilter>>('UserRelationFilter').implement({
  fields: UserRelationFilterFields,
});

export const AccountProviderProviderAccountIdCompoundUniqueInputFields = (t: any) => ({
  provider: t.string({"required":true}),
  providerAccountId: t.string({"required":true}),
});
export const AccountProviderProviderAccountIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountProviderProviderAccountIdCompoundUniqueInput>>('AccountProviderProviderAccountIdCompoundUniqueInput').implement({
  fields: AccountProviderProviderAccountIdCompoundUniqueInputFields,
});

export const AccountCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  provider: t.field({"required":false,"type":SortOrder}),
  providerAccountId: t.field({"required":false,"type":SortOrder}),
  refresh_token: t.field({"required":false,"type":SortOrder}),
  access_token: t.field({"required":false,"type":SortOrder}),
  expires_at: t.field({"required":false,"type":SortOrder}),
  token_type: t.field({"required":false,"type":SortOrder}),
  scope: t.field({"required":false,"type":SortOrder}),
  id_token: t.field({"required":false,"type":SortOrder}),
  session_state: t.field({"required":false,"type":SortOrder}),
});
export const AccountCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCountOrderByAggregateInput>>('AccountCountOrderByAggregateInput').implement({
  fields: AccountCountOrderByAggregateInputFields,
});

export const AccountAvgOrderByAggregateInputFields = (t: any) => ({
  expires_at: t.field({"required":false,"type":SortOrder}),
});
export const AccountAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountAvgOrderByAggregateInput>>('AccountAvgOrderByAggregateInput').implement({
  fields: AccountAvgOrderByAggregateInputFields,
});

export const AccountMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  provider: t.field({"required":false,"type":SortOrder}),
  providerAccountId: t.field({"required":false,"type":SortOrder}),
  refresh_token: t.field({"required":false,"type":SortOrder}),
  access_token: t.field({"required":false,"type":SortOrder}),
  expires_at: t.field({"required":false,"type":SortOrder}),
  token_type: t.field({"required":false,"type":SortOrder}),
  scope: t.field({"required":false,"type":SortOrder}),
  id_token: t.field({"required":false,"type":SortOrder}),
  session_state: t.field({"required":false,"type":SortOrder}),
});
export const AccountMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountMaxOrderByAggregateInput>>('AccountMaxOrderByAggregateInput').implement({
  fields: AccountMaxOrderByAggregateInputFields,
});

export const AccountMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  provider: t.field({"required":false,"type":SortOrder}),
  providerAccountId: t.field({"required":false,"type":SortOrder}),
  refresh_token: t.field({"required":false,"type":SortOrder}),
  access_token: t.field({"required":false,"type":SortOrder}),
  expires_at: t.field({"required":false,"type":SortOrder}),
  token_type: t.field({"required":false,"type":SortOrder}),
  scope: t.field({"required":false,"type":SortOrder}),
  id_token: t.field({"required":false,"type":SortOrder}),
  session_state: t.field({"required":false,"type":SortOrder}),
});
export const AccountMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountMinOrderByAggregateInput>>('AccountMinOrderByAggregateInput').implement({
  fields: AccountMinOrderByAggregateInputFields,
});

export const AccountSumOrderByAggregateInputFields = (t: any) => ({
  expires_at: t.field({"required":false,"type":SortOrder}),
});
export const AccountSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountSumOrderByAggregateInput>>('AccountSumOrderByAggregateInput').implement({
  fields: AccountSumOrderByAggregateInputFields,
});

export const SessionCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  sessionToken: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const SessionCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCountOrderByAggregateInput>>('SessionCountOrderByAggregateInput').implement({
  fields: SessionCountOrderByAggregateInputFields,
});

export const SessionMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  sessionToken: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const SessionMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionMaxOrderByAggregateInput>>('SessionMaxOrderByAggregateInput').implement({
  fields: SessionMaxOrderByAggregateInputFields,
});

export const SessionMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  sessionToken: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const SessionMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionMinOrderByAggregateInput>>('SessionMinOrderByAggregateInput').implement({
  fields: SessionMinOrderByAggregateInputFields,
});

export const VerificationTokenIdentifierTokenCompoundUniqueInputFields = (t: any) => ({
  identifier: t.string({"required":true}),
  token: t.string({"required":true}),
});
export const VerificationTokenIdentifierTokenCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenIdentifierTokenCompoundUniqueInput>>('VerificationTokenIdentifierTokenCompoundUniqueInput').implement({
  fields: VerificationTokenIdentifierTokenCompoundUniqueInputFields,
});

export const VerificationTokenCountOrderByAggregateInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":SortOrder}),
  token: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const VerificationTokenCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenCountOrderByAggregateInput>>('VerificationTokenCountOrderByAggregateInput').implement({
  fields: VerificationTokenCountOrderByAggregateInputFields,
});

export const VerificationTokenMaxOrderByAggregateInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":SortOrder}),
  token: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const VerificationTokenMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenMaxOrderByAggregateInput>>('VerificationTokenMaxOrderByAggregateInput').implement({
  fields: VerificationTokenMaxOrderByAggregateInputFields,
});

export const VerificationTokenMinOrderByAggregateInputFields = (t: any) => ({
  identifier: t.field({"required":false,"type":SortOrder}),
  token: t.field({"required":false,"type":SortOrder}),
  expires: t.field({"required":false,"type":SortOrder}),
});
export const VerificationTokenMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.VerificationTokenMinOrderByAggregateInput>>('VerificationTokenMinOrderByAggregateInput').implement({
  fields: VerificationTokenMinOrderByAggregateInputFields,
});

export const IntFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntFilter}),
});
export const IntFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.IntFilter>>('IntFilter').implement({
  fields: IntFilterFields,
});

export const UserNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":UserWhereInput}),
  isNot: t.field({"required":false,"type":UserWhereInput}),
});
export const UserNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserNullableRelationFilter>>('UserNullableRelationFilter').implement({
  fields: UserNullableRelationFilterFields,
});

export const CandidateNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":CandidateWhereInput}),
  isNot: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateNullableRelationFilter>>('CandidateNullableRelationFilter').implement({
  fields: CandidateNullableRelationFilterFields,
});

export const CompanyNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":CompanyWhereInput}),
  isNot: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyNullableRelationFilter>>('CompanyNullableRelationFilter').implement({
  fields: CompanyNullableRelationFilterFields,
});

export const HiringRoleNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":HiringRoleWhereInput}),
  isNot: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleNullableRelationFilter>>('HiringRoleNullableRelationFilter').implement({
  fields: HiringRoleNullableRelationFilterFields,
});

export const OfferFileListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":OfferFileWhereInput}),
  some: t.field({"required":false,"type":OfferFileWhereInput}),
  none: t.field({"required":false,"type":OfferFileWhereInput}),
});
export const OfferFileListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileListRelationFilter>>('OfferFileListRelationFilter').implement({
  fields: OfferFileListRelationFilterFields,
});

export const TalentPoolFileListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TalentPoolFileWhereInput}),
  some: t.field({"required":false,"type":TalentPoolFileWhereInput}),
  none: t.field({"required":false,"type":TalentPoolFileWhereInput}),
});
export const TalentPoolFileListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileListRelationFilter>>('TalentPoolFileListRelationFilter').implement({
  fields: TalentPoolFileListRelationFilterFields,
});

export const CompanyRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":CompanyWhereInput}),
  isNot: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyRelationFilter>>('CompanyRelationFilter').implement({
  fields: CompanyRelationFilterFields,
});

export const OfferFileOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileOrderByRelationAggregateInput>>('OfferFileOrderByRelationAggregateInput').implement({
  fields: OfferFileOrderByRelationAggregateInputFields,
});

export const TalentPoolFileOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileOrderByRelationAggregateInput>>('TalentPoolFileOrderByRelationAggregateInput').implement({
  fields: TalentPoolFileOrderByRelationAggregateInputFields,
});

export const AttachmentCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  contentType: t.field({"required":false,"type":SortOrder}),
  filename: t.field({"required":false,"type":SortOrder}),
  path: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCountOrderByAggregateInput>>('AttachmentCountOrderByAggregateInput').implement({
  fields: AttachmentCountOrderByAggregateInputFields,
});

export const AttachmentAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentAvgOrderByAggregateInput>>('AttachmentAvgOrderByAggregateInput').implement({
  fields: AttachmentAvgOrderByAggregateInputFields,
});

export const AttachmentMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  contentType: t.field({"required":false,"type":SortOrder}),
  filename: t.field({"required":false,"type":SortOrder}),
  path: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentMaxOrderByAggregateInput>>('AttachmentMaxOrderByAggregateInput').implement({
  fields: AttachmentMaxOrderByAggregateInputFields,
});

export const AttachmentMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  contentType: t.field({"required":false,"type":SortOrder}),
  filename: t.field({"required":false,"type":SortOrder}),
  path: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentMinOrderByAggregateInput>>('AttachmentMinOrderByAggregateInput').implement({
  fields: AttachmentMinOrderByAggregateInputFields,
});

export const AttachmentSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  size: t.field({"required":false,"type":SortOrder}),
  uploaderId: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentSumOrderByAggregateInput>>('AttachmentSumOrderByAggregateInput').implement({
  fields: AttachmentSumOrderByAggregateInputFields,
});

export const IntWithAggregatesFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _avg: t.field({"required":false,"type":NestedFloatFilter}),
  _sum: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedIntFilter}),
  _max: t.field({"required":false,"type":NestedIntFilter}),
});
export const IntWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.IntWithAggregatesFilter>>('IntWithAggregatesFilter').implement({
  fields: IntWithAggregatesFilterFields,
});

export const RoleRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":RoleWhereInput}),
  isNot: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleRelationFilter>>('RoleRelationFilter').implement({
  fields: RoleRelationFilterFields,
});

export const AttachmentListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":AttachmentWhereInput}),
  some: t.field({"required":false,"type":AttachmentWhereInput}),
  none: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentListRelationFilter>>('AttachmentListRelationFilter').implement({
  fields: AttachmentListRelationFilterFields,
});

export const AuditLogListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":AuditLogWhereInput}),
  some: t.field({"required":false,"type":AuditLogWhereInput}),
  none: t.field({"required":false,"type":AuditLogWhereInput}),
});
export const AuditLogListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogListRelationFilter>>('AuditLogListRelationFilter').implement({
  fields: AuditLogListRelationFilterFields,
});

export const EventScheduleInterviewerListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EventScheduleInterviewerWhereInput}),
  some: t.field({"required":false,"type":EventScheduleInterviewerWhereInput}),
  none: t.field({"required":false,"type":EventScheduleInterviewerWhereInput}),
});
export const EventScheduleInterviewerListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerListRelationFilter>>('EventScheduleInterviewerListRelationFilter').implement({
  fields: EventScheduleInterviewerListRelationFilterFields,
});

export const EventListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EventWhereInput}),
  some: t.field({"required":false,"type":EventWhereInput}),
  none: t.field({"required":false,"type":EventWhereInput}),
});
export const EventListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventListRelationFilter>>('EventListRelationFilter').implement({
  fields: EventListRelationFilterFields,
});

export const OfferNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":OfferWhereInput}),
  isNot: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferNullableRelationFilter>>('OfferNullableRelationFilter').implement({
  fields: OfferNullableRelationFilterFields,
});

export const MembershipListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":MembershipWhereInput}),
  some: t.field({"required":false,"type":MembershipWhereInput}),
  none: t.field({"required":false,"type":MembershipWhereInput}),
});
export const MembershipListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipListRelationFilter>>('MembershipListRelationFilter').implement({
  fields: MembershipListRelationFilterFields,
});

export const StageVisibilityListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":StageVisibilityWhereInput}),
  some: t.field({"required":false,"type":StageVisibilityWhereInput}),
  none: t.field({"required":false,"type":StageVisibilityWhereInput}),
});
export const StageVisibilityListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityListRelationFilter>>('StageVisibilityListRelationFilter').implement({
  fields: StageVisibilityListRelationFilterFields,
});

export const CandidateListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CandidateWhereInput}),
  some: t.field({"required":false,"type":CandidateWhereInput}),
  none: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateListRelationFilter>>('CandidateListRelationFilter').implement({
  fields: CandidateListRelationFilterFields,
});

export const EvaluationListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EvaluationWhereInput}),
  some: t.field({"required":false,"type":EvaluationWhereInput}),
  none: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationListRelationFilter>>('EvaluationListRelationFilter').implement({
  fields: EvaluationListRelationFilterFields,
});

export const TaskMemberListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TaskMemberWhereInput}),
  some: t.field({"required":false,"type":TaskMemberWhereInput}),
  none: t.field({"required":false,"type":TaskMemberWhereInput}),
});
export const TaskMemberListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberListRelationFilter>>('TaskMemberListRelationFilter').implement({
  fields: TaskMemberListRelationFilterFields,
});

export const FollowListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":FollowWhereInput}),
  some: t.field({"required":false,"type":FollowWhereInput}),
  none: t.field({"required":false,"type":FollowWhereInput}),
});
export const FollowListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowListRelationFilter>>('FollowListRelationFilter').implement({
  fields: FollowListRelationFilterFields,
});

export const EventInterviewerListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EventInterviewerWhereInput}),
  some: t.field({"required":false,"type":EventInterviewerWhereInput}),
  none: t.field({"required":false,"type":EventInterviewerWhereInput}),
});
export const EventInterviewerListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerListRelationFilter>>('EventInterviewerListRelationFilter').implement({
  fields: EventInterviewerListRelationFilterFields,
});

export const AttachmentOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const AttachmentOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentOrderByRelationAggregateInput>>('AttachmentOrderByRelationAggregateInput').implement({
  fields: AttachmentOrderByRelationAggregateInputFields,
});

export const AuditLogOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogOrderByRelationAggregateInput>>('AuditLogOrderByRelationAggregateInput').implement({
  fields: AuditLogOrderByRelationAggregateInputFields,
});

export const EventScheduleInterviewerOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerOrderByRelationAggregateInput>>('EventScheduleInterviewerOrderByRelationAggregateInput').implement({
  fields: EventScheduleInterviewerOrderByRelationAggregateInputFields,
});

export const EventOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EventOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventOrderByRelationAggregateInput>>('EventOrderByRelationAggregateInput').implement({
  fields: EventOrderByRelationAggregateInputFields,
});

export const MembershipOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const MembershipOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipOrderByRelationAggregateInput>>('MembershipOrderByRelationAggregateInput').implement({
  fields: MembershipOrderByRelationAggregateInputFields,
});

export const StageVisibilityOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilityOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityOrderByRelationAggregateInput>>('StageVisibilityOrderByRelationAggregateInput').implement({
  fields: StageVisibilityOrderByRelationAggregateInputFields,
});

export const CandidateOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CandidateOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateOrderByRelationAggregateInput>>('CandidateOrderByRelationAggregateInput').implement({
  fields: CandidateOrderByRelationAggregateInputFields,
});

export const EvaluationOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationOrderByRelationAggregateInput>>('EvaluationOrderByRelationAggregateInput').implement({
  fields: EvaluationOrderByRelationAggregateInputFields,
});

export const TaskMemberOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberOrderByRelationAggregateInput>>('TaskMemberOrderByRelationAggregateInput').implement({
  fields: TaskMemberOrderByRelationAggregateInputFields,
});

export const FollowOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const FollowOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowOrderByRelationAggregateInput>>('FollowOrderByRelationAggregateInput').implement({
  fields: FollowOrderByRelationAggregateInputFields,
});

export const EventInterviewerOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerOrderByRelationAggregateInput>>('EventInterviewerOrderByRelationAggregateInput').implement({
  fields: EventInterviewerOrderByRelationAggregateInputFields,
});

export const HiringRoleUserIdCompanyIdCompoundUniqueInputFields = (t: any) => ({
  userId: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const HiringRoleUserIdCompanyIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUserIdCompanyIdCompoundUniqueInput>>('HiringRoleUserIdCompanyIdCompoundUniqueInput').implement({
  fields: HiringRoleUserIdCompanyIdCompoundUniqueInputFields,
});

export const HiringRoleCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  extraAbilities: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCountOrderByAggregateInput>>('HiringRoleCountOrderByAggregateInput').implement({
  fields: HiringRoleCountOrderByAggregateInputFields,
});

export const HiringRoleAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleAvgOrderByAggregateInput>>('HiringRoleAvgOrderByAggregateInput').implement({
  fields: HiringRoleAvgOrderByAggregateInputFields,
});

export const HiringRoleMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleMaxOrderByAggregateInput>>('HiringRoleMaxOrderByAggregateInput').implement({
  fields: HiringRoleMaxOrderByAggregateInputFields,
});

export const HiringRoleMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleMinOrderByAggregateInput>>('HiringRoleMinOrderByAggregateInput').implement({
  fields: HiringRoleMinOrderByAggregateInputFields,
});

export const HiringRoleSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
});
export const HiringRoleSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleSumOrderByAggregateInput>>('HiringRoleSumOrderByAggregateInput').implement({
  fields: HiringRoleSumOrderByAggregateInputFields,
});

export const RoleCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  abilities: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const RoleCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCountOrderByAggregateInput>>('RoleCountOrderByAggregateInput').implement({
  fields: RoleCountOrderByAggregateInputFields,
});

export const RoleAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const RoleAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleAvgOrderByAggregateInput>>('RoleAvgOrderByAggregateInput').implement({
  fields: RoleAvgOrderByAggregateInputFields,
});

export const RoleMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const RoleMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleMaxOrderByAggregateInput>>('RoleMaxOrderByAggregateInput').implement({
  fields: RoleMaxOrderByAggregateInputFields,
});

export const RoleMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const RoleMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleMinOrderByAggregateInput>>('RoleMinOrderByAggregateInput').implement({
  fields: RoleMinOrderByAggregateInputFields,
});

export const RoleSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const RoleSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleSumOrderByAggregateInput>>('RoleSumOrderByAggregateInput').implement({
  fields: RoleSumOrderByAggregateInputFields,
});

export const BoolNullableFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolNullableFilter}),
});
export const BoolNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.BoolNullableFilter>>('BoolNullableFilter').implement({
  fields: BoolNullableFilterFields,
});

export const RoleListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":RoleWhereInput}),
  some: t.field({"required":false,"type":RoleWhereInput}),
  none: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleListRelationFilter>>('RoleListRelationFilter').implement({
  fields: RoleListRelationFilterFields,
});

export const SubscriptionDataNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  isNot: t.field({"required":false,"type":SubscriptionDataWhereInput}),
});
export const SubscriptionDataNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataNullableRelationFilter>>('SubscriptionDataNullableRelationFilter').implement({
  fields: SubscriptionDataNullableRelationFilterFields,
});

export const MeetingRoomListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":MeetingRoomWhereInput}),
  some: t.field({"required":false,"type":MeetingRoomWhereInput}),
  none: t.field({"required":false,"type":MeetingRoomWhereInput}),
});
export const MeetingRoomListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomListRelationFilter>>('MeetingRoomListRelationFilter').implement({
  fields: MeetingRoomListRelationFilterFields,
});

export const CompanyMetadataListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CompanyMetadataWhereInput}),
  some: t.field({"required":false,"type":CompanyMetadataWhereInput}),
  none: t.field({"required":false,"type":CompanyMetadataWhereInput}),
});
export const CompanyMetadataListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataListRelationFilter>>('CompanyMetadataListRelationFilter').implement({
  fields: CompanyMetadataListRelationFilterFields,
});

export const EventScheduleListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EventScheduleWhereInput}),
  some: t.field({"required":false,"type":EventScheduleWhereInput}),
  none: t.field({"required":false,"type":EventScheduleWhereInput}),
});
export const EventScheduleListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleListRelationFilter>>('EventScheduleListRelationFilter').implement({
  fields: EventScheduleListRelationFilterFields,
});

export const DepartmentListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":DepartmentWhereInput}),
  some: t.field({"required":false,"type":DepartmentWhereInput}),
  none: t.field({"required":false,"type":DepartmentWhereInput}),
});
export const DepartmentListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentListRelationFilter>>('DepartmentListRelationFilter').implement({
  fields: DepartmentListRelationFilterFields,
});

export const DisqualifyReasonListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  some: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  none: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
});
export const DisqualifyReasonListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonListRelationFilter>>('DisqualifyReasonListRelationFilter').implement({
  fields: DisqualifyReasonListRelationFilterFields,
});

export const TagSourceListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TagSourceWhereInput}),
  some: t.field({"required":false,"type":TagSourceWhereInput}),
  none: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceListRelationFilter>>('TagSourceListRelationFilter').implement({
  fields: TagSourceListRelationFilterFields,
});

export const OfferListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":OfferWhereInput}),
  some: t.field({"required":false,"type":OfferWhereInput}),
  none: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferListRelationFilter>>('OfferListRelationFilter').implement({
  fields: OfferListRelationFilterFields,
});

export const TemplateListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TemplateWhereInput}),
  some: t.field({"required":false,"type":TemplateWhereInput}),
  none: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateListRelationFilter>>('TemplateListRelationFilter').implement({
  fields: TemplateListRelationFilterFields,
});

export const TaskListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TaskWhereInput}),
  some: t.field({"required":false,"type":TaskWhereInput}),
  none: t.field({"required":false,"type":TaskWhereInput}),
});
export const TaskListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskListRelationFilter>>('TaskListRelationFilter').implement({
  fields: TaskListRelationFilterFields,
});

export const TalentPoolListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TalentPoolWhereInput}),
  some: t.field({"required":false,"type":TalentPoolWhereInput}),
  none: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolListRelationFilter>>('TalentPoolListRelationFilter').implement({
  fields: TalentPoolListRelationFilterFields,
});

export const CustomFieldListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CustomFieldWhereInput}),
  some: t.field({"required":false,"type":CustomFieldWhereInput}),
  none: t.field({"required":false,"type":CustomFieldWhereInput}),
});
export const CustomFieldListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldListRelationFilter>>('CustomFieldListRelationFilter').implement({
  fields: CustomFieldListRelationFilterFields,
});

export const RoleOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const RoleOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleOrderByRelationAggregateInput>>('RoleOrderByRelationAggregateInput').implement({
  fields: RoleOrderByRelationAggregateInputFields,
});

export const MeetingRoomOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomOrderByRelationAggregateInput>>('MeetingRoomOrderByRelationAggregateInput').implement({
  fields: MeetingRoomOrderByRelationAggregateInputFields,
});

export const CompanyMetadataOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataOrderByRelationAggregateInput>>('CompanyMetadataOrderByRelationAggregateInput').implement({
  fields: CompanyMetadataOrderByRelationAggregateInputFields,
});

export const EventScheduleOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleOrderByRelationAggregateInput>>('EventScheduleOrderByRelationAggregateInput').implement({
  fields: EventScheduleOrderByRelationAggregateInputFields,
});

export const DepartmentOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentOrderByRelationAggregateInput>>('DepartmentOrderByRelationAggregateInput').implement({
  fields: DepartmentOrderByRelationAggregateInputFields,
});

export const DisqualifyReasonOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonOrderByRelationAggregateInput>>('DisqualifyReasonOrderByRelationAggregateInput').implement({
  fields: DisqualifyReasonOrderByRelationAggregateInputFields,
});

export const TagSourceOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceOrderByRelationAggregateInput>>('TagSourceOrderByRelationAggregateInput').implement({
  fields: TagSourceOrderByRelationAggregateInputFields,
});

export const OfferOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const OfferOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferOrderByRelationAggregateInput>>('OfferOrderByRelationAggregateInput').implement({
  fields: OfferOrderByRelationAggregateInputFields,
});

export const TemplateOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TemplateOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateOrderByRelationAggregateInput>>('TemplateOrderByRelationAggregateInput').implement({
  fields: TemplateOrderByRelationAggregateInputFields,
});

export const TaskOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TaskOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskOrderByRelationAggregateInput>>('TaskOrderByRelationAggregateInput').implement({
  fields: TaskOrderByRelationAggregateInputFields,
});

export const TalentPoolOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolOrderByRelationAggregateInput>>('TalentPoolOrderByRelationAggregateInput').implement({
  fields: TalentPoolOrderByRelationAggregateInputFields,
});

export const CustomFieldOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldOrderByRelationAggregateInput>>('CustomFieldOrderByRelationAggregateInput').implement({
  fields: CustomFieldOrderByRelationAggregateInputFields,
});

export const CompanyCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  address: t.field({"required":false,"type":SortOrder}),
  city: t.field({"required":false,"type":SortOrder}),
  state: t.field({"required":false,"type":SortOrder}),
  country: t.field({"required":false,"type":SortOrder}),
  companyInbox: t.field({"required":false,"type":SortOrder}),
  subdomain: t.field({"required":false,"type":SortOrder}),
  gdprEnable: t.field({"required":false,"type":SortOrder}),
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":SortOrder}),
  gdprEmailFooter: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  ownerId: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
});
export const CompanyCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCountOrderByAggregateInput>>('CompanyCountOrderByAggregateInput').implement({
  fields: CompanyCountOrderByAggregateInputFields,
});

export const CompanyAvgOrderByAggregateInputFields = (t: any) => ({
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
});
export const CompanyAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyAvgOrderByAggregateInput>>('CompanyAvgOrderByAggregateInput').implement({
  fields: CompanyAvgOrderByAggregateInputFields,
});

export const CompanyMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  address: t.field({"required":false,"type":SortOrder}),
  city: t.field({"required":false,"type":SortOrder}),
  state: t.field({"required":false,"type":SortOrder}),
  country: t.field({"required":false,"type":SortOrder}),
  companyInbox: t.field({"required":false,"type":SortOrder}),
  subdomain: t.field({"required":false,"type":SortOrder}),
  gdprEnable: t.field({"required":false,"type":SortOrder}),
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":SortOrder}),
  gdprEmailFooter: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  ownerId: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMaxOrderByAggregateInput>>('CompanyMaxOrderByAggregateInput').implement({
  fields: CompanyMaxOrderByAggregateInputFields,
});

export const CompanyMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  address: t.field({"required":false,"type":SortOrder}),
  city: t.field({"required":false,"type":SortOrder}),
  state: t.field({"required":false,"type":SortOrder}),
  country: t.field({"required":false,"type":SortOrder}),
  companyInbox: t.field({"required":false,"type":SortOrder}),
  subdomain: t.field({"required":false,"type":SortOrder}),
  gdprEnable: t.field({"required":false,"type":SortOrder}),
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":SortOrder}),
  gdprEmailFooter: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  ownerId: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMinOrderByAggregateInput>>('CompanyMinOrderByAggregateInput').implement({
  fields: CompanyMinOrderByAggregateInputFields,
});

export const CompanySumOrderByAggregateInputFields = (t: any) => ({
  gdprRetention: t.field({"required":false,"type":SortOrder}),
  logoId: t.field({"required":false,"type":SortOrder}),
});
export const CompanySumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanySumOrderByAggregateInput>>('CompanySumOrderByAggregateInput').implement({
  fields: CompanySumOrderByAggregateInputFields,
});

export const BoolNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedBoolNullableFilter}),
  _max: t.field({"required":false,"type":NestedBoolNullableFilter}),
});
export const BoolNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.BoolNullableWithAggregatesFilter>>('BoolNullableWithAggregatesFilter').implement({
  fields: BoolNullableWithAggregatesFilterFields,
});

export const SubscriptionDataCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  active: t.field({"required":false,"type":SortOrder}),
  currentPeriodStart: t.field({"required":false,"type":SortOrder}),
  currentPeriodEnd: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const SubscriptionDataCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCountOrderByAggregateInput>>('SubscriptionDataCountOrderByAggregateInput').implement({
  fields: SubscriptionDataCountOrderByAggregateInputFields,
});

export const SubscriptionDataAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const SubscriptionDataAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataAvgOrderByAggregateInput>>('SubscriptionDataAvgOrderByAggregateInput').implement({
  fields: SubscriptionDataAvgOrderByAggregateInputFields,
});

export const SubscriptionDataMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  active: t.field({"required":false,"type":SortOrder}),
  currentPeriodStart: t.field({"required":false,"type":SortOrder}),
  currentPeriodEnd: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const SubscriptionDataMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataMaxOrderByAggregateInput>>('SubscriptionDataMaxOrderByAggregateInput').implement({
  fields: SubscriptionDataMaxOrderByAggregateInputFields,
});

export const SubscriptionDataMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  active: t.field({"required":false,"type":SortOrder}),
  currentPeriodStart: t.field({"required":false,"type":SortOrder}),
  currentPeriodEnd: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const SubscriptionDataMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataMinOrderByAggregateInput>>('SubscriptionDataMinOrderByAggregateInput').implement({
  fields: SubscriptionDataMinOrderByAggregateInputFields,
});

export const SubscriptionDataSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const SubscriptionDataSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataSumOrderByAggregateInput>>('SubscriptionDataSumOrderByAggregateInput').implement({
  fields: SubscriptionDataSumOrderByAggregateInputFields,
});

export const CompanyMetadataCompanyIdKeyCompoundUniqueInputFields = (t: any) => ({
  companyId: t.string({"required":true}),
  key: t.string({"required":true}),
});
export const CompanyMetadataCompanyIdKeyCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCompanyIdKeyCompoundUniqueInput>>('CompanyMetadataCompanyIdKeyCompoundUniqueInput').implement({
  fields: CompanyMetadataCompanyIdKeyCompoundUniqueInputFields,
});

export const CompanyMetadataCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCountOrderByAggregateInput>>('CompanyMetadataCountOrderByAggregateInput').implement({
  fields: CompanyMetadataCountOrderByAggregateInputFields,
});

export const CompanyMetadataAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataAvgOrderByAggregateInput>>('CompanyMetadataAvgOrderByAggregateInput').implement({
  fields: CompanyMetadataAvgOrderByAggregateInputFields,
});

export const CompanyMetadataMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataMaxOrderByAggregateInput>>('CompanyMetadataMaxOrderByAggregateInput').implement({
  fields: CompanyMetadataMaxOrderByAggregateInputFields,
});

export const CompanyMetadataMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataMinOrderByAggregateInput>>('CompanyMetadataMinOrderByAggregateInput').implement({
  fields: CompanyMetadataMinOrderByAggregateInputFields,
});

export const CompanyMetadataSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const CompanyMetadataSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataSumOrderByAggregateInput>>('CompanyMetadataSumOrderByAggregateInput').implement({
  fields: CompanyMetadataSumOrderByAggregateInputFields,
});

export const DepartmentCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCountOrderByAggregateInput>>('DepartmentCountOrderByAggregateInput').implement({
  fields: DepartmentCountOrderByAggregateInputFields,
});

export const DepartmentAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentAvgOrderByAggregateInput>>('DepartmentAvgOrderByAggregateInput').implement({
  fields: DepartmentAvgOrderByAggregateInputFields,
});

export const DepartmentMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentMaxOrderByAggregateInput>>('DepartmentMaxOrderByAggregateInput').implement({
  fields: DepartmentMaxOrderByAggregateInputFields,
});

export const DepartmentMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentMinOrderByAggregateInput>>('DepartmentMinOrderByAggregateInput').implement({
  fields: DepartmentMinOrderByAggregateInputFields,
});

export const DepartmentSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const DepartmentSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentSumOrderByAggregateInput>>('DepartmentSumOrderByAggregateInput').implement({
  fields: DepartmentSumOrderByAggregateInputFields,
});

export const JsonFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
});
export const JsonFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.JsonFilter>>('JsonFilter').implement({
  fields: JsonFilterFields,
});

export const MatchListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":MatchWhereInput}),
  some: t.field({"required":false,"type":MatchWhereInput}),
  none: t.field({"required":false,"type":MatchWhereInput}),
});
export const MatchListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchListRelationFilter>>('MatchListRelationFilter').implement({
  fields: MatchListRelationFilterFields,
});

export const MatchOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const MatchOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchOrderByRelationAggregateInput>>('MatchOrderByRelationAggregateInput').implement({
  fields: MatchOrderByRelationAggregateInputFields,
});

export const DisqualifyReasonCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCountOrderByAggregateInput>>('DisqualifyReasonCountOrderByAggregateInput').implement({
  fields: DisqualifyReasonCountOrderByAggregateInputFields,
});

export const DisqualifyReasonAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonAvgOrderByAggregateInput>>('DisqualifyReasonAvgOrderByAggregateInput').implement({
  fields: DisqualifyReasonAvgOrderByAggregateInputFields,
});

export const DisqualifyReasonMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonMaxOrderByAggregateInput>>('DisqualifyReasonMaxOrderByAggregateInput').implement({
  fields: DisqualifyReasonMaxOrderByAggregateInputFields,
});

export const DisqualifyReasonMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonMinOrderByAggregateInput>>('DisqualifyReasonMinOrderByAggregateInput').implement({
  fields: DisqualifyReasonMinOrderByAggregateInputFields,
});

export const DisqualifyReasonSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const DisqualifyReasonSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonSumOrderByAggregateInput>>('DisqualifyReasonSumOrderByAggregateInput').implement({
  fields: DisqualifyReasonSumOrderByAggregateInputFields,
});

export const JsonWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedJsonFilter}),
  _max: t.field({"required":false,"type":NestedJsonFilter}),
});
export const JsonWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.JsonWithAggregatesFilter>>('JsonWithAggregatesFilter').implement({
  fields: JsonWithAggregatesFilterFields,
});

export const EnumTagSourceTypeFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TagSourceType}),
  in: t.field({"required":false,"type":[TagSourceType]}),
  notIn: t.field({"required":false,"type":[TagSourceType]}),
  not: t.field({"required":false,"type":TagSourceType}),
});
export const EnumTagSourceTypeFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTagSourceTypeFilter>>('EnumTagSourceTypeFilter').implement({
  fields: EnumTagSourceTypeFilterFields,
});

export const OfferTagListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":OfferTagWhereInput}),
  some: t.field({"required":false,"type":OfferTagWhereInput}),
  none: t.field({"required":false,"type":OfferTagWhereInput}),
});
export const OfferTagListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagListRelationFilter>>('OfferTagListRelationFilter').implement({
  fields: OfferTagListRelationFilterFields,
});

export const CandidateTagListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CandidateTagWhereInput}),
  some: t.field({"required":false,"type":CandidateTagWhereInput}),
  none: t.field({"required":false,"type":CandidateTagWhereInput}),
});
export const CandidateTagListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagListRelationFilter>>('CandidateTagListRelationFilter').implement({
  fields: CandidateTagListRelationFilterFields,
});

export const OfferTagOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagOrderByRelationAggregateInput>>('OfferTagOrderByRelationAggregateInput').implement({
  fields: OfferTagOrderByRelationAggregateInputFields,
});

export const CandidateTagOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagOrderByRelationAggregateInput>>('CandidateTagOrderByRelationAggregateInput').implement({
  fields: CandidateTagOrderByRelationAggregateInputFields,
});

export const TagSourceCompanyIdTypeNameCompoundUniqueInputFields = (t: any) => ({
  companyId: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  name: t.string({"required":true}),
});
export const TagSourceCompanyIdTypeNameCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCompanyIdTypeNameCompoundUniqueInput>>('TagSourceCompanyIdTypeNameCompoundUniqueInput').implement({
  fields: TagSourceCompanyIdTypeNameCompoundUniqueInputFields,
});

export const TagSourceCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCountOrderByAggregateInput>>('TagSourceCountOrderByAggregateInput').implement({
  fields: TagSourceCountOrderByAggregateInputFields,
});

export const TagSourceAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceAvgOrderByAggregateInput>>('TagSourceAvgOrderByAggregateInput').implement({
  fields: TagSourceAvgOrderByAggregateInputFields,
});

export const TagSourceMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceMaxOrderByAggregateInput>>('TagSourceMaxOrderByAggregateInput').implement({
  fields: TagSourceMaxOrderByAggregateInputFields,
});

export const TagSourceMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceMinOrderByAggregateInput>>('TagSourceMinOrderByAggregateInput').implement({
  fields: TagSourceMinOrderByAggregateInputFields,
});

export const TagSourceSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TagSourceSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceSumOrderByAggregateInput>>('TagSourceSumOrderByAggregateInput').implement({
  fields: TagSourceSumOrderByAggregateInputFields,
});

export const EnumTagSourceTypeWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TagSourceType}),
  in: t.field({"required":false,"type":[TagSourceType]}),
  notIn: t.field({"required":false,"type":[TagSourceType]}),
  not: t.field({"required":false,"type":TagSourceType}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumTagSourceTypeFilter}),
  _max: t.field({"required":false,"type":NestedEnumTagSourceTypeFilter}),
});
export const EnumTagSourceTypeWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTagSourceTypeWithAggregatesFilter>>('EnumTagSourceTypeWithAggregatesFilter').implement({
  fields: EnumTagSourceTypeWithAggregatesFilterFields,
});

export const AuditLogCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  actor: t.field({"required":false,"type":SortOrder}),
  actorType: t.field({"required":false,"type":SortOrder}),
  ip: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  eventDetails: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCountOrderByAggregateInput>>('AuditLogCountOrderByAggregateInput').implement({
  fields: AuditLogCountOrderByAggregateInputFields,
});

export const AuditLogAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogAvgOrderByAggregateInput>>('AuditLogAvgOrderByAggregateInput').implement({
  fields: AuditLogAvgOrderByAggregateInputFields,
});

export const AuditLogMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  actor: t.field({"required":false,"type":SortOrder}),
  actorType: t.field({"required":false,"type":SortOrder}),
  ip: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogMaxOrderByAggregateInput>>('AuditLogMaxOrderByAggregateInput').implement({
  fields: AuditLogMaxOrderByAggregateInputFields,
});

export const AuditLogMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  actor: t.field({"required":false,"type":SortOrder}),
  actorType: t.field({"required":false,"type":SortOrder}),
  ip: t.field({"required":false,"type":SortOrder}),
  action: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogMinOrderByAggregateInput>>('AuditLogMinOrderByAggregateInput').implement({
  fields: AuditLogMinOrderByAggregateInputFields,
});

export const AuditLogSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  userId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const AuditLogSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogSumOrderByAggregateInput>>('AuditLogSumOrderByAggregateInput').implement({
  fields: AuditLogSumOrderByAggregateInputFields,
});

export const MeetingRoomCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCountOrderByAggregateInput>>('MeetingRoomCountOrderByAggregateInput').implement({
  fields: MeetingRoomCountOrderByAggregateInputFields,
});

export const MeetingRoomAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomAvgOrderByAggregateInput>>('MeetingRoomAvgOrderByAggregateInput').implement({
  fields: MeetingRoomAvgOrderByAggregateInputFields,
});

export const MeetingRoomMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomMaxOrderByAggregateInput>>('MeetingRoomMaxOrderByAggregateInput').implement({
  fields: MeetingRoomMaxOrderByAggregateInputFields,
});

export const MeetingRoomMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomMinOrderByAggregateInput>>('MeetingRoomMinOrderByAggregateInput').implement({
  fields: MeetingRoomMinOrderByAggregateInputFields,
});

export const MeetingRoomSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const MeetingRoomSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomSumOrderByAggregateInput>>('MeetingRoomSumOrderByAggregateInput').implement({
  fields: MeetingRoomSumOrderByAggregateInputFields,
});

export const EventScheduleEvaluationListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EventScheduleEvaluationWhereInput}),
  some: t.field({"required":false,"type":EventScheduleEvaluationWhereInput}),
  none: t.field({"required":false,"type":EventScheduleEvaluationWhereInput}),
});
export const EventScheduleEvaluationListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationListRelationFilter>>('EventScheduleEvaluationListRelationFilter').implement({
  fields: EventScheduleEvaluationListRelationFilterFields,
});

export const EventScheduleEvaluationOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationOrderByRelationAggregateInput>>('EventScheduleEvaluationOrderByRelationAggregateInput').implement({
  fields: EventScheduleEvaluationOrderByRelationAggregateInputFields,
});

export const EventScheduleCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  inviteAll: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  ignoreDayEvents: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCountOrderByAggregateInput>>('EventScheduleCountOrderByAggregateInput').implement({
  fields: EventScheduleCountOrderByAggregateInputFields,
});

export const EventScheduleAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleAvgOrderByAggregateInput>>('EventScheduleAvgOrderByAggregateInput').implement({
  fields: EventScheduleAvgOrderByAggregateInputFields,
});

export const EventScheduleMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  inviteAll: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  ignoreDayEvents: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleMaxOrderByAggregateInput>>('EventScheduleMaxOrderByAggregateInput').implement({
  fields: EventScheduleMaxOrderByAggregateInputFields,
});

export const EventScheduleMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  inviteAll: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  ignoreDayEvents: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  timezone: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleMinOrderByAggregateInput>>('EventScheduleMinOrderByAggregateInput').implement({
  fields: EventScheduleMinOrderByAggregateInputFields,
});

export const EventScheduleSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  dateRange: t.field({"required":false,"type":SortOrder}),
  expiresAfter: t.field({"required":false,"type":SortOrder}),
  bufferTime: t.field({"required":false,"type":SortOrder}),
  meetingLimit: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  Interval: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleSumOrderByAggregateInput>>('EventScheduleSumOrderByAggregateInput').implement({
  fields: EventScheduleSumOrderByAggregateInputFields,
});

export const EventScheduleRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":EventScheduleWhereInput}),
  isNot: t.field({"required":false,"type":EventScheduleWhereInput}),
});
export const EventScheduleRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleRelationFilter>>('EventScheduleRelationFilter').implement({
  fields: EventScheduleRelationFilterFields,
});

export const HiringRoleRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":HiringRoleWhereInput}),
  isNot: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleRelationFilter>>('HiringRoleRelationFilter').implement({
  fields: HiringRoleRelationFilterFields,
});

export const EventScheduleInterviewerCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  availability: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCountOrderByAggregateInput>>('EventScheduleInterviewerCountOrderByAggregateInput').implement({
  fields: EventScheduleInterviewerCountOrderByAggregateInputFields,
});

export const EventScheduleInterviewerAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerAvgOrderByAggregateInput>>('EventScheduleInterviewerAvgOrderByAggregateInput').implement({
  fields: EventScheduleInterviewerAvgOrderByAggregateInputFields,
});

export const EventScheduleInterviewerMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerMaxOrderByAggregateInput>>('EventScheduleInterviewerMaxOrderByAggregateInput').implement({
  fields: EventScheduleInterviewerMaxOrderByAggregateInputFields,
});

export const EventScheduleInterviewerMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerMinOrderByAggregateInput>>('EventScheduleInterviewerMinOrderByAggregateInput').implement({
  fields: EventScheduleInterviewerMinOrderByAggregateInputFields,
});

export const EventScheduleInterviewerSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleInterviewerSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerSumOrderByAggregateInput>>('EventScheduleInterviewerSumOrderByAggregateInput').implement({
  fields: EventScheduleInterviewerSumOrderByAggregateInputFields,
});

export const EvaluationRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":EvaluationWhereInput}),
  isNot: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationRelationFilter>>('EvaluationRelationFilter').implement({
  fields: EvaluationRelationFilterFields,
});

export const EventScheduleEvaluationCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCountOrderByAggregateInput>>('EventScheduleEvaluationCountOrderByAggregateInput').implement({
  fields: EventScheduleEvaluationCountOrderByAggregateInputFields,
});

export const EventScheduleEvaluationAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationAvgOrderByAggregateInput>>('EventScheduleEvaluationAvgOrderByAggregateInput').implement({
  fields: EventScheduleEvaluationAvgOrderByAggregateInputFields,
});

export const EventScheduleEvaluationMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationMaxOrderByAggregateInput>>('EventScheduleEvaluationMaxOrderByAggregateInput').implement({
  fields: EventScheduleEvaluationMaxOrderByAggregateInputFields,
});

export const EventScheduleEvaluationMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationMinOrderByAggregateInput>>('EventScheduleEvaluationMinOrderByAggregateInput').implement({
  fields: EventScheduleEvaluationMinOrderByAggregateInputFields,
});

export const EventScheduleEvaluationSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventScheduleId: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EventScheduleEvaluationSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationSumOrderByAggregateInput>>('EventScheduleEvaluationSumOrderByAggregateInput').implement({
  fields: EventScheduleEvaluationSumOrderByAggregateInputFields,
});

export const EventCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  date: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
});
export const EventCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCountOrderByAggregateInput>>('EventCountOrderByAggregateInput').implement({
  fields: EventCountOrderByAggregateInputFields,
});

export const EventAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
});
export const EventAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventAvgOrderByAggregateInput>>('EventAvgOrderByAggregateInput').implement({
  fields: EventAvgOrderByAggregateInputFields,
});

export const EventMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  date: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
});
export const EventMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventMaxOrderByAggregateInput>>('EventMaxOrderByAggregateInput').implement({
  fields: EventMaxOrderByAggregateInputFields,
});

export const EventMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  date: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  location: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  privateNote: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
});
export const EventMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventMinOrderByAggregateInput>>('EventMinOrderByAggregateInput').implement({
  fields: EventMinOrderByAggregateInputFields,
});

export const EventSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  duration: t.field({"required":false,"type":SortOrder}),
  createdById: t.field({"required":false,"type":SortOrder}),
});
export const EventSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventSumOrderByAggregateInput>>('EventSumOrderByAggregateInput').implement({
  fields: EventSumOrderByAggregateInputFields,
});

export const EventRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":EventWhereInput}),
  isNot: t.field({"required":false,"type":EventWhereInput}),
});
export const EventRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventRelationFilter>>('EventRelationFilter').implement({
  fields: EventRelationFilterFields,
});

export const EventInterviewerCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCountOrderByAggregateInput>>('EventInterviewerCountOrderByAggregateInput').implement({
  fields: EventInterviewerCountOrderByAggregateInputFields,
});

export const EventInterviewerAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerAvgOrderByAggregateInput>>('EventInterviewerAvgOrderByAggregateInput').implement({
  fields: EventInterviewerAvgOrderByAggregateInputFields,
});

export const EventInterviewerMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerMaxOrderByAggregateInput>>('EventInterviewerMaxOrderByAggregateInput').implement({
  fields: EventInterviewerMaxOrderByAggregateInputFields,
});

export const EventInterviewerMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerMinOrderByAggregateInput>>('EventInterviewerMinOrderByAggregateInput').implement({
  fields: EventInterviewerMinOrderByAggregateInputFields,
});

export const EventInterviewerSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const EventInterviewerSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerSumOrderByAggregateInput>>('EventInterviewerSumOrderByAggregateInput').implement({
  fields: EventInterviewerSumOrderByAggregateInputFields,
});

export const EnumOfferPersonalItemsFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":OfferPersonalItems}),
  in: t.field({"required":false,"type":[OfferPersonalItems]}),
  notIn: t.field({"required":false,"type":[OfferPersonalItems]}),
  not: t.field({"required":false,"type":OfferPersonalItems}),
});
export const EnumOfferPersonalItemsFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumOfferPersonalItemsFilter>>('EnumOfferPersonalItemsFilter').implement({
  fields: EnumOfferPersonalItemsFilterFields,
});

export const DepartmentNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":DepartmentWhereInput}),
  isNot: t.field({"required":false,"type":DepartmentWhereInput}),
});
export const DepartmentNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentNullableRelationFilter>>('DepartmentNullableRelationFilter').implement({
  fields: DepartmentNullableRelationFilterFields,
});

export const TemplateNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TemplateWhereInput}),
  isNot: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateNullableRelationFilter>>('TemplateNullableRelationFilter').implement({
  fields: TemplateNullableRelationFilterFields,
});

export const OfferCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  requirements: t.field({"required":false,"type":SortOrder}),
  locationCountry: t.field({"required":false,"type":SortOrder}),
  locationState: t.field({"required":false,"type":SortOrder}),
  locationCity: t.field({"required":false,"type":SortOrder}),
  locationStreet: t.field({"required":false,"type":SortOrder}),
  zipcode: t.field({"required":false,"type":SortOrder}),
  remote: t.field({"required":false,"type":SortOrder}),
  jobType: t.field({"required":false,"type":SortOrder}),
  jobCategory: t.field({"required":false,"type":SortOrder}),
  jobReqEducation: t.field({"required":false,"type":SortOrder}),
  jobReqExperience: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryPeriod: t.field({"required":false,"type":SortOrder}),
  jobSalaryCurrency: t.field({"required":false,"type":SortOrder}),
  personalInfoCv: t.field({"required":false,"type":SortOrder}),
  personalInfoCoverLetter: t.field({"required":false,"type":SortOrder}),
  personalInfoPhoto: t.field({"required":false,"type":SortOrder}),
  personalInfoPhone: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
  isPublished: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const OfferCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCountOrderByAggregateInput>>('OfferCountOrderByAggregateInput').implement({
  fields: OfferCountOrderByAggregateInputFields,
});

export const OfferAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
});
export const OfferAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferAvgOrderByAggregateInput>>('OfferAvgOrderByAggregateInput').implement({
  fields: OfferAvgOrderByAggregateInputFields,
});

export const OfferMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  requirements: t.field({"required":false,"type":SortOrder}),
  locationCountry: t.field({"required":false,"type":SortOrder}),
  locationState: t.field({"required":false,"type":SortOrder}),
  locationCity: t.field({"required":false,"type":SortOrder}),
  locationStreet: t.field({"required":false,"type":SortOrder}),
  zipcode: t.field({"required":false,"type":SortOrder}),
  remote: t.field({"required":false,"type":SortOrder}),
  jobType: t.field({"required":false,"type":SortOrder}),
  jobCategory: t.field({"required":false,"type":SortOrder}),
  jobReqEducation: t.field({"required":false,"type":SortOrder}),
  jobReqExperience: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryPeriod: t.field({"required":false,"type":SortOrder}),
  jobSalaryCurrency: t.field({"required":false,"type":SortOrder}),
  personalInfoCv: t.field({"required":false,"type":SortOrder}),
  personalInfoCoverLetter: t.field({"required":false,"type":SortOrder}),
  personalInfoPhoto: t.field({"required":false,"type":SortOrder}),
  personalInfoPhone: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
  isPublished: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const OfferMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferMaxOrderByAggregateInput>>('OfferMaxOrderByAggregateInput').implement({
  fields: OfferMaxOrderByAggregateInputFields,
});

export const OfferMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  requirements: t.field({"required":false,"type":SortOrder}),
  locationCountry: t.field({"required":false,"type":SortOrder}),
  locationState: t.field({"required":false,"type":SortOrder}),
  locationCity: t.field({"required":false,"type":SortOrder}),
  locationStreet: t.field({"required":false,"type":SortOrder}),
  zipcode: t.field({"required":false,"type":SortOrder}),
  remote: t.field({"required":false,"type":SortOrder}),
  jobType: t.field({"required":false,"type":SortOrder}),
  jobCategory: t.field({"required":false,"type":SortOrder}),
  jobReqEducation: t.field({"required":false,"type":SortOrder}),
  jobReqExperience: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryPeriod: t.field({"required":false,"type":SortOrder}),
  jobSalaryCurrency: t.field({"required":false,"type":SortOrder}),
  personalInfoCv: t.field({"required":false,"type":SortOrder}),
  personalInfoCoverLetter: t.field({"required":false,"type":SortOrder}),
  personalInfoPhoto: t.field({"required":false,"type":SortOrder}),
  personalInfoPhone: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
  isPublished: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const OfferMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferMinOrderByAggregateInput>>('OfferMinOrderByAggregateInput').implement({
  fields: OfferMinOrderByAggregateInputFields,
});

export const OfferSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  departmentId: t.field({"required":false,"type":SortOrder}),
  recruiterId: t.field({"required":false,"type":SortOrder}),
  hiringManagerId: t.field({"required":false,"type":SortOrder}),
  jobHoursMin: t.field({"required":false,"type":SortOrder}),
  jobHoursMax: t.field({"required":false,"type":SortOrder}),
  jobSalaryMin: t.field({"required":false,"type":SortOrder}),
  jobSalaryMax: t.field({"required":false,"type":SortOrder}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":SortOrder}),
  pipelineTemplateId: t.field({"required":false,"type":SortOrder}),
  autoConfirmationEmailId: t.field({"required":false,"type":SortOrder}),
});
export const OfferSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferSumOrderByAggregateInput>>('OfferSumOrderByAggregateInput').implement({
  fields: OfferSumOrderByAggregateInputFields,
});

export const EnumOfferPersonalItemsWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":OfferPersonalItems}),
  in: t.field({"required":false,"type":[OfferPersonalItems]}),
  notIn: t.field({"required":false,"type":[OfferPersonalItems]}),
  not: t.field({"required":false,"type":OfferPersonalItems}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumOfferPersonalItemsFilter}),
  _max: t.field({"required":false,"type":NestedEnumOfferPersonalItemsFilter}),
});
export const EnumOfferPersonalItemsWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumOfferPersonalItemsWithAggregatesFilter>>('EnumOfferPersonalItemsWithAggregatesFilter').implement({
  fields: EnumOfferPersonalItemsWithAggregatesFilterFields,
});

export const OfferRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":OfferWhereInput}),
  isNot: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferRelationFilter>>('OfferRelationFilter').implement({
  fields: OfferRelationFilterFields,
});

export const AttachmentRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":AttachmentWhereInput}),
  isNot: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentRelationFilter>>('AttachmentRelationFilter').implement({
  fields: AttachmentRelationFilterFields,
});

export const OfferFileCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCountOrderByAggregateInput>>('OfferFileCountOrderByAggregateInput').implement({
  fields: OfferFileCountOrderByAggregateInputFields,
});

export const OfferFileAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileAvgOrderByAggregateInput>>('OfferFileAvgOrderByAggregateInput').implement({
  fields: OfferFileAvgOrderByAggregateInputFields,
});

export const OfferFileMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileMaxOrderByAggregateInput>>('OfferFileMaxOrderByAggregateInput').implement({
  fields: OfferFileMaxOrderByAggregateInputFields,
});

export const OfferFileMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileMinOrderByAggregateInput>>('OfferFileMinOrderByAggregateInput').implement({
  fields: OfferFileMinOrderByAggregateInputFields,
});

export const OfferFileSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const OfferFileSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileSumOrderByAggregateInput>>('OfferFileSumOrderByAggregateInput').implement({
  fields: OfferFileSumOrderByAggregateInputFields,
});

export const CandidateRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":CandidateWhereInput}),
  isNot: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateRelationFilter>>('CandidateRelationFilter').implement({
  fields: CandidateRelationFilterFields,
});

export const StageNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":StageWhereInput}),
  isNot: t.field({"required":false,"type":StageWhereInput}),
});
export const StageNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageNullableRelationFilter>>('StageNullableRelationFilter').implement({
  fields: StageNullableRelationFilterFields,
});

export const DisqualifyReasonNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  isNot: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
});
export const DisqualifyReasonNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonNullableRelationFilter>>('DisqualifyReasonNullableRelationFilter').implement({
  fields: DisqualifyReasonNullableRelationFilterFields,
});

export const MatchCandidateIdOfferIdCompoundUniqueInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  offerId: t.int({"required":true}),
});
export const MatchCandidateIdOfferIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCandidateIdOfferIdCompoundUniqueInput>>('MatchCandidateIdOfferIdCompoundUniqueInput').implement({
  fields: MatchCandidateIdOfferIdCompoundUniqueInputFields,
});

export const MatchCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  isHired: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
});
export const MatchCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCountOrderByAggregateInput>>('MatchCountOrderByAggregateInput').implement({
  fields: MatchCountOrderByAggregateInputFields,
});

export const MatchAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
});
export const MatchAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchAvgOrderByAggregateInput>>('MatchAvgOrderByAggregateInput').implement({
  fields: MatchAvgOrderByAggregateInputFields,
});

export const MatchMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  isHired: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
});
export const MatchMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchMaxOrderByAggregateInput>>('MatchMaxOrderByAggregateInput').implement({
  fields: MatchMaxOrderByAggregateInputFields,
});

export const MatchMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  isHired: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
});
export const MatchMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchMinOrderByAggregateInput>>('MatchMinOrderByAggregateInput').implement({
  fields: MatchMinOrderByAggregateInputFields,
});

export const MatchSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
  disqualifyReasonId: t.field({"required":false,"type":SortOrder}),
});
export const MatchSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchSumOrderByAggregateInput>>('MatchSumOrderByAggregateInput').implement({
  fields: MatchSumOrderByAggregateInputFields,
});

export const TagSourceRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TagSourceWhereInput}),
  isNot: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceRelationFilter>>('TagSourceRelationFilter').implement({
  fields: TagSourceRelationFilterFields,
});

export const OfferTagOfferIdTagIdCompoundUniqueInputFields = (t: any) => ({
  offerId: t.int({"required":true}),
  tagId: t.int({"required":true}),
});
export const OfferTagOfferIdTagIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagOfferIdTagIdCompoundUniqueInput>>('OfferTagOfferIdTagIdCompoundUniqueInput').implement({
  fields: OfferTagOfferIdTagIdCompoundUniqueInputFields,
});

export const OfferTagCountOrderByAggregateInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCountOrderByAggregateInput>>('OfferTagCountOrderByAggregateInput').implement({
  fields: OfferTagCountOrderByAggregateInputFields,
});

export const OfferTagAvgOrderByAggregateInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagAvgOrderByAggregateInput>>('OfferTagAvgOrderByAggregateInput').implement({
  fields: OfferTagAvgOrderByAggregateInputFields,
});

export const OfferTagMaxOrderByAggregateInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagMaxOrderByAggregateInput>>('OfferTagMaxOrderByAggregateInput').implement({
  fields: OfferTagMaxOrderByAggregateInputFields,
});

export const OfferTagMinOrderByAggregateInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagMinOrderByAggregateInput>>('OfferTagMinOrderByAggregateInput').implement({
  fields: OfferTagMinOrderByAggregateInputFields,
});

export const OfferTagSumOrderByAggregateInputFields = (t: any) => ({
  offerId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const OfferTagSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagSumOrderByAggregateInput>>('OfferTagSumOrderByAggregateInput').implement({
  fields: OfferTagSumOrderByAggregateInputFields,
});

export const EnumMembershipTypesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":MembershipTypes}),
  in: t.field({"required":false,"type":[MembershipTypes]}),
  notIn: t.field({"required":false,"type":[MembershipTypes]}),
  not: t.field({"required":false,"type":MembershipTypes}),
});
export const EnumMembershipTypesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumMembershipTypesFilter>>('EnumMembershipTypesFilter').implement({
  fields: EnumMembershipTypesFilterFields,
});

export const RoleNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":RoleWhereInput}),
  isNot: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleNullableRelationFilter>>('RoleNullableRelationFilter').implement({
  fields: RoleNullableRelationFilterFields,
});

export const MembershipCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
});
export const MembershipCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCountOrderByAggregateInput>>('MembershipCountOrderByAggregateInput').implement({
  fields: MembershipCountOrderByAggregateInputFields,
});

export const MembershipAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
});
export const MembershipAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipAvgOrderByAggregateInput>>('MembershipAvgOrderByAggregateInput').implement({
  fields: MembershipAvgOrderByAggregateInputFields,
});

export const MembershipMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
});
export const MembershipMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipMaxOrderByAggregateInput>>('MembershipMaxOrderByAggregateInput').implement({
  fields: MembershipMaxOrderByAggregateInputFields,
});

export const MembershipMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
});
export const MembershipMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipMinOrderByAggregateInput>>('MembershipMinOrderByAggregateInput').implement({
  fields: MembershipMinOrderByAggregateInputFields,
});

export const MembershipSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
});
export const MembershipSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipSumOrderByAggregateInput>>('MembershipSumOrderByAggregateInput').implement({
  fields: MembershipSumOrderByAggregateInputFields,
});

export const EnumMembershipTypesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":MembershipTypes}),
  in: t.field({"required":false,"type":[MembershipTypes]}),
  notIn: t.field({"required":false,"type":[MembershipTypes]}),
  not: t.field({"required":false,"type":MembershipTypes}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumMembershipTypesFilter}),
  _max: t.field({"required":false,"type":NestedEnumMembershipTypesFilter}),
});
export const EnumMembershipTypesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumMembershipTypesWithAggregatesFilter>>('EnumMembershipTypesWithAggregatesFilter').implement({
  fields: EnumMembershipTypesWithAggregatesFilterFields,
});

export const TalentPoolMatchListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":TalentPoolMatchWhereInput}),
  some: t.field({"required":false,"type":TalentPoolMatchWhereInput}),
  none: t.field({"required":false,"type":TalentPoolMatchWhereInput}),
});
export const TalentPoolMatchListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchListRelationFilter>>('TalentPoolMatchListRelationFilter').implement({
  fields: TalentPoolMatchListRelationFilterFields,
});

export const TalentPoolMatchOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchOrderByRelationAggregateInput>>('TalentPoolMatchOrderByRelationAggregateInput').implement({
  fields: TalentPoolMatchOrderByRelationAggregateInputFields,
});

export const TalentPoolCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCountOrderByAggregateInput>>('TalentPoolCountOrderByAggregateInput').implement({
  fields: TalentPoolCountOrderByAggregateInputFields,
});

export const TalentPoolAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolAvgOrderByAggregateInput>>('TalentPoolAvgOrderByAggregateInput').implement({
  fields: TalentPoolAvgOrderByAggregateInputFields,
});

export const TalentPoolMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMaxOrderByAggregateInput>>('TalentPoolMaxOrderByAggregateInput').implement({
  fields: TalentPoolMaxOrderByAggregateInputFields,
});

export const TalentPoolMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMinOrderByAggregateInput>>('TalentPoolMinOrderByAggregateInput').implement({
  fields: TalentPoolMinOrderByAggregateInputFields,
});

export const TalentPoolSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolSumOrderByAggregateInput>>('TalentPoolSumOrderByAggregateInput').implement({
  fields: TalentPoolSumOrderByAggregateInputFields,
});

export const TalentPoolRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TalentPoolWhereInput}),
  isNot: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolRelationFilter>>('TalentPoolRelationFilter').implement({
  fields: TalentPoolRelationFilterFields,
});

export const TalentPoolFileCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCountOrderByAggregateInput>>('TalentPoolFileCountOrderByAggregateInput').implement({
  fields: TalentPoolFileCountOrderByAggregateInputFields,
});

export const TalentPoolFileAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileAvgOrderByAggregateInput>>('TalentPoolFileAvgOrderByAggregateInput').implement({
  fields: TalentPoolFileAvgOrderByAggregateInputFields,
});

export const TalentPoolFileMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileMaxOrderByAggregateInput>>('TalentPoolFileMaxOrderByAggregateInput').implement({
  fields: TalentPoolFileMaxOrderByAggregateInputFields,
});

export const TalentPoolFileMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileMinOrderByAggregateInput>>('TalentPoolFileMinOrderByAggregateInput').implement({
  fields: TalentPoolFileMinOrderByAggregateInputFields,
});

export const TalentPoolFileSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  attachmentId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolFileSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileSumOrderByAggregateInput>>('TalentPoolFileSumOrderByAggregateInput').implement({
  fields: TalentPoolFileSumOrderByAggregateInputFields,
});

export const TalentPoolMatchCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCountOrderByAggregateInput>>('TalentPoolMatchCountOrderByAggregateInput').implement({
  fields: TalentPoolMatchCountOrderByAggregateInputFields,
});

export const TalentPoolMatchAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchAvgOrderByAggregateInput>>('TalentPoolMatchAvgOrderByAggregateInput').implement({
  fields: TalentPoolMatchAvgOrderByAggregateInputFields,
});

export const TalentPoolMatchMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchMaxOrderByAggregateInput>>('TalentPoolMatchMaxOrderByAggregateInput').implement({
  fields: TalentPoolMatchMaxOrderByAggregateInputFields,
});

export const TalentPoolMatchMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchMinOrderByAggregateInput>>('TalentPoolMatchMinOrderByAggregateInput').implement({
  fields: TalentPoolMatchMinOrderByAggregateInputFields,
});

export const TalentPoolMatchSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TalentPoolMatchSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchSumOrderByAggregateInput>>('TalentPoolMatchSumOrderByAggregateInput').implement({
  fields: TalentPoolMatchSumOrderByAggregateInputFields,
});

export const EnumTemplateTypesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TemplateTypes}),
  in: t.field({"required":false,"type":[TemplateTypes]}),
  notIn: t.field({"required":false,"type":[TemplateTypes]}),
  not: t.field({"required":false,"type":TemplateTypes}),
});
export const EnumTemplateTypesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTemplateTypesFilter>>('EnumTemplateTypesFilter').implement({
  fields: EnumTemplateTypesFilterFields,
});

export const StageListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":StageWhereInput}),
  some: t.field({"required":false,"type":StageWhereInput}),
  none: t.field({"required":false,"type":StageWhereInput}),
});
export const StageListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageListRelationFilter>>('StageListRelationFilter').implement({
  fields: StageListRelationFilterFields,
});

export const StageOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const StageOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageOrderByRelationAggregateInput>>('StageOrderByRelationAggregateInput').implement({
  fields: StageOrderByRelationAggregateInputFields,
});

export const TemplateCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  isCompanyWide: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
});
export const TemplateCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCountOrderByAggregateInput>>('TemplateCountOrderByAggregateInput').implement({
  fields: TemplateCountOrderByAggregateInputFields,
});

export const TemplateAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TemplateAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateAvgOrderByAggregateInput>>('TemplateAvgOrderByAggregateInput').implement({
  fields: TemplateAvgOrderByAggregateInputFields,
});

export const TemplateMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  isCompanyWide: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
});
export const TemplateMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateMaxOrderByAggregateInput>>('TemplateMaxOrderByAggregateInput').implement({
  fields: TemplateMaxOrderByAggregateInputFields,
});

export const TemplateMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  isCompanyWide: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
});
export const TemplateMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateMinOrderByAggregateInput>>('TemplateMinOrderByAggregateInput').implement({
  fields: TemplateMinOrderByAggregateInputFields,
});

export const TemplateSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const TemplateSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateSumOrderByAggregateInput>>('TemplateSumOrderByAggregateInput').implement({
  fields: TemplateSumOrderByAggregateInputFields,
});

export const EnumTemplateTypesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TemplateTypes}),
  in: t.field({"required":false,"type":[TemplateTypes]}),
  notIn: t.field({"required":false,"type":[TemplateTypes]}),
  not: t.field({"required":false,"type":TemplateTypes}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumTemplateTypesFilter}),
  _max: t.field({"required":false,"type":NestedEnumTemplateTypesFilter}),
});
export const EnumTemplateTypesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTemplateTypesWithAggregatesFilter>>('EnumTemplateTypesWithAggregatesFilter').implement({
  fields: EnumTemplateTypesWithAggregatesFilterFields,
});

export const TemplateRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TemplateWhereInput}),
  isNot: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateRelationFilter>>('TemplateRelationFilter').implement({
  fields: TemplateRelationFilterFields,
});

export const StageMetadataListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":StageMetadataWhereInput}),
  some: t.field({"required":false,"type":StageMetadataWhereInput}),
  none: t.field({"required":false,"type":StageMetadataWhereInput}),
});
export const StageMetadataListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataListRelationFilter>>('StageMetadataListRelationFilter').implement({
  fields: StageMetadataListRelationFilterFields,
});

export const StageMetadataOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataOrderByRelationAggregateInput>>('StageMetadataOrderByRelationAggregateInput').implement({
  fields: StageMetadataOrderByRelationAggregateInputFields,
});

export const StageCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  isProtected: t.field({"required":false,"type":SortOrder}),
});
export const StageCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCountOrderByAggregateInput>>('StageCountOrderByAggregateInput').implement({
  fields: StageCountOrderByAggregateInputFields,
});

export const StageAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
});
export const StageAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageAvgOrderByAggregateInput>>('StageAvgOrderByAggregateInput').implement({
  fields: StageAvgOrderByAggregateInputFields,
});

export const StageMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  isProtected: t.field({"required":false,"type":SortOrder}),
});
export const StageMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMaxOrderByAggregateInput>>('StageMaxOrderByAggregateInput').implement({
  fields: StageMaxOrderByAggregateInputFields,
});

export const StageMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  category: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  isProtected: t.field({"required":false,"type":SortOrder}),
});
export const StageMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMinOrderByAggregateInput>>('StageMinOrderByAggregateInput').implement({
  fields: StageMinOrderByAggregateInputFields,
});

export const StageSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  position: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
});
export const StageSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageSumOrderByAggregateInput>>('StageSumOrderByAggregateInput').implement({
  fields: StageSumOrderByAggregateInputFields,
});

export const StageRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":StageWhereInput}),
  isNot: t.field({"required":false,"type":StageWhereInput}),
});
export const StageRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageRelationFilter>>('StageRelationFilter').implement({
  fields: StageRelationFilterFields,
});

export const StageVisibilityCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilityCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCountOrderByAggregateInput>>('StageVisibilityCountOrderByAggregateInput').implement({
  fields: StageVisibilityCountOrderByAggregateInputFields,
});

export const StageVisibilityAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilityAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityAvgOrderByAggregateInput>>('StageVisibilityAvgOrderByAggregateInput').implement({
  fields: StageVisibilityAvgOrderByAggregateInputFields,
});

export const StageVisibilityMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilityMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityMaxOrderByAggregateInput>>('StageVisibilityMaxOrderByAggregateInput').implement({
  fields: StageVisibilityMaxOrderByAggregateInputFields,
});

export const StageVisibilityMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilityMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityMinOrderByAggregateInput>>('StageVisibilityMinOrderByAggregateInput').implement({
  fields: StageVisibilityMinOrderByAggregateInputFields,
});

export const StageVisibilitySumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  roleId: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageVisibilitySumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilitySumOrderByAggregateInput>>('StageVisibilitySumOrderByAggregateInput').implement({
  fields: StageVisibilitySumOrderByAggregateInputFields,
});

export const StageMetadataCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  metaKey: t.field({"required":false,"type":SortOrder}),
  metaValue: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCountOrderByAggregateInput>>('StageMetadataCountOrderByAggregateInput').implement({
  fields: StageMetadataCountOrderByAggregateInputFields,
});

export const StageMetadataAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataAvgOrderByAggregateInput>>('StageMetadataAvgOrderByAggregateInput').implement({
  fields: StageMetadataAvgOrderByAggregateInputFields,
});

export const StageMetadataMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  metaKey: t.field({"required":false,"type":SortOrder}),
  metaValue: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataMaxOrderByAggregateInput>>('StageMetadataMaxOrderByAggregateInput').implement({
  fields: StageMetadataMaxOrderByAggregateInputFields,
});

export const StageMetadataMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  metaKey: t.field({"required":false,"type":SortOrder}),
  metaValue: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataMinOrderByAggregateInput>>('StageMetadataMinOrderByAggregateInput').implement({
  fields: StageMetadataMinOrderByAggregateInputFields,
});

export const StageMetadataSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  stageId: t.field({"required":false,"type":SortOrder}),
});
export const StageMetadataSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataSumOrderByAggregateInput>>('StageMetadataSumOrderByAggregateInput').implement({
  fields: StageMetadataSumOrderByAggregateInputFields,
});

export const TagSourceNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TagSourceWhereInput}),
  isNot: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceNullableRelationFilter>>('TagSourceNullableRelationFilter').implement({
  fields: TagSourceNullableRelationFilterFields,
});

export const CandidateCustomFieldListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":CandidateCustomFieldWhereInput}),
  some: t.field({"required":false,"type":CandidateCustomFieldWhereInput}),
  none: t.field({"required":false,"type":CandidateCustomFieldWhereInput}),
});
export const CandidateCustomFieldListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldListRelationFilter>>('CandidateCustomFieldListRelationFilter').implement({
  fields: CandidateCustomFieldListRelationFilterFields,
});

export const SharedCandidateLinkListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":SharedCandidateLinkWhereInput}),
  some: t.field({"required":false,"type":SharedCandidateLinkWhereInput}),
  none: t.field({"required":false,"type":SharedCandidateLinkWhereInput}),
});
export const SharedCandidateLinkListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkListRelationFilter>>('SharedCandidateLinkListRelationFilter').implement({
  fields: SharedCandidateLinkListRelationFilterFields,
});

export const CandidateCustomFieldOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldOrderByRelationAggregateInput>>('CandidateCustomFieldOrderByRelationAggregateInput').implement({
  fields: CandidateCustomFieldOrderByRelationAggregateInputFields,
});

export const SharedCandidateLinkOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkOrderByRelationAggregateInput>>('SharedCandidateLinkOrderByRelationAggregateInput').implement({
  fields: SharedCandidateLinkOrderByRelationAggregateInputFields,
});

export const CandidateEmailCompanyIdCompoundUniqueInputFields = (t: any) => ({
  email: t.string({"required":true}),
  companyId: t.string({"required":true}),
});
export const CandidateEmailCompanyIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateEmailCompanyIdCompoundUniqueInput>>('CandidateEmailCompanyIdCompoundUniqueInput').implement({
  fields: CandidateEmailCompanyIdCompoundUniqueInputFields,
});

export const CandidateCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  skills: t.field({"required":false,"type":SortOrder}),
  mainLanguage: t.field({"required":false,"type":SortOrder}),
  languages: t.field({"required":false,"type":SortOrder}),
  coverLetterText: t.field({"required":false,"type":SortOrder}),
  birthday: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  educationLevel: t.field({"required":false,"type":SortOrder}),
  socials: t.field({"required":false,"type":SortOrder}),
  links: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCountOrderByAggregateInput>>('CandidateCountOrderByAggregateInput').implement({
  fields: CandidateCountOrderByAggregateInputFields,
});

export const CandidateAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
});
export const CandidateAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateAvgOrderByAggregateInput>>('CandidateAvgOrderByAggregateInput').implement({
  fields: CandidateAvgOrderByAggregateInputFields,
});

export const CandidateMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  mainLanguage: t.field({"required":false,"type":SortOrder}),
  coverLetterText: t.field({"required":false,"type":SortOrder}),
  birthday: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  educationLevel: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const CandidateMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateMaxOrderByAggregateInput>>('CandidateMaxOrderByAggregateInput').implement({
  fields: CandidateMaxOrderByAggregateInputFields,
});

export const CandidateMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  firstName: t.field({"required":false,"type":SortOrder}),
  lastName: t.field({"required":false,"type":SortOrder}),
  email: t.field({"required":false,"type":SortOrder}),
  phone: t.field({"required":false,"type":SortOrder}),
  mainLanguage: t.field({"required":false,"type":SortOrder}),
  coverLetterText: t.field({"required":false,"type":SortOrder}),
  birthday: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  educationLevel: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const CandidateMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateMinOrderByAggregateInput>>('CandidateMinOrderByAggregateInput').implement({
  fields: CandidateMinOrderByAggregateInputFields,
});

export const CandidateSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  referrerId: t.field({"required":false,"type":SortOrder}),
  cvId: t.field({"required":false,"type":SortOrder}),
  avatarId: t.field({"required":false,"type":SortOrder}),
  coverLetterId: t.field({"required":false,"type":SortOrder}),
  salaryExpectation: t.field({"required":false,"type":SortOrder}),
  hiredAtId: t.field({"required":false,"type":SortOrder}),
  hiredById: t.field({"required":false,"type":SortOrder}),
});
export const CandidateSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateSumOrderByAggregateInput>>('CandidateSumOrderByAggregateInput').implement({
  fields: CandidateSumOrderByAggregateInputFields,
});

export const CandidateTagCandidateIdTagIdCompoundUniqueInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  tagId: t.int({"required":true}),
});
export const CandidateTagCandidateIdTagIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCandidateIdTagIdCompoundUniqueInput>>('CandidateTagCandidateIdTagIdCompoundUniqueInput').implement({
  fields: CandidateTagCandidateIdTagIdCompoundUniqueInputFields,
});

export const CandidateTagCountOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCountOrderByAggregateInput>>('CandidateTagCountOrderByAggregateInput').implement({
  fields: CandidateTagCountOrderByAggregateInputFields,
});

export const CandidateTagAvgOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagAvgOrderByAggregateInput>>('CandidateTagAvgOrderByAggregateInput').implement({
  fields: CandidateTagAvgOrderByAggregateInputFields,
});

export const CandidateTagMaxOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagMaxOrderByAggregateInput>>('CandidateTagMaxOrderByAggregateInput').implement({
  fields: CandidateTagMaxOrderByAggregateInputFields,
});

export const CandidateTagMinOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagMinOrderByAggregateInput>>('CandidateTagMinOrderByAggregateInput').implement({
  fields: CandidateTagMinOrderByAggregateInputFields,
});

export const CandidateTagSumOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  tagId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateTagSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagSumOrderByAggregateInput>>('CandidateTagSumOrderByAggregateInput').implement({
  fields: CandidateTagSumOrderByAggregateInputFields,
});

export const CustomFieldRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":CustomFieldWhereInput}),
  isNot: t.field({"required":false,"type":CustomFieldWhereInput}),
});
export const CustomFieldRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldRelationFilter>>('CustomFieldRelationFilter').implement({
  fields: CustomFieldRelationFilterFields,
});

export const CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  customFieldId: t.int({"required":true}),
});
export const CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInput>>('CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInput').implement({
  fields: CandidateCustomFieldCandidateIdCustomFieldIdCompoundUniqueInputFields,
});

export const CandidateCustomFieldCountOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCountOrderByAggregateInput>>('CandidateCustomFieldCountOrderByAggregateInput').implement({
  fields: CandidateCustomFieldCountOrderByAggregateInputFields,
});

export const CandidateCustomFieldAvgOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldAvgOrderByAggregateInput>>('CandidateCustomFieldAvgOrderByAggregateInput').implement({
  fields: CandidateCustomFieldAvgOrderByAggregateInputFields,
});

export const CandidateCustomFieldMaxOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldMaxOrderByAggregateInput>>('CandidateCustomFieldMaxOrderByAggregateInput').implement({
  fields: CandidateCustomFieldMaxOrderByAggregateInputFields,
});

export const CandidateCustomFieldMinOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
  value: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldMinOrderByAggregateInput>>('CandidateCustomFieldMinOrderByAggregateInput').implement({
  fields: CandidateCustomFieldMinOrderByAggregateInputFields,
});

export const CandidateCustomFieldSumOrderByAggregateInputFields = (t: any) => ({
  candidateId: t.field({"required":false,"type":SortOrder}),
  customFieldId: t.field({"required":false,"type":SortOrder}),
});
export const CandidateCustomFieldSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldSumOrderByAggregateInput>>('CandidateCustomFieldSumOrderByAggregateInput').implement({
  fields: CandidateCustomFieldSumOrderByAggregateInputFields,
});

export const CustomFieldCompanyIdKeyCompoundUniqueInputFields = (t: any) => ({
  companyId: t.string({"required":true}),
  key: t.string({"required":true}),
});
export const CustomFieldCompanyIdKeyCompoundUniqueInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCompanyIdKeyCompoundUniqueInput>>('CustomFieldCompanyIdKeyCompoundUniqueInput').implement({
  fields: CustomFieldCompanyIdKeyCompoundUniqueInputFields,
});

export const CustomFieldCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  defaultValue: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCountOrderByAggregateInput>>('CustomFieldCountOrderByAggregateInput').implement({
  fields: CustomFieldCountOrderByAggregateInputFields,
});

export const CustomFieldAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldAvgOrderByAggregateInput>>('CustomFieldAvgOrderByAggregateInput').implement({
  fields: CustomFieldAvgOrderByAggregateInputFields,
});

export const CustomFieldMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  defaultValue: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldMaxOrderByAggregateInput>>('CustomFieldMaxOrderByAggregateInput').implement({
  fields: CustomFieldMaxOrderByAggregateInputFields,
});

export const CustomFieldMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  type: t.field({"required":false,"type":SortOrder}),
  key: t.field({"required":false,"type":SortOrder}),
  defaultValue: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldMinOrderByAggregateInput>>('CustomFieldMinOrderByAggregateInput').implement({
  fields: CustomFieldMinOrderByAggregateInputFields,
});

export const CustomFieldSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
});
export const CustomFieldSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldSumOrderByAggregateInput>>('CustomFieldSumOrderByAggregateInput').implement({
  fields: CustomFieldSumOrderByAggregateInputFields,
});

export const EnumSCORE_TYPESFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":SCORE_TYPES}),
  in: t.field({"required":false,"type":[SCORE_TYPES]}),
  notIn: t.field({"required":false,"type":[SCORE_TYPES]}),
  not: t.field({"required":false,"type":SCORE_TYPES}),
});
export const EnumSCORE_TYPESFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumSCORE_TYPESFilter>>('EnumSCORE_TYPESFilter').implement({
  fields: EnumSCORE_TYPESFilterFields,
});

export const EventNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":EventWhereInput}),
  isNot: t.field({"required":false,"type":EventWhereInput}),
});
export const EventNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventNullableRelationFilter>>('EventNullableRelationFilter').implement({
  fields: EventNullableRelationFilterFields,
});

export const EvaluationQuestionListRelationFilterFields = (t: any) => ({
  every: t.field({"required":false,"type":EvaluationQuestionWhereInput}),
  some: t.field({"required":false,"type":EvaluationQuestionWhereInput}),
  none: t.field({"required":false,"type":EvaluationQuestionWhereInput}),
});
export const EvaluationQuestionListRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionListRelationFilter>>('EvaluationQuestionListRelationFilter').implement({
  fields: EvaluationQuestionListRelationFilterFields,
});

export const EvaluationQuestionOrderByRelationAggregateInputFields = (t: any) => ({
  _count: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionOrderByRelationAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionOrderByRelationAggregateInput>>('EvaluationQuestionOrderByRelationAggregateInput').implement({
  fields: EvaluationQuestionOrderByRelationAggregateInputFields,
});

export const EvaluationCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  isQuickEval: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  score: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCountOrderByAggregateInput>>('EvaluationCountOrderByAggregateInput').implement({
  fields: EvaluationCountOrderByAggregateInputFields,
});

export const EvaluationAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationAvgOrderByAggregateInput>>('EvaluationAvgOrderByAggregateInput').implement({
  fields: EvaluationAvgOrderByAggregateInputFields,
});

export const EvaluationMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  isQuickEval: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  score: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationMaxOrderByAggregateInput>>('EvaluationMaxOrderByAggregateInput').implement({
  fields: EvaluationMaxOrderByAggregateInputFields,
});

export const EvaluationMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  isQuickEval: t.field({"required":false,"type":SortOrder}),
  description: t.field({"required":false,"type":SortOrder}),
  score: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
  createdAt: t.field({"required":false,"type":SortOrder}),
  updatedAt: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationMinOrderByAggregateInput>>('EvaluationMinOrderByAggregateInput').implement({
  fields: EvaluationMinOrderByAggregateInputFields,
});

export const EvaluationSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  templateId: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
  eventId: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationSumOrderByAggregateInput>>('EvaluationSumOrderByAggregateInput').implement({
  fields: EvaluationSumOrderByAggregateInputFields,
});

export const EnumSCORE_TYPESWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":SCORE_TYPES}),
  in: t.field({"required":false,"type":[SCORE_TYPES]}),
  notIn: t.field({"required":false,"type":[SCORE_TYPES]}),
  not: t.field({"required":false,"type":SCORE_TYPES}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumSCORE_TYPESFilter}),
  _max: t.field({"required":false,"type":NestedEnumSCORE_TYPESFilter}),
});
export const EnumSCORE_TYPESWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumSCORE_TYPESWithAggregatesFilter>>('EnumSCORE_TYPESWithAggregatesFilter').implement({
  fields: EnumSCORE_TYPESWithAggregatesFilterFields,
});

export const EvaluationQuestionCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  settings: t.field({"required":false,"type":SortOrder}),
  question: t.field({"required":false,"type":SortOrder}),
  answer: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCountOrderByAggregateInput>>('EvaluationQuestionCountOrderByAggregateInput').implement({
  fields: EvaluationQuestionCountOrderByAggregateInputFields,
});

export const EvaluationQuestionAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionAvgOrderByAggregateInput>>('EvaluationQuestionAvgOrderByAggregateInput').implement({
  fields: EvaluationQuestionAvgOrderByAggregateInputFields,
});

export const EvaluationQuestionMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  question: t.field({"required":false,"type":SortOrder}),
  answer: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionMaxOrderByAggregateInput>>('EvaluationQuestionMaxOrderByAggregateInput').implement({
  fields: EvaluationQuestionMaxOrderByAggregateInputFields,
});

export const EvaluationQuestionMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
  inputType: t.field({"required":false,"type":SortOrder}),
  question: t.field({"required":false,"type":SortOrder}),
  answer: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionMinOrderByAggregateInput>>('EvaluationQuestionMinOrderByAggregateInput').implement({
  fields: EvaluationQuestionMinOrderByAggregateInputFields,
});

export const EvaluationQuestionSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  evaluationId: t.field({"required":false,"type":SortOrder}),
});
export const EvaluationQuestionSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionSumOrderByAggregateInput>>('EvaluationQuestionSumOrderByAggregateInput').implement({
  fields: EvaluationQuestionSumOrderByAggregateInputFields,
});

export const SharedCandidateLinkCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  visibleSections: t.field({"required":false,"type":SortOrder}),
  editModelSections: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  expiration: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCountOrderByAggregateInput>>('SharedCandidateLinkCountOrderByAggregateInput').implement({
  fields: SharedCandidateLinkCountOrderByAggregateInputFields,
});

export const SharedCandidateLinkAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkAvgOrderByAggregateInput>>('SharedCandidateLinkAvgOrderByAggregateInput').implement({
  fields: SharedCandidateLinkAvgOrderByAggregateInputFields,
});

export const SharedCandidateLinkMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  expiration: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkMaxOrderByAggregateInput>>('SharedCandidateLinkMaxOrderByAggregateInput').implement({
  fields: SharedCandidateLinkMaxOrderByAggregateInputFields,
});

export const SharedCandidateLinkMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  link: t.field({"required":false,"type":SortOrder}),
  expiration: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkMinOrderByAggregateInput>>('SharedCandidateLinkMinOrderByAggregateInput').implement({
  fields: SharedCandidateLinkMinOrderByAggregateInputFields,
});

export const SharedCandidateLinkSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const SharedCandidateLinkSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkSumOrderByAggregateInput>>('SharedCandidateLinkSumOrderByAggregateInput').implement({
  fields: SharedCandidateLinkSumOrderByAggregateInputFields,
});

export const TaskCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  dueDate: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TaskCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCountOrderByAggregateInput>>('TaskCountOrderByAggregateInput').implement({
  fields: TaskCountOrderByAggregateInputFields,
});

export const TaskAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TaskAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskAvgOrderByAggregateInput>>('TaskAvgOrderByAggregateInput').implement({
  fields: TaskAvgOrderByAggregateInputFields,
});

export const TaskMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  dueDate: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMaxOrderByAggregateInput>>('TaskMaxOrderByAggregateInput').implement({
  fields: TaskMaxOrderByAggregateInputFields,
});

export const TaskMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  companyId: t.field({"required":false,"type":SortOrder}),
  name: t.field({"required":false,"type":SortOrder}),
  status: t.field({"required":false,"type":SortOrder}),
  dueDate: t.field({"required":false,"type":SortOrder}),
  note: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMinOrderByAggregateInput>>('TaskMinOrderByAggregateInput').implement({
  fields: TaskMinOrderByAggregateInputFields,
});

export const TaskSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
});
export const TaskSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskSumOrderByAggregateInput>>('TaskSumOrderByAggregateInput').implement({
  fields: TaskSumOrderByAggregateInputFields,
});

export const TaskRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TaskWhereInput}),
  isNot: t.field({"required":false,"type":TaskWhereInput}),
});
export const TaskRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskRelationFilter>>('TaskRelationFilter').implement({
  fields: TaskRelationFilterFields,
});

export const TaskMemberCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCountOrderByAggregateInput>>('TaskMemberCountOrderByAggregateInput').implement({
  fields: TaskMemberCountOrderByAggregateInputFields,
});

export const TaskMemberAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberAvgOrderByAggregateInput>>('TaskMemberAvgOrderByAggregateInput').implement({
  fields: TaskMemberAvgOrderByAggregateInputFields,
});

export const TaskMemberMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberMaxOrderByAggregateInput>>('TaskMemberMaxOrderByAggregateInput').implement({
  fields: TaskMemberMaxOrderByAggregateInputFields,
});

export const TaskMemberMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberMinOrderByAggregateInput>>('TaskMemberMinOrderByAggregateInput').implement({
  fields: TaskMemberMinOrderByAggregateInputFields,
});

export const TaskMemberSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  taskId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const TaskMemberSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberSumOrderByAggregateInput>>('TaskMemberSumOrderByAggregateInput').implement({
  fields: TaskMemberSumOrderByAggregateInputFields,
});

export const TalentPoolNullableRelationFilterFields = (t: any) => ({
  is: t.field({"required":false,"type":TalentPoolWhereInput}),
  isNot: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolNullableRelationFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolNullableRelationFilter>>('TalentPoolNullableRelationFilter').implement({
  fields: TalentPoolNullableRelationFilterFields,
});

export const FollowCountOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const FollowCountOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCountOrderByAggregateInput>>('FollowCountOrderByAggregateInput').implement({
  fields: FollowCountOrderByAggregateInputFields,
});

export const FollowAvgOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const FollowAvgOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowAvgOrderByAggregateInput>>('FollowAvgOrderByAggregateInput').implement({
  fields: FollowAvgOrderByAggregateInputFields,
});

export const FollowMaxOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const FollowMaxOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowMaxOrderByAggregateInput>>('FollowMaxOrderByAggregateInput').implement({
  fields: FollowMaxOrderByAggregateInputFields,
});

export const FollowMinOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const FollowMinOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowMinOrderByAggregateInput>>('FollowMinOrderByAggregateInput').implement({
  fields: FollowMinOrderByAggregateInputFields,
});

export const FollowSumOrderByAggregateInputFields = (t: any) => ({
  id: t.field({"required":false,"type":SortOrder}),
  offerId: t.field({"required":false,"type":SortOrder}),
  candidateId: t.field({"required":false,"type":SortOrder}),
  talentPoolId: t.field({"required":false,"type":SortOrder}),
  teamMemberId: t.field({"required":false,"type":SortOrder}),
});
export const FollowSumOrderByAggregateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowSumOrderByAggregateInput>>('FollowSumOrderByAggregateInput').implement({
  fields: FollowSumOrderByAggregateInputFields,
});

export const UserCreatefeatureDiscoveryInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const UserCreatefeatureDiscoveryInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreatefeatureDiscoveryInput>>('UserCreatefeatureDiscoveryInput').implement({
  fields: UserCreatefeatureDiscoveryInputFields,
});

export const UserCreateemailProvidersInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const UserCreateemailProvidersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateemailProvidersInput>>('UserCreateemailProvidersInput').implement({
  fields: UserCreateemailProvidersInputFields,
});

export const AttachmentCreateNestedOneWithoutUserProfilePhotoInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutUserProfilePhotoInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutUserProfilePhotoInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutUserProfilePhotoInput>>('AttachmentCreateNestedOneWithoutUserProfilePhotoInput').implement({
  fields: AttachmentCreateNestedOneWithoutUserProfilePhotoInputFields,
});

export const AccountCreateNestedManyWithoutUserInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AccountCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[AccountCreateOrConnectWithoutUserInput]}),
  createMany: t.field({"required":false,"type":AccountCreateManyUserInputEnvelope}),
  connect: t.field({"required":false,"type":[AccountWhereUniqueInput]}),
});
export const AccountCreateNestedManyWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateNestedManyWithoutUserInput>>('AccountCreateNestedManyWithoutUserInput').implement({
  fields: AccountCreateNestedManyWithoutUserInputFields,
});

export const SessionCreateNestedManyWithoutUserInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[SessionCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[SessionCreateOrConnectWithoutUserInput]}),
  createMany: t.field({"required":false,"type":SessionCreateManyUserInputEnvelope}),
  connect: t.field({"required":false,"type":[SessionWhereUniqueInput]}),
});
export const SessionCreateNestedManyWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateNestedManyWithoutUserInput>>('SessionCreateNestedManyWithoutUserInput').implement({
  fields: SessionCreateNestedManyWithoutUserInputFields,
});

export const HiringRoleCreateNestedManyWithoutUserInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutUserInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyUserInputEnvelope}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
});
export const HiringRoleCreateNestedManyWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedManyWithoutUserInput>>('HiringRoleCreateNestedManyWithoutUserInput').implement({
  fields: HiringRoleCreateNestedManyWithoutUserInputFields,
});

export const CompanyCreateNestedManyWithoutOwnerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CompanyCreateWithoutOwnerInput]}),
  connectOrCreate: t.field({"required":false,"type":[CompanyCreateOrConnectWithoutOwnerInput]}),
  createMany: t.field({"required":false,"type":CompanyCreateManyOwnerInputEnvelope}),
  connect: t.field({"required":false,"type":[CompanyWhereUniqueInput]}),
});
export const CompanyCreateNestedManyWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedManyWithoutOwnerInput>>('CompanyCreateNestedManyWithoutOwnerInput').implement({
  fields: CompanyCreateNestedManyWithoutOwnerInputFields,
});

export const StringFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.string({"required":false}),
});
export const StringFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StringFieldUpdateOperationsInput>>('StringFieldUpdateOperationsInput').implement({
  fields: StringFieldUpdateOperationsInputFields,
});

export const NullableStringFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.string({"required":false}),
});
export const NullableStringFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NullableStringFieldUpdateOperationsInput>>('NullableStringFieldUpdateOperationsInput').implement({
  fields: NullableStringFieldUpdateOperationsInputFields,
});

export const NullableDateTimeFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":DateTime}),
});
export const NullableDateTimeFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NullableDateTimeFieldUpdateOperationsInput>>('NullableDateTimeFieldUpdateOperationsInput').implement({
  fields: NullableDateTimeFieldUpdateOperationsInputFields,
});

export const BoolFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.boolean({"required":false}),
});
export const BoolFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.BoolFieldUpdateOperationsInput>>('BoolFieldUpdateOperationsInput').implement({
  fields: BoolFieldUpdateOperationsInputFields,
});

export const UserUpdatefeatureDiscoveryInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const UserUpdatefeatureDiscoveryInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdatefeatureDiscoveryInput>>('UserUpdatefeatureDiscoveryInput').implement({
  fields: UserUpdatefeatureDiscoveryInputFields,
});

export const UserUpdateemailProvidersInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const UserUpdateemailProvidersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateemailProvidersInput>>('UserUpdateemailProvidersInput').implement({
  fields: UserUpdateemailProvidersInputFields,
});

export const DateTimeFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":DateTime}),
});
export const DateTimeFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DateTimeFieldUpdateOperationsInput>>('DateTimeFieldUpdateOperationsInput').implement({
  fields: DateTimeFieldUpdateOperationsInputFields,
});

export const EnumUserRolesFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":UserRoles}),
});
export const EnumUserRolesFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumUserRolesFieldUpdateOperationsInput>>('EnumUserRolesFieldUpdateOperationsInput').implement({
  fields: EnumUserRolesFieldUpdateOperationsInputFields,
});

export const AttachmentUpdateOneWithoutUserProfilePhotoNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutUserProfilePhotoInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutUserProfilePhotoInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutUserProfilePhotoInput}),
  disconnect: t.field({"required":false,"type":AttachmentWhereInput}),
  delete: t.field({"required":false,"type":AttachmentWhereInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInput}),
});
export const AttachmentUpdateOneWithoutUserProfilePhotoNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneWithoutUserProfilePhotoNestedInput>>('AttachmentUpdateOneWithoutUserProfilePhotoNestedInput').implement({
  fields: AttachmentUpdateOneWithoutUserProfilePhotoNestedInputFields,
});

export const AccountUpdateManyWithoutUserNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AccountCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[AccountCreateOrConnectWithoutUserInput]}),
  upsert: t.field({"required":false,"type":[AccountUpsertWithWhereUniqueWithoutUserInput]}),
  createMany: t.field({"required":false,"type":AccountCreateManyUserInputEnvelope}),
  set: t.field({"required":false,"type":[AccountWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AccountWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AccountWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AccountWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AccountUpdateWithWhereUniqueWithoutUserInput]}),
  updateMany: t.field({"required":false,"type":[AccountUpdateManyWithWhereWithoutUserInput]}),
  deleteMany: t.field({"required":false,"type":[AccountScalarWhereInput]}),
});
export const AccountUpdateManyWithoutUserNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateManyWithoutUserNestedInput>>('AccountUpdateManyWithoutUserNestedInput').implement({
  fields: AccountUpdateManyWithoutUserNestedInputFields,
});

export const SessionUpdateManyWithoutUserNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[SessionCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[SessionCreateOrConnectWithoutUserInput]}),
  upsert: t.field({"required":false,"type":[SessionUpsertWithWhereUniqueWithoutUserInput]}),
  createMany: t.field({"required":false,"type":SessionCreateManyUserInputEnvelope}),
  set: t.field({"required":false,"type":[SessionWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[SessionWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[SessionWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[SessionWhereUniqueInput]}),
  update: t.field({"required":false,"type":[SessionUpdateWithWhereUniqueWithoutUserInput]}),
  updateMany: t.field({"required":false,"type":[SessionUpdateManyWithWhereWithoutUserInput]}),
  deleteMany: t.field({"required":false,"type":[SessionScalarWhereInput]}),
});
export const SessionUpdateManyWithoutUserNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateManyWithoutUserNestedInput>>('SessionUpdateManyWithoutUserNestedInput').implement({
  fields: SessionUpdateManyWithoutUserNestedInputFields,
});

export const HiringRoleUpdateManyWithoutUserNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutUserInput]}),
  upsert: t.field({"required":false,"type":[HiringRoleUpsertWithWhereUniqueWithoutUserInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyUserInputEnvelope}),
  set: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[HiringRoleUpdateWithWhereUniqueWithoutUserInput]}),
  updateMany: t.field({"required":false,"type":[HiringRoleUpdateManyWithWhereWithoutUserInput]}),
  deleteMany: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
});
export const HiringRoleUpdateManyWithoutUserNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithoutUserNestedInput>>('HiringRoleUpdateManyWithoutUserNestedInput').implement({
  fields: HiringRoleUpdateManyWithoutUserNestedInputFields,
});

export const CompanyUpdateManyWithoutOwnerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CompanyCreateWithoutOwnerInput]}),
  connectOrCreate: t.field({"required":false,"type":[CompanyCreateOrConnectWithoutOwnerInput]}),
  upsert: t.field({"required":false,"type":[CompanyUpsertWithWhereUniqueWithoutOwnerInput]}),
  createMany: t.field({"required":false,"type":CompanyCreateManyOwnerInputEnvelope}),
  set: t.field({"required":false,"type":[CompanyWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CompanyWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CompanyWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CompanyWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CompanyUpdateWithWhereUniqueWithoutOwnerInput]}),
  updateMany: t.field({"required":false,"type":[CompanyUpdateManyWithWhereWithoutOwnerInput]}),
  deleteMany: t.field({"required":false,"type":[CompanyScalarWhereInput]}),
});
export const CompanyUpdateManyWithoutOwnerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateManyWithoutOwnerNestedInput>>('CompanyUpdateManyWithoutOwnerNestedInput').implement({
  fields: CompanyUpdateManyWithoutOwnerNestedInputFields,
});

export const NullableIntFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.int({"required":false}),
  increment: t.int({"required":false}),
  decrement: t.int({"required":false}),
  multiply: t.int({"required":false}),
  divide: t.int({"required":false}),
});
export const NullableIntFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NullableIntFieldUpdateOperationsInput>>('NullableIntFieldUpdateOperationsInput').implement({
  fields: NullableIntFieldUpdateOperationsInputFields,
});

export const UserCreateNestedOneWithoutAccountsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutAccountsInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutAccountsInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
});
export const UserCreateNestedOneWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateNestedOneWithoutAccountsInput>>('UserCreateNestedOneWithoutAccountsInput').implement({
  fields: UserCreateNestedOneWithoutAccountsInputFields,
});

export const UserUpdateOneRequiredWithoutAccountsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutAccountsInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutAccountsInput}),
  upsert: t.field({"required":false,"type":UserUpsertWithoutAccountsInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
  update: t.field({"required":false,"type":UserUpdateToOneWithWhereWithoutAccountsInput}),
});
export const UserUpdateOneRequiredWithoutAccountsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateOneRequiredWithoutAccountsNestedInput>>('UserUpdateOneRequiredWithoutAccountsNestedInput').implement({
  fields: UserUpdateOneRequiredWithoutAccountsNestedInputFields,
});

export const UserCreateNestedOneWithoutSessionsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutSessionsInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutSessionsInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
});
export const UserCreateNestedOneWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateNestedOneWithoutSessionsInput>>('UserCreateNestedOneWithoutSessionsInput').implement({
  fields: UserCreateNestedOneWithoutSessionsInputFields,
});

export const UserUpdateOneRequiredWithoutSessionsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutSessionsInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutSessionsInput}),
  upsert: t.field({"required":false,"type":UserUpsertWithoutSessionsInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
  update: t.field({"required":false,"type":UserUpdateToOneWithWhereWithoutSessionsInput}),
});
export const UserUpdateOneRequiredWithoutSessionsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateOneRequiredWithoutSessionsNestedInput>>('UserUpdateOneRequiredWithoutSessionsNestedInput').implement({
  fields: UserUpdateOneRequiredWithoutSessionsNestedInputFields,
});

export const UserCreateNestedOneWithoutPhotoInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutPhotoInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutPhotoInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
});
export const UserCreateNestedOneWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateNestedOneWithoutPhotoInput>>('UserCreateNestedOneWithoutPhotoInput').implement({
  fields: UserCreateNestedOneWithoutPhotoInputFields,
});

export const CandidateCreateNestedOneWithoutCvInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCvInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCvInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutCvInput>>('CandidateCreateNestedOneWithoutCvInput').implement({
  fields: CandidateCreateNestedOneWithoutCvInputFields,
});

export const CandidateCreateNestedOneWithoutAvatarInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutAvatarInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutAvatarInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutAvatarInput>>('CandidateCreateNestedOneWithoutAvatarInput').implement({
  fields: CandidateCreateNestedOneWithoutAvatarInputFields,
});

export const CandidateCreateNestedOneWithoutCoverLetterInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCoverLetterInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCoverLetterInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutCoverLetterInput>>('CandidateCreateNestedOneWithoutCoverLetterInput').implement({
  fields: CandidateCreateNestedOneWithoutCoverLetterInputFields,
});

export const CompanyCreateNestedOneWithoutLogoInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutLogoInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutLogoInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutLogoInput>>('CompanyCreateNestedOneWithoutLogoInput').implement({
  fields: CompanyCreateNestedOneWithoutLogoInputFields,
});

export const HiringRoleCreateNestedOneWithoutAttachmentsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutAttachmentsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutAttachmentsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutAttachmentsInput>>('HiringRoleCreateNestedOneWithoutAttachmentsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutAttachmentsInputFields,
});

export const OfferFileCreateNestedManyWithoutAttachmentInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferFileCreateWithoutAttachmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferFileCreateOrConnectWithoutAttachmentInput]}),
  createMany: t.field({"required":false,"type":OfferFileCreateManyAttachmentInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
});
export const OfferFileCreateNestedManyWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateNestedManyWithoutAttachmentInput>>('OfferFileCreateNestedManyWithoutAttachmentInput').implement({
  fields: OfferFileCreateNestedManyWithoutAttachmentInputFields,
});

export const TalentPoolFileCreateNestedManyWithoutAttachmentInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolFileCreateWithoutAttachmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolFileCreateOrConnectWithoutAttachmentInput]}),
  createMany: t.field({"required":false,"type":TalentPoolFileCreateManyAttachmentInputEnvelope}),
  connect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
});
export const TalentPoolFileCreateNestedManyWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateNestedManyWithoutAttachmentInput>>('TalentPoolFileCreateNestedManyWithoutAttachmentInput').implement({
  fields: TalentPoolFileCreateNestedManyWithoutAttachmentInputFields,
});

export const CompanyCreateNestedOneWithoutAttachmentsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutAttachmentsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutAttachmentsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutAttachmentsInput>>('CompanyCreateNestedOneWithoutAttachmentsInput').implement({
  fields: CompanyCreateNestedOneWithoutAttachmentsInputFields,
});

export const UserUpdateOneWithoutPhotoNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutPhotoInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutPhotoInput}),
  upsert: t.field({"required":false,"type":UserUpsertWithoutPhotoInput}),
  disconnect: t.field({"required":false,"type":UserWhereInput}),
  delete: t.field({"required":false,"type":UserWhereInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
  update: t.field({"required":false,"type":UserUpdateToOneWithWhereWithoutPhotoInput}),
});
export const UserUpdateOneWithoutPhotoNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateOneWithoutPhotoNestedInput>>('UserUpdateOneWithoutPhotoNestedInput').implement({
  fields: UserUpdateOneWithoutPhotoNestedInputFields,
});

export const CandidateUpdateOneWithoutCvNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCvInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCvInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutCvInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutCvInput}),
});
export const CandidateUpdateOneWithoutCvNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutCvNestedInput>>('CandidateUpdateOneWithoutCvNestedInput').implement({
  fields: CandidateUpdateOneWithoutCvNestedInputFields,
});

export const CandidateUpdateOneWithoutAvatarNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutAvatarInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutAvatarInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutAvatarInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutAvatarInput}),
});
export const CandidateUpdateOneWithoutAvatarNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutAvatarNestedInput>>('CandidateUpdateOneWithoutAvatarNestedInput').implement({
  fields: CandidateUpdateOneWithoutAvatarNestedInputFields,
});

export const CandidateUpdateOneWithoutCoverLetterNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCoverLetterInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCoverLetterInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutCoverLetterInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutCoverLetterInput}),
});
export const CandidateUpdateOneWithoutCoverLetterNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutCoverLetterNestedInput>>('CandidateUpdateOneWithoutCoverLetterNestedInput').implement({
  fields: CandidateUpdateOneWithoutCoverLetterNestedInputFields,
});

export const CompanyUpdateOneWithoutLogoNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutLogoInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutLogoInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutLogoInput}),
  disconnect: t.field({"required":false,"type":CompanyWhereInput}),
  delete: t.field({"required":false,"type":CompanyWhereInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutLogoInput}),
});
export const CompanyUpdateOneWithoutLogoNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneWithoutLogoNestedInput>>('CompanyUpdateOneWithoutLogoNestedInput').implement({
  fields: CompanyUpdateOneWithoutLogoNestedInputFields,
});

export const HiringRoleUpdateOneWithoutAttachmentsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutAttachmentsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutAttachmentsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutAttachmentsInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutAttachmentsInput}),
});
export const HiringRoleUpdateOneWithoutAttachmentsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutAttachmentsNestedInput>>('HiringRoleUpdateOneWithoutAttachmentsNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutAttachmentsNestedInputFields,
});

export const OfferFileUpdateManyWithoutAttachmentNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferFileCreateWithoutAttachmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferFileCreateOrConnectWithoutAttachmentInput]}),
  upsert: t.field({"required":false,"type":[OfferFileUpsertWithWhereUniqueWithoutAttachmentInput]}),
  createMany: t.field({"required":false,"type":OfferFileCreateManyAttachmentInputEnvelope}),
  set: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferFileUpdateWithWhereUniqueWithoutAttachmentInput]}),
  updateMany: t.field({"required":false,"type":[OfferFileUpdateManyWithWhereWithoutAttachmentInput]}),
  deleteMany: t.field({"required":false,"type":[OfferFileScalarWhereInput]}),
});
export const OfferFileUpdateManyWithoutAttachmentNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateManyWithoutAttachmentNestedInput>>('OfferFileUpdateManyWithoutAttachmentNestedInput').implement({
  fields: OfferFileUpdateManyWithoutAttachmentNestedInputFields,
});

export const TalentPoolFileUpdateManyWithoutAttachmentNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolFileCreateWithoutAttachmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolFileCreateOrConnectWithoutAttachmentInput]}),
  upsert: t.field({"required":false,"type":[TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInput]}),
  createMany: t.field({"required":false,"type":TalentPoolFileCreateManyAttachmentInputEnvelope}),
  set: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInput]}),
  updateMany: t.field({"required":false,"type":[TalentPoolFileUpdateManyWithWhereWithoutAttachmentInput]}),
  deleteMany: t.field({"required":false,"type":[TalentPoolFileScalarWhereInput]}),
});
export const TalentPoolFileUpdateManyWithoutAttachmentNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateManyWithoutAttachmentNestedInput>>('TalentPoolFileUpdateManyWithoutAttachmentNestedInput').implement({
  fields: TalentPoolFileUpdateManyWithoutAttachmentNestedInputFields,
});

export const CompanyUpdateOneRequiredWithoutAttachmentsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutAttachmentsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutAttachmentsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutAttachmentsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutAttachmentsInput}),
});
export const CompanyUpdateOneRequiredWithoutAttachmentsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutAttachmentsNestedInput>>('CompanyUpdateOneRequiredWithoutAttachmentsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutAttachmentsNestedInputFields,
});

export const IntFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.int({"required":false}),
  increment: t.int({"required":false}),
  decrement: t.int({"required":false}),
  multiply: t.int({"required":false}),
  divide: t.int({"required":false}),
});
export const IntFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.IntFieldUpdateOperationsInput>>('IntFieldUpdateOperationsInput').implement({
  fields: IntFieldUpdateOperationsInputFields,
});

export const HiringRoleCreateextraAbilitiesInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const HiringRoleCreateextraAbilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateextraAbilitiesInput>>('HiringRoleCreateextraAbilitiesInput').implement({
  fields: HiringRoleCreateextraAbilitiesInputFields,
});

export const UserCreateNestedOneWithoutHiringRolesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
});
export const UserCreateNestedOneWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateNestedOneWithoutHiringRolesInput>>('UserCreateNestedOneWithoutHiringRolesInput').implement({
  fields: UserCreateNestedOneWithoutHiringRolesInputFields,
});

export const RoleCreateNestedOneWithoutHiringRolesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
});
export const RoleCreateNestedOneWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateNestedOneWithoutHiringRolesInput>>('RoleCreateNestedOneWithoutHiringRolesInput').implement({
  fields: RoleCreateNestedOneWithoutHiringRolesInputFields,
});

export const CompanyCreateNestedOneWithoutHiringRolesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutHiringRolesInput>>('CompanyCreateNestedOneWithoutHiringRolesInput').implement({
  fields: CompanyCreateNestedOneWithoutHiringRolesInputFields,
});

export const AttachmentCreateNestedManyWithoutUploaderInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AttachmentCreateWithoutUploaderInput]}),
  connectOrCreate: t.field({"required":false,"type":[AttachmentCreateOrConnectWithoutUploaderInput]}),
  createMany: t.field({"required":false,"type":AttachmentCreateManyUploaderInputEnvelope}),
  connect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
});
export const AttachmentCreateNestedManyWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedManyWithoutUploaderInput>>('AttachmentCreateNestedManyWithoutUploaderInput').implement({
  fields: AttachmentCreateNestedManyWithoutUploaderInputFields,
});

export const AuditLogCreateNestedManyWithoutUserInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutUserInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyUserInputEnvelope}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
});
export const AuditLogCreateNestedManyWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateNestedManyWithoutUserInput>>('AuditLogCreateNestedManyWithoutUserInput').implement({
  fields: AuditLogCreateNestedManyWithoutUserInputFields,
});

export const EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleInterviewerCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EventScheduleInterviewerCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
});
export const EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput>>('EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInputFields,
});

export const EventCreateNestedManyWithoutCreatedByInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCreatedByInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCreatedByInput]}),
  createMany: t.field({"required":false,"type":EventCreateManyCreatedByInputEnvelope}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
});
export const EventCreateNestedManyWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedManyWithoutCreatedByInput>>('EventCreateNestedManyWithoutCreatedByInput').implement({
  fields: EventCreateNestedManyWithoutCreatedByInputFields,
});

export const OfferCreateNestedOneWithoutRecruiterInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutRecruiterInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutRecruiterInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutRecruiterInput>>('OfferCreateNestedOneWithoutRecruiterInput').implement({
  fields: OfferCreateNestedOneWithoutRecruiterInputFields,
});

export const OfferCreateNestedOneWithoutHiringManagerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutHiringManagerInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutHiringManagerInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutHiringManagerInput>>('OfferCreateNestedOneWithoutHiringManagerInput').implement({
  fields: OfferCreateNestedOneWithoutHiringManagerInputFields,
});

export const MembershipCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
});
export const MembershipCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateNestedManyWithoutTeamMemberInput>>('MembershipCreateNestedManyWithoutTeamMemberInput').implement({
  fields: MembershipCreateNestedManyWithoutTeamMemberInputFields,
});

export const StageVisibilityCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
});
export const StageVisibilityCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateNestedManyWithoutTeamMemberInput>>('StageVisibilityCreateNestedManyWithoutTeamMemberInput').implement({
  fields: StageVisibilityCreateNestedManyWithoutTeamMemberInputFields,
});

export const CandidateCreateNestedManyWithoutHiredByInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutHiredByInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutHiredByInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyHiredByInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
});
export const CandidateCreateNestedManyWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedManyWithoutHiredByInput>>('CandidateCreateNestedManyWithoutHiredByInput').implement({
  fields: CandidateCreateNestedManyWithoutHiredByInputFields,
});

export const EvaluationCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
});
export const EvaluationCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedManyWithoutTeamMemberInput>>('EvaluationCreateNestedManyWithoutTeamMemberInput').implement({
  fields: EvaluationCreateNestedManyWithoutTeamMemberInputFields,
});

export const TaskMemberCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskMemberCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskMemberCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":TaskMemberCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
});
export const TaskMemberCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateNestedManyWithoutTeamMemberInput>>('TaskMemberCreateNestedManyWithoutTeamMemberInput').implement({
  fields: TaskMemberCreateNestedManyWithoutTeamMemberInputFields,
});

export const FollowCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
});
export const FollowCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateNestedManyWithoutTeamMemberInput>>('FollowCreateNestedManyWithoutTeamMemberInput').implement({
  fields: FollowCreateNestedManyWithoutTeamMemberInputFields,
});

export const EventCreateNestedManyWithoutInterviewersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutInterviewersInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutInterviewersInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
});
export const EventCreateNestedManyWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedManyWithoutInterviewersInput>>('EventCreateNestedManyWithoutInterviewersInput').implement({
  fields: EventCreateNestedManyWithoutInterviewersInputFields,
});

export const EventInterviewerCreateNestedManyWithoutTeamMemberInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventInterviewerCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventInterviewerCreateOrConnectWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EventInterviewerCreateManyTeamMemberInputEnvelope}),
  connect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
});
export const EventInterviewerCreateNestedManyWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateNestedManyWithoutTeamMemberInput>>('EventInterviewerCreateNestedManyWithoutTeamMemberInput').implement({
  fields: EventInterviewerCreateNestedManyWithoutTeamMemberInputFields,
});

export const HiringRoleUpdateextraAbilitiesInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const HiringRoleUpdateextraAbilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateextraAbilitiesInput>>('HiringRoleUpdateextraAbilitiesInput').implement({
  fields: HiringRoleUpdateextraAbilitiesInputFields,
});

export const UserUpdateOneRequiredWithoutHiringRolesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutHiringRolesInput}),
  upsert: t.field({"required":false,"type":UserUpsertWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
  update: t.field({"required":false,"type":UserUpdateToOneWithWhereWithoutHiringRolesInput}),
});
export const UserUpdateOneRequiredWithoutHiringRolesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateOneRequiredWithoutHiringRolesNestedInput>>('UserUpdateOneRequiredWithoutHiringRolesNestedInput').implement({
  fields: UserUpdateOneRequiredWithoutHiringRolesNestedInputFields,
});

export const RoleUpdateOneRequiredWithoutHiringRolesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutHiringRolesInput}),
  upsert: t.field({"required":false,"type":RoleUpsertWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
  update: t.field({"required":false,"type":RoleUpdateToOneWithWhereWithoutHiringRolesInput}),
});
export const RoleUpdateOneRequiredWithoutHiringRolesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateOneRequiredWithoutHiringRolesNestedInput>>('RoleUpdateOneRequiredWithoutHiringRolesNestedInput').implement({
  fields: RoleUpdateOneRequiredWithoutHiringRolesNestedInputFields,
});

export const CompanyUpdateOneRequiredWithoutHiringRolesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutHiringRolesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutHiringRolesInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutHiringRolesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutHiringRolesInput}),
});
export const CompanyUpdateOneRequiredWithoutHiringRolesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutHiringRolesNestedInput>>('CompanyUpdateOneRequiredWithoutHiringRolesNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutHiringRolesNestedInputFields,
});

export const AttachmentUpdateManyWithoutUploaderNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AttachmentCreateWithoutUploaderInput]}),
  connectOrCreate: t.field({"required":false,"type":[AttachmentCreateOrConnectWithoutUploaderInput]}),
  upsert: t.field({"required":false,"type":[AttachmentUpsertWithWhereUniqueWithoutUploaderInput]}),
  createMany: t.field({"required":false,"type":AttachmentCreateManyUploaderInputEnvelope}),
  set: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AttachmentUpdateWithWhereUniqueWithoutUploaderInput]}),
  updateMany: t.field({"required":false,"type":[AttachmentUpdateManyWithWhereWithoutUploaderInput]}),
  deleteMany: t.field({"required":false,"type":[AttachmentScalarWhereInput]}),
});
export const AttachmentUpdateManyWithoutUploaderNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateManyWithoutUploaderNestedInput>>('AttachmentUpdateManyWithoutUploaderNestedInput').implement({
  fields: AttachmentUpdateManyWithoutUploaderNestedInputFields,
});

export const AuditLogUpdateManyWithoutUserNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutUserInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutUserInput]}),
  upsert: t.field({"required":false,"type":[AuditLogUpsertWithWhereUniqueWithoutUserInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyUserInputEnvelope}),
  set: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AuditLogUpdateWithWhereUniqueWithoutUserInput]}),
  updateMany: t.field({"required":false,"type":[AuditLogUpdateManyWithWhereWithoutUserInput]}),
  deleteMany: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
});
export const AuditLogUpdateManyWithoutUserNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithoutUserNestedInput>>('AuditLogUpdateManyWithoutUserNestedInput').implement({
  fields: AuditLogUpdateManyWithoutUserNestedInputFields,
});

export const EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleInterviewerCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EventScheduleInterviewerCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereInput]}),
});
export const EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput>>('EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInputFields,
});

export const EventUpdateManyWithoutCreatedByNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCreatedByInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCreatedByInput]}),
  upsert: t.field({"required":false,"type":[EventUpsertWithWhereUniqueWithoutCreatedByInput]}),
  createMany: t.field({"required":false,"type":EventCreateManyCreatedByInputEnvelope}),
  set: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventUpdateWithWhereUniqueWithoutCreatedByInput]}),
  updateMany: t.field({"required":false,"type":[EventUpdateManyWithWhereWithoutCreatedByInput]}),
  deleteMany: t.field({"required":false,"type":[EventScalarWhereInput]}),
});
export const EventUpdateManyWithoutCreatedByNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithoutCreatedByNestedInput>>('EventUpdateManyWithoutCreatedByNestedInput').implement({
  fields: EventUpdateManyWithoutCreatedByNestedInputFields,
});

export const OfferUpdateOneWithoutRecruiterNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutRecruiterInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutRecruiterInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutRecruiterInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutRecruiterInput}),
});
export const OfferUpdateOneWithoutRecruiterNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutRecruiterNestedInput>>('OfferUpdateOneWithoutRecruiterNestedInput').implement({
  fields: OfferUpdateOneWithoutRecruiterNestedInputFields,
});

export const OfferUpdateOneWithoutHiringManagerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutHiringManagerInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutHiringManagerInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutHiringManagerInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutHiringManagerInput}),
});
export const OfferUpdateOneWithoutHiringManagerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutHiringManagerNestedInput>>('OfferUpdateOneWithoutHiringManagerNestedInput').implement({
  fields: OfferUpdateOneWithoutHiringManagerNestedInputFields,
});

export const MembershipUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[MembershipUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MembershipUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[MembershipUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
});
export const MembershipUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithoutTeamMemberNestedInput>>('MembershipUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: MembershipUpdateManyWithoutTeamMemberNestedInputFields,
});

export const StageVisibilityUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  update: t.field({"required":false,"type":[StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[StageVisibilityUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
});
export const StageVisibilityUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithoutTeamMemberNestedInput>>('StageVisibilityUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: StageVisibilityUpdateManyWithoutTeamMemberNestedInputFields,
});

export const CandidateUpdateManyWithoutHiredByNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutHiredByInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutHiredByInput]}),
  upsert: t.field({"required":false,"type":[CandidateUpsertWithWhereUniqueWithoutHiredByInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyHiredByInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateUpdateWithWhereUniqueWithoutHiredByInput]}),
  updateMany: t.field({"required":false,"type":[CandidateUpdateManyWithWhereWithoutHiredByInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
});
export const CandidateUpdateManyWithoutHiredByNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithoutHiredByNestedInput>>('CandidateUpdateManyWithoutHiredByNestedInput').implement({
  fields: CandidateUpdateManyWithoutHiredByNestedInputFields,
});

export const EvaluationUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[EvaluationUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
});
export const EvaluationUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithoutTeamMemberNestedInput>>('EvaluationUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: EvaluationUpdateManyWithoutTeamMemberNestedInputFields,
});

export const TaskMemberUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskMemberCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskMemberCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":TaskMemberCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[TaskMemberUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[TaskMemberScalarWhereInput]}),
});
export const TaskMemberUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateManyWithoutTeamMemberNestedInput>>('TaskMemberUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: TaskMemberUpdateManyWithoutTeamMemberNestedInputFields,
});

export const FollowUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[FollowUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  update: t.field({"required":false,"type":[FollowUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[FollowUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[FollowScalarWhereInput]}),
});
export const FollowUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithoutTeamMemberNestedInput>>('FollowUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: FollowUpdateManyWithoutTeamMemberNestedInputFields,
});

export const EventUpdateManyWithoutInterviewersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutInterviewersInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutInterviewersInput]}),
  upsert: t.field({"required":false,"type":[EventUpsertWithWhereUniqueWithoutInterviewersInput]}),
  set: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventUpdateWithWhereUniqueWithoutInterviewersInput]}),
  updateMany: t.field({"required":false,"type":[EventUpdateManyWithWhereWithoutInterviewersInput]}),
  deleteMany: t.field({"required":false,"type":[EventScalarWhereInput]}),
});
export const EventUpdateManyWithoutInterviewersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithoutInterviewersNestedInput>>('EventUpdateManyWithoutInterviewersNestedInput').implement({
  fields: EventUpdateManyWithoutInterviewersNestedInputFields,
});

export const EventInterviewerUpdateManyWithoutTeamMemberNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventInterviewerCreateWithoutTeamMemberInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventInterviewerCreateOrConnectWithoutTeamMemberInput]}),
  upsert: t.field({"required":false,"type":[EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput]}),
  createMany: t.field({"required":false,"type":EventInterviewerCreateManyTeamMemberInputEnvelope}),
  set: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput]}),
  updateMany: t.field({"required":false,"type":[EventInterviewerUpdateManyWithWhereWithoutTeamMemberInput]}),
  deleteMany: t.field({"required":false,"type":[EventInterviewerScalarWhereInput]}),
});
export const EventInterviewerUpdateManyWithoutTeamMemberNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateManyWithoutTeamMemberNestedInput>>('EventInterviewerUpdateManyWithoutTeamMemberNestedInput').implement({
  fields: EventInterviewerUpdateManyWithoutTeamMemberNestedInputFields,
});

export const RoleCreateabilitiesInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const RoleCreateabilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateabilitiesInput>>('RoleCreateabilitiesInput').implement({
  fields: RoleCreateabilitiesInputFields,
});

export const CompanyCreateNestedOneWithoutRolesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutRolesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutRolesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutRolesInput>>('CompanyCreateNestedOneWithoutRolesInput').implement({
  fields: CompanyCreateNestedOneWithoutRolesInputFields,
});

export const HiringRoleCreateNestedManyWithoutRoleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyRoleInputEnvelope}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
});
export const HiringRoleCreateNestedManyWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedManyWithoutRoleInput>>('HiringRoleCreateNestedManyWithoutRoleInput').implement({
  fields: HiringRoleCreateNestedManyWithoutRoleInputFields,
});

export const MembershipCreateNestedManyWithoutRoleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyRoleInputEnvelope}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
});
export const MembershipCreateNestedManyWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateNestedManyWithoutRoleInput>>('MembershipCreateNestedManyWithoutRoleInput').implement({
  fields: MembershipCreateNestedManyWithoutRoleInputFields,
});

export const StageVisibilityCreateNestedManyWithoutRoleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyRoleInputEnvelope}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
});
export const StageVisibilityCreateNestedManyWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateNestedManyWithoutRoleInput>>('StageVisibilityCreateNestedManyWithoutRoleInput').implement({
  fields: StageVisibilityCreateNestedManyWithoutRoleInputFields,
});

export const RoleUpdateabilitiesInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const RoleUpdateabilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateabilitiesInput>>('RoleUpdateabilitiesInput').implement({
  fields: RoleUpdateabilitiesInputFields,
});

export const CompanyUpdateOneRequiredWithoutRolesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutRolesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutRolesInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutRolesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutRolesInput}),
});
export const CompanyUpdateOneRequiredWithoutRolesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutRolesNestedInput>>('CompanyUpdateOneRequiredWithoutRolesNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutRolesNestedInputFields,
});

export const HiringRoleUpdateManyWithoutRoleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutRoleInput]}),
  upsert: t.field({"required":false,"type":[HiringRoleUpsertWithWhereUniqueWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyRoleInputEnvelope}),
  set: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[HiringRoleUpdateWithWhereUniqueWithoutRoleInput]}),
  updateMany: t.field({"required":false,"type":[HiringRoleUpdateManyWithWhereWithoutRoleInput]}),
  deleteMany: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
});
export const HiringRoleUpdateManyWithoutRoleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithoutRoleNestedInput>>('HiringRoleUpdateManyWithoutRoleNestedInput').implement({
  fields: HiringRoleUpdateManyWithoutRoleNestedInputFields,
});

export const MembershipUpdateManyWithoutRoleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutRoleInput]}),
  upsert: t.field({"required":false,"type":[MembershipUpsertWithWhereUniqueWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyRoleInputEnvelope}),
  set: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MembershipUpdateWithWhereUniqueWithoutRoleInput]}),
  updateMany: t.field({"required":false,"type":[MembershipUpdateManyWithWhereWithoutRoleInput]}),
  deleteMany: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
});
export const MembershipUpdateManyWithoutRoleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithoutRoleNestedInput>>('MembershipUpdateManyWithoutRoleNestedInput').implement({
  fields: MembershipUpdateManyWithoutRoleNestedInputFields,
});

export const StageVisibilityUpdateManyWithoutRoleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutRoleInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutRoleInput]}),
  upsert: t.field({"required":false,"type":[StageVisibilityUpsertWithWhereUniqueWithoutRoleInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyRoleInputEnvelope}),
  set: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  update: t.field({"required":false,"type":[StageVisibilityUpdateWithWhereUniqueWithoutRoleInput]}),
  updateMany: t.field({"required":false,"type":[StageVisibilityUpdateManyWithWhereWithoutRoleInput]}),
  deleteMany: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
});
export const StageVisibilityUpdateManyWithoutRoleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithoutRoleNestedInput>>('StageVisibilityUpdateManyWithoutRoleNestedInput').implement({
  fields: StageVisibilityUpdateManyWithoutRoleNestedInputFields,
});

export const RoleCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[RoleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[RoleCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":RoleCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[RoleWhereUniqueInput]}),
});
export const RoleCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateNestedManyWithoutCompanyInput>>('RoleCreateNestedManyWithoutCompanyInput').implement({
  fields: RoleCreateNestedManyWithoutCompanyInputFields,
});

export const SubscriptionDataCreateNestedOneWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":SubscriptionDataCreateWithoutCompanyInput}),
  connectOrCreate: t.field({"required":false,"type":SubscriptionDataCreateOrConnectWithoutCompanyInput}),
  connect: t.field({"required":false,"type":SubscriptionDataWhereUniqueInput}),
});
export const SubscriptionDataCreateNestedOneWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCreateNestedOneWithoutCompanyInput>>('SubscriptionDataCreateNestedOneWithoutCompanyInput').implement({
  fields: SubscriptionDataCreateNestedOneWithoutCompanyInputFields,
});

export const MeetingRoomCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MeetingRoomCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[MeetingRoomCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":MeetingRoomCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[MeetingRoomWhereUniqueInput]}),
});
export const MeetingRoomCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateNestedManyWithoutCompanyInput>>('MeetingRoomCreateNestedManyWithoutCompanyInput').implement({
  fields: MeetingRoomCreateNestedManyWithoutCompanyInputFields,
});

export const CompanyMetadataCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CompanyMetadataCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CompanyMetadataCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CompanyMetadataCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[CompanyMetadataWhereUniqueInput]}),
});
export const CompanyMetadataCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateNestedManyWithoutCompanyInput>>('CompanyMetadataCreateNestedManyWithoutCompanyInput').implement({
  fields: CompanyMetadataCreateNestedManyWithoutCompanyInputFields,
});

export const EventScheduleCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":EventScheduleCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[EventScheduleWhereUniqueInput]}),
});
export const EventScheduleCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateNestedManyWithoutCompanyInput>>('EventScheduleCreateNestedManyWithoutCompanyInput').implement({
  fields: EventScheduleCreateNestedManyWithoutCompanyInputFields,
});

export const EventCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":EventCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
});
export const EventCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedManyWithoutCompanyInput>>('EventCreateNestedManyWithoutCompanyInput').implement({
  fields: EventCreateNestedManyWithoutCompanyInputFields,
});

export const DepartmentCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[DepartmentCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[DepartmentCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":DepartmentCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[DepartmentWhereUniqueInput]}),
});
export const DepartmentCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateNestedManyWithoutCompanyInput>>('DepartmentCreateNestedManyWithoutCompanyInput').implement({
  fields: DepartmentCreateNestedManyWithoutCompanyInputFields,
});

export const DisqualifyReasonCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[DisqualifyReasonCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[DisqualifyReasonCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":DisqualifyReasonCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[DisqualifyReasonWhereUniqueInput]}),
});
export const DisqualifyReasonCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateNestedManyWithoutCompanyInput>>('DisqualifyReasonCreateNestedManyWithoutCompanyInput').implement({
  fields: DisqualifyReasonCreateNestedManyWithoutCompanyInputFields,
});

export const TagSourceCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TagSourceCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TagSourceCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TagSourceCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[TagSourceWhereUniqueInput]}),
});
export const TagSourceCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateNestedManyWithoutCompanyInput>>('TagSourceCreateNestedManyWithoutCompanyInput').implement({
  fields: TagSourceCreateNestedManyWithoutCompanyInputFields,
});

export const AuditLogCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
});
export const AuditLogCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateNestedManyWithoutCompanyInput>>('AuditLogCreateNestedManyWithoutCompanyInput').implement({
  fields: AuditLogCreateNestedManyWithoutCompanyInputFields,
});

export const OfferCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
});
export const OfferCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedManyWithoutCompanyInput>>('OfferCreateNestedManyWithoutCompanyInput').implement({
  fields: OfferCreateNestedManyWithoutCompanyInputFields,
});

export const TemplateCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TemplateCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TemplateCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TemplateCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[TemplateWhereUniqueInput]}),
});
export const TemplateCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedManyWithoutCompanyInput>>('TemplateCreateNestedManyWithoutCompanyInput').implement({
  fields: TemplateCreateNestedManyWithoutCompanyInputFields,
});

export const TaskCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TaskCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
});
export const TaskCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateNestedManyWithoutCompanyInput>>('TaskCreateNestedManyWithoutCompanyInput').implement({
  fields: TaskCreateNestedManyWithoutCompanyInputFields,
});

export const UserCreateNestedOneWithoutCompaniesOwnedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutCompaniesOwnedInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutCompaniesOwnedInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
});
export const UserCreateNestedOneWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateNestedOneWithoutCompaniesOwnedInput>>('UserCreateNestedOneWithoutCompaniesOwnedInput').implement({
  fields: UserCreateNestedOneWithoutCompaniesOwnedInputFields,
});

export const HiringRoleCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
});
export const HiringRoleCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedManyWithoutCompanyInput>>('HiringRoleCreateNestedManyWithoutCompanyInput').implement({
  fields: HiringRoleCreateNestedManyWithoutCompanyInputFields,
});

export const CandidateCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
});
export const CandidateCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedManyWithoutCompanyInput>>('CandidateCreateNestedManyWithoutCompanyInput').implement({
  fields: CandidateCreateNestedManyWithoutCompanyInputFields,
});

export const TalentPoolCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TalentPoolCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[TalentPoolWhereUniqueInput]}),
});
export const TalentPoolCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateNestedManyWithoutCompanyInput>>('TalentPoolCreateNestedManyWithoutCompanyInput').implement({
  fields: TalentPoolCreateNestedManyWithoutCompanyInputFields,
});

export const CustomFieldCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CustomFieldCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CustomFieldCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CustomFieldCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[CustomFieldWhereUniqueInput]}),
});
export const CustomFieldCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateNestedManyWithoutCompanyInput>>('CustomFieldCreateNestedManyWithoutCompanyInput').implement({
  fields: CustomFieldCreateNestedManyWithoutCompanyInputFields,
});

export const AttachmentCreateNestedOneWithoutCompanyLogoInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCompanyLogoInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCompanyLogoInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutCompanyLogoInput>>('AttachmentCreateNestedOneWithoutCompanyLogoInput').implement({
  fields: AttachmentCreateNestedOneWithoutCompanyLogoInputFields,
});

export const AttachmentCreateNestedManyWithoutCompanyInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AttachmentCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[AttachmentCreateOrConnectWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":AttachmentCreateManyCompanyInputEnvelope}),
  connect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
});
export const AttachmentCreateNestedManyWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedManyWithoutCompanyInput>>('AttachmentCreateNestedManyWithoutCompanyInput').implement({
  fields: AttachmentCreateNestedManyWithoutCompanyInputFields,
});

export const NullableBoolFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.boolean({"required":false}),
});
export const NullableBoolFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NullableBoolFieldUpdateOperationsInput>>('NullableBoolFieldUpdateOperationsInput').implement({
  fields: NullableBoolFieldUpdateOperationsInputFields,
});

export const RoleUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[RoleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[RoleCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[RoleUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":RoleCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[RoleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[RoleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[RoleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[RoleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[RoleUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[RoleUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[RoleScalarWhereInput]}),
});
export const RoleUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateManyWithoutCompanyNestedInput>>('RoleUpdateManyWithoutCompanyNestedInput').implement({
  fields: RoleUpdateManyWithoutCompanyNestedInputFields,
});

export const SubscriptionDataUpdateOneWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":SubscriptionDataCreateWithoutCompanyInput}),
  connectOrCreate: t.field({"required":false,"type":SubscriptionDataCreateOrConnectWithoutCompanyInput}),
  upsert: t.field({"required":false,"type":SubscriptionDataUpsertWithoutCompanyInput}),
  disconnect: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  delete: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  connect: t.field({"required":false,"type":SubscriptionDataWhereUniqueInput}),
  update: t.field({"required":false,"type":SubscriptionDataUpdateToOneWithWhereWithoutCompanyInput}),
});
export const SubscriptionDataUpdateOneWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpdateOneWithoutCompanyNestedInput>>('SubscriptionDataUpdateOneWithoutCompanyNestedInput').implement({
  fields: SubscriptionDataUpdateOneWithoutCompanyNestedInputFields,
});

export const MeetingRoomUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MeetingRoomCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[MeetingRoomCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[MeetingRoomUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":MeetingRoomCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[MeetingRoomWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MeetingRoomWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MeetingRoomWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MeetingRoomWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MeetingRoomUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[MeetingRoomUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[MeetingRoomScalarWhereInput]}),
});
export const MeetingRoomUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateManyWithoutCompanyNestedInput>>('MeetingRoomUpdateManyWithoutCompanyNestedInput').implement({
  fields: MeetingRoomUpdateManyWithoutCompanyNestedInputFields,
});

export const CompanyMetadataUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CompanyMetadataCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CompanyMetadataCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CompanyMetadataCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[CompanyMetadataWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CompanyMetadataWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CompanyMetadataWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CompanyMetadataWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[CompanyMetadataUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[CompanyMetadataScalarWhereInput]}),
});
export const CompanyMetadataUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateManyWithoutCompanyNestedInput>>('CompanyMetadataUpdateManyWithoutCompanyNestedInput').implement({
  fields: CompanyMetadataUpdateManyWithoutCompanyNestedInputFields,
});

export const EventScheduleUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[EventScheduleUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":EventScheduleCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[EventScheduleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventScheduleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventScheduleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventScheduleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventScheduleUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[EventScheduleUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[EventScheduleScalarWhereInput]}),
});
export const EventScheduleUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateManyWithoutCompanyNestedInput>>('EventScheduleUpdateManyWithoutCompanyNestedInput').implement({
  fields: EventScheduleUpdateManyWithoutCompanyNestedInputFields,
});

export const EventUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[EventUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":EventCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[EventUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[EventScalarWhereInput]}),
});
export const EventUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithoutCompanyNestedInput>>('EventUpdateManyWithoutCompanyNestedInput').implement({
  fields: EventUpdateManyWithoutCompanyNestedInputFields,
});

export const DepartmentUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[DepartmentCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[DepartmentCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[DepartmentUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":DepartmentCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[DepartmentWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[DepartmentWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[DepartmentWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[DepartmentWhereUniqueInput]}),
  update: t.field({"required":false,"type":[DepartmentUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[DepartmentUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[DepartmentScalarWhereInput]}),
});
export const DepartmentUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateManyWithoutCompanyNestedInput>>('DepartmentUpdateManyWithoutCompanyNestedInput').implement({
  fields: DepartmentUpdateManyWithoutCompanyNestedInputFields,
});

export const DisqualifyReasonUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[DisqualifyReasonCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[DisqualifyReasonCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":DisqualifyReasonCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[DisqualifyReasonWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[DisqualifyReasonWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[DisqualifyReasonWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[DisqualifyReasonWhereUniqueInput]}),
  update: t.field({"required":false,"type":[DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[DisqualifyReasonUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[DisqualifyReasonScalarWhereInput]}),
});
export const DisqualifyReasonUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateManyWithoutCompanyNestedInput>>('DisqualifyReasonUpdateManyWithoutCompanyNestedInput').implement({
  fields: DisqualifyReasonUpdateManyWithoutCompanyNestedInputFields,
});

export const TagSourceUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TagSourceCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TagSourceCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[TagSourceUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TagSourceCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[TagSourceWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TagSourceWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TagSourceWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TagSourceWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TagSourceUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[TagSourceUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[TagSourceScalarWhereInput]}),
});
export const TagSourceUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateManyWithoutCompanyNestedInput>>('TagSourceUpdateManyWithoutCompanyNestedInput').implement({
  fields: TagSourceUpdateManyWithoutCompanyNestedInputFields,
});

export const AuditLogUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[AuditLogUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AuditLogUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[AuditLogUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
});
export const AuditLogUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithoutCompanyNestedInput>>('AuditLogUpdateManyWithoutCompanyNestedInput').implement({
  fields: AuditLogUpdateManyWithoutCompanyNestedInputFields,
});

export const OfferUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[OfferUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[OfferUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[OfferScalarWhereInput]}),
});
export const OfferUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithoutCompanyNestedInput>>('OfferUpdateManyWithoutCompanyNestedInput').implement({
  fields: OfferUpdateManyWithoutCompanyNestedInputFields,
});

export const TemplateUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TemplateCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TemplateCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[TemplateUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TemplateCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[TemplateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TemplateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TemplateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TemplateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TemplateUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[TemplateUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[TemplateScalarWhereInput]}),
});
export const TemplateUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateManyWithoutCompanyNestedInput>>('TemplateUpdateManyWithoutCompanyNestedInput').implement({
  fields: TemplateUpdateManyWithoutCompanyNestedInputFields,
});

export const TaskUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[TaskUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TaskCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TaskUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[TaskUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[TaskScalarWhereInput]}),
});
export const TaskUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateManyWithoutCompanyNestedInput>>('TaskUpdateManyWithoutCompanyNestedInput').implement({
  fields: TaskUpdateManyWithoutCompanyNestedInputFields,
});

export const UserUpdateOneRequiredWithoutCompaniesOwnedNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":UserCreateWithoutCompaniesOwnedInput}),
  connectOrCreate: t.field({"required":false,"type":UserCreateOrConnectWithoutCompaniesOwnedInput}),
  upsert: t.field({"required":false,"type":UserUpsertWithoutCompaniesOwnedInput}),
  connect: t.field({"required":false,"type":UserWhereUniqueInput}),
  update: t.field({"required":false,"type":UserUpdateToOneWithWhereWithoutCompaniesOwnedInput}),
});
export const UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput>>('UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput').implement({
  fields: UserUpdateOneRequiredWithoutCompaniesOwnedNestedInputFields,
});

export const HiringRoleUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[HiringRoleUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":HiringRoleCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[HiringRoleUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[HiringRoleUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
});
export const HiringRoleUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithoutCompanyNestedInput>>('HiringRoleUpdateManyWithoutCompanyNestedInput').implement({
  fields: HiringRoleUpdateManyWithoutCompanyNestedInputFields,
});

export const CandidateUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[CandidateUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[CandidateUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
});
export const CandidateUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithoutCompanyNestedInput>>('CandidateUpdateManyWithoutCompanyNestedInput').implement({
  fields: CandidateUpdateManyWithoutCompanyNestedInputFields,
});

export const TalentPoolUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[TalentPoolUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":TalentPoolCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[TalentPoolWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TalentPoolWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TalentPoolWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TalentPoolWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TalentPoolUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[TalentPoolUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[TalentPoolScalarWhereInput]}),
});
export const TalentPoolUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateManyWithoutCompanyNestedInput>>('TalentPoolUpdateManyWithoutCompanyNestedInput').implement({
  fields: TalentPoolUpdateManyWithoutCompanyNestedInputFields,
});

export const CustomFieldUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CustomFieldCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[CustomFieldCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[CustomFieldUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":CustomFieldCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[CustomFieldWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CustomFieldWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CustomFieldWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CustomFieldWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CustomFieldUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[CustomFieldUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[CustomFieldScalarWhereInput]}),
});
export const CustomFieldUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateManyWithoutCompanyNestedInput>>('CustomFieldUpdateManyWithoutCompanyNestedInput').implement({
  fields: CustomFieldUpdateManyWithoutCompanyNestedInputFields,
});

export const AttachmentUpdateOneWithoutCompanyLogoNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCompanyLogoInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCompanyLogoInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutCompanyLogoInput}),
  disconnect: t.field({"required":false,"type":AttachmentWhereInput}),
  delete: t.field({"required":false,"type":AttachmentWhereInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutCompanyLogoInput}),
});
export const AttachmentUpdateOneWithoutCompanyLogoNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneWithoutCompanyLogoNestedInput>>('AttachmentUpdateOneWithoutCompanyLogoNestedInput').implement({
  fields: AttachmentUpdateOneWithoutCompanyLogoNestedInputFields,
});

export const AttachmentUpdateManyWithoutCompanyNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AttachmentCreateWithoutCompanyInput]}),
  connectOrCreate: t.field({"required":false,"type":[AttachmentCreateOrConnectWithoutCompanyInput]}),
  upsert: t.field({"required":false,"type":[AttachmentUpsertWithWhereUniqueWithoutCompanyInput]}),
  createMany: t.field({"required":false,"type":AttachmentCreateManyCompanyInputEnvelope}),
  set: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AttachmentWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AttachmentUpdateWithWhereUniqueWithoutCompanyInput]}),
  updateMany: t.field({"required":false,"type":[AttachmentUpdateManyWithWhereWithoutCompanyInput]}),
  deleteMany: t.field({"required":false,"type":[AttachmentScalarWhereInput]}),
});
export const AttachmentUpdateManyWithoutCompanyNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateManyWithoutCompanyNestedInput>>('AttachmentUpdateManyWithoutCompanyNestedInput').implement({
  fields: AttachmentUpdateManyWithoutCompanyNestedInputFields,
});

export const CompanyCreateNestedOneWithoutSubscriptionInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutSubscriptionInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutSubscriptionInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutSubscriptionInput>>('CompanyCreateNestedOneWithoutSubscriptionInput').implement({
  fields: CompanyCreateNestedOneWithoutSubscriptionInputFields,
});

export const CompanyUpdateOneRequiredWithoutSubscriptionNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutSubscriptionInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutSubscriptionInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutSubscriptionInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutSubscriptionInput}),
});
export const CompanyUpdateOneRequiredWithoutSubscriptionNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutSubscriptionNestedInput>>('CompanyUpdateOneRequiredWithoutSubscriptionNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutSubscriptionNestedInputFields,
});

export const CompanyCreateNestedOneWithoutMetadataInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutMetadataInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutMetadataInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutMetadataInput>>('CompanyCreateNestedOneWithoutMetadataInput').implement({
  fields: CompanyCreateNestedOneWithoutMetadataInputFields,
});

export const CompanyUpdateOneRequiredWithoutMetadataNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutMetadataInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutMetadataInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutMetadataInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutMetadataInput}),
});
export const CompanyUpdateOneRequiredWithoutMetadataNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutMetadataNestedInput>>('CompanyUpdateOneRequiredWithoutMetadataNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutMetadataNestedInputFields,
});

export const CompanyCreateNestedOneWithoutDepartmentsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutDepartmentsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutDepartmentsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutDepartmentsInput>>('CompanyCreateNestedOneWithoutDepartmentsInput').implement({
  fields: CompanyCreateNestedOneWithoutDepartmentsInputFields,
});

export const OfferCreateNestedManyWithoutDepartmentInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutDepartmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutDepartmentInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyDepartmentInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
});
export const OfferCreateNestedManyWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedManyWithoutDepartmentInput>>('OfferCreateNestedManyWithoutDepartmentInput').implement({
  fields: OfferCreateNestedManyWithoutDepartmentInputFields,
});

export const CompanyUpdateOneRequiredWithoutDepartmentsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutDepartmentsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutDepartmentsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutDepartmentsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutDepartmentsInput}),
});
export const CompanyUpdateOneRequiredWithoutDepartmentsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutDepartmentsNestedInput>>('CompanyUpdateOneRequiredWithoutDepartmentsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutDepartmentsNestedInputFields,
});

export const OfferUpdateManyWithoutDepartmentNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutDepartmentInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutDepartmentInput]}),
  upsert: t.field({"required":false,"type":[OfferUpsertWithWhereUniqueWithoutDepartmentInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyDepartmentInputEnvelope}),
  set: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferUpdateWithWhereUniqueWithoutDepartmentInput]}),
  updateMany: t.field({"required":false,"type":[OfferUpdateManyWithWhereWithoutDepartmentInput]}),
  deleteMany: t.field({"required":false,"type":[OfferScalarWhereInput]}),
});
export const OfferUpdateManyWithoutDepartmentNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithoutDepartmentNestedInput>>('OfferUpdateManyWithoutDepartmentNestedInput').implement({
  fields: OfferUpdateManyWithoutDepartmentNestedInputFields,
});

export const CompanyCreateNestedOneWithoutDisqualifyReasonsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutDisqualifyReasonsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutDisqualifyReasonsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutDisqualifyReasonsInput>>('CompanyCreateNestedOneWithoutDisqualifyReasonsInput').implement({
  fields: CompanyCreateNestedOneWithoutDisqualifyReasonsInputFields,
});

export const MatchCreateNestedManyWithoutDisqualifyReasonInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutDisqualifyReasonInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutDisqualifyReasonInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyDisqualifyReasonInputEnvelope}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
});
export const MatchCreateNestedManyWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateNestedManyWithoutDisqualifyReasonInput>>('MatchCreateNestedManyWithoutDisqualifyReasonInput').implement({
  fields: MatchCreateNestedManyWithoutDisqualifyReasonInputFields,
});

export const CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutDisqualifyReasonsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutDisqualifyReasonsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutDisqualifyReasonsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInput}),
});
export const CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInput>>('CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInputFields,
});

export const MatchUpdateManyWithoutDisqualifyReasonNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutDisqualifyReasonInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutDisqualifyReasonInput]}),
  upsert: t.field({"required":false,"type":[MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyDisqualifyReasonInputEnvelope}),
  set: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInput]}),
  updateMany: t.field({"required":false,"type":[MatchUpdateManyWithWhereWithoutDisqualifyReasonInput]}),
  deleteMany: t.field({"required":false,"type":[MatchScalarWhereInput]}),
});
export const MatchUpdateManyWithoutDisqualifyReasonNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithoutDisqualifyReasonNestedInput>>('MatchUpdateManyWithoutDisqualifyReasonNestedInput').implement({
  fields: MatchUpdateManyWithoutDisqualifyReasonNestedInputFields,
});

export const CompanyCreateNestedOneWithoutTagSourcesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTagSourcesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTagSourcesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutTagSourcesInput>>('CompanyCreateNestedOneWithoutTagSourcesInput').implement({
  fields: CompanyCreateNestedOneWithoutTagSourcesInputFields,
});

export const OfferTagCreateNestedManyWithoutTagInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferTagCreateWithoutTagInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferTagCreateOrConnectWithoutTagInput]}),
  createMany: t.field({"required":false,"type":OfferTagCreateManyTagInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
});
export const OfferTagCreateNestedManyWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateNestedManyWithoutTagInput>>('OfferTagCreateNestedManyWithoutTagInput').implement({
  fields: OfferTagCreateNestedManyWithoutTagInputFields,
});

export const CandidateCreateNestedManyWithoutReferrerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutReferrerInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutReferrerInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyReferrerInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
});
export const CandidateCreateNestedManyWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedManyWithoutReferrerInput>>('CandidateCreateNestedManyWithoutReferrerInput').implement({
  fields: CandidateCreateNestedManyWithoutReferrerInputFields,
});

export const CandidateTagCreateNestedManyWithoutTagInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateTagCreateWithoutTagInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateTagCreateOrConnectWithoutTagInput]}),
  createMany: t.field({"required":false,"type":CandidateTagCreateManyTagInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
});
export const CandidateTagCreateNestedManyWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateNestedManyWithoutTagInput>>('CandidateTagCreateNestedManyWithoutTagInput').implement({
  fields: CandidateTagCreateNestedManyWithoutTagInputFields,
});

export const EnumTagSourceTypeFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":TagSourceType}),
});
export const EnumTagSourceTypeFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTagSourceTypeFieldUpdateOperationsInput>>('EnumTagSourceTypeFieldUpdateOperationsInput').implement({
  fields: EnumTagSourceTypeFieldUpdateOperationsInputFields,
});

export const CompanyUpdateOneRequiredWithoutTagSourcesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTagSourcesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTagSourcesInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutTagSourcesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutTagSourcesInput}),
});
export const CompanyUpdateOneRequiredWithoutTagSourcesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutTagSourcesNestedInput>>('CompanyUpdateOneRequiredWithoutTagSourcesNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutTagSourcesNestedInputFields,
});

export const OfferTagUpdateManyWithoutTagNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferTagCreateWithoutTagInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferTagCreateOrConnectWithoutTagInput]}),
  upsert: t.field({"required":false,"type":[OfferTagUpsertWithWhereUniqueWithoutTagInput]}),
  createMany: t.field({"required":false,"type":OfferTagCreateManyTagInputEnvelope}),
  set: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferTagUpdateWithWhereUniqueWithoutTagInput]}),
  updateMany: t.field({"required":false,"type":[OfferTagUpdateManyWithWhereWithoutTagInput]}),
  deleteMany: t.field({"required":false,"type":[OfferTagScalarWhereInput]}),
});
export const OfferTagUpdateManyWithoutTagNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateManyWithoutTagNestedInput>>('OfferTagUpdateManyWithoutTagNestedInput').implement({
  fields: OfferTagUpdateManyWithoutTagNestedInputFields,
});

export const CandidateUpdateManyWithoutReferrerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutReferrerInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutReferrerInput]}),
  upsert: t.field({"required":false,"type":[CandidateUpsertWithWhereUniqueWithoutReferrerInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyReferrerInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateUpdateWithWhereUniqueWithoutReferrerInput]}),
  updateMany: t.field({"required":false,"type":[CandidateUpdateManyWithWhereWithoutReferrerInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
});
export const CandidateUpdateManyWithoutReferrerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithoutReferrerNestedInput>>('CandidateUpdateManyWithoutReferrerNestedInput').implement({
  fields: CandidateUpdateManyWithoutReferrerNestedInputFields,
});

export const CandidateTagUpdateManyWithoutTagNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateTagCreateWithoutTagInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateTagCreateOrConnectWithoutTagInput]}),
  upsert: t.field({"required":false,"type":[CandidateTagUpsertWithWhereUniqueWithoutTagInput]}),
  createMany: t.field({"required":false,"type":CandidateTagCreateManyTagInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateTagUpdateWithWhereUniqueWithoutTagInput]}),
  updateMany: t.field({"required":false,"type":[CandidateTagUpdateManyWithWhereWithoutTagInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateTagScalarWhereInput]}),
});
export const CandidateTagUpdateManyWithoutTagNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateManyWithoutTagNestedInput>>('CandidateTagUpdateManyWithoutTagNestedInput').implement({
  fields: CandidateTagUpdateManyWithoutTagNestedInputFields,
});

export const CompanyCreateNestedOneWithoutAuditLogsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutAuditLogsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutAuditLogsInput>>('CompanyCreateNestedOneWithoutAuditLogsInput').implement({
  fields: CompanyCreateNestedOneWithoutAuditLogsInputFields,
});

export const HiringRoleCreateNestedOneWithoutAuditLogsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutAuditLogsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutAuditLogsInput>>('HiringRoleCreateNestedOneWithoutAuditLogsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutAuditLogsInputFields,
});

export const OfferCreateNestedOneWithoutAuditLogsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutAuditLogsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutAuditLogsInput>>('OfferCreateNestedOneWithoutAuditLogsInput').implement({
  fields: OfferCreateNestedOneWithoutAuditLogsInputFields,
});

export const CandidateCreateNestedOneWithoutAuditLogsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutAuditLogsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutAuditLogsInput>>('CandidateCreateNestedOneWithoutAuditLogsInput').implement({
  fields: CandidateCreateNestedOneWithoutAuditLogsInputFields,
});

export const CompanyUpdateOneRequiredWithoutAuditLogsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutAuditLogsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutAuditLogsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutAuditLogsInput}),
});
export const CompanyUpdateOneRequiredWithoutAuditLogsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutAuditLogsNestedInput>>('CompanyUpdateOneRequiredWithoutAuditLogsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutAuditLogsNestedInputFields,
});

export const HiringRoleUpdateOneWithoutAuditLogsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutAuditLogsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutAuditLogsInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutAuditLogsInput}),
});
export const HiringRoleUpdateOneWithoutAuditLogsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutAuditLogsNestedInput>>('HiringRoleUpdateOneWithoutAuditLogsNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutAuditLogsNestedInputFields,
});

export const OfferUpdateOneWithoutAuditLogsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutAuditLogsInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutAuditLogsInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutAuditLogsInput}),
});
export const OfferUpdateOneWithoutAuditLogsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutAuditLogsNestedInput>>('OfferUpdateOneWithoutAuditLogsNestedInput').implement({
  fields: OfferUpdateOneWithoutAuditLogsNestedInputFields,
});

export const CandidateUpdateOneWithoutAuditLogsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutAuditLogsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutAuditLogsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutAuditLogsInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutAuditLogsInput}),
});
export const CandidateUpdateOneWithoutAuditLogsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutAuditLogsNestedInput>>('CandidateUpdateOneWithoutAuditLogsNestedInput').implement({
  fields: CandidateUpdateOneWithoutAuditLogsNestedInputFields,
});

export const CompanyCreateNestedOneWithoutMeetingRoomsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutMeetingRoomsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutMeetingRoomsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutMeetingRoomsInput>>('CompanyCreateNestedOneWithoutMeetingRoomsInput').implement({
  fields: CompanyCreateNestedOneWithoutMeetingRoomsInputFields,
});

export const CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutMeetingRoomsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutMeetingRoomsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutMeetingRoomsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutMeetingRoomsInput}),
});
export const CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInput>>('CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutMeetingRoomsNestedInputFields,
});

export const CompanyCreateNestedOneWithoutEventScheduleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutEventScheduleInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutEventScheduleInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutEventScheduleInput>>('CompanyCreateNestedOneWithoutEventScheduleInput').implement({
  fields: CompanyCreateNestedOneWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleInterviewerCreateWithoutEventScheduleInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInput]}),
  createMany: t.field({"required":false,"type":EventScheduleInterviewerCreateManyEventScheduleInputEnvelope}),
  connect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
});
export const EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput>>('EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleEvaluationCreateWithoutEventScheduleInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInput]}),
  createMany: t.field({"required":false,"type":EventScheduleEvaluationCreateManyEventScheduleInputEnvelope}),
  connect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
});
export const EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput>>('EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInputFields,
});

export const CompanyUpdateOneRequiredWithoutEventScheduleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutEventScheduleInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutEventScheduleInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutEventScheduleInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutEventScheduleInput}),
});
export const CompanyUpdateOneRequiredWithoutEventScheduleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutEventScheduleNestedInput>>('CompanyUpdateOneRequiredWithoutEventScheduleNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutEventScheduleNestedInputFields,
});

export const EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleInterviewerCreateWithoutEventScheduleInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInput]}),
  upsert: t.field({"required":false,"type":[EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInput]}),
  createMany: t.field({"required":false,"type":EventScheduleInterviewerCreateManyEventScheduleInputEnvelope}),
  set: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventScheduleInterviewerWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInput]}),
  updateMany: t.field({"required":false,"type":[EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInput]}),
  deleteMany: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereInput]}),
});
export const EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput>>('EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput').implement({
  fields: EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInputFields,
});

export const EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleEvaluationCreateWithoutEventScheduleInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInput]}),
  upsert: t.field({"required":false,"type":[EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInput]}),
  createMany: t.field({"required":false,"type":EventScheduleEvaluationCreateManyEventScheduleInputEnvelope}),
  set: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInput]}),
  updateMany: t.field({"required":false,"type":[EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInput]}),
  deleteMany: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereInput]}),
});
export const EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput>>('EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput').implement({
  fields: EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInputFields,
});

export const EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventScheduleCreateWithoutEventScheduleInterviewersInput}),
  connectOrCreate: t.field({"required":false,"type":EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInput}),
  connect: t.field({"required":false,"type":EventScheduleWhereUniqueInput}),
});
export const EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInput>>('EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEventScheduleInterviewersInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInput>>('HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventScheduleCreateWithoutEventScheduleInterviewersInput}),
  connectOrCreate: t.field({"required":false,"type":EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInput}),
  upsert: t.field({"required":false,"type":EventScheduleUpsertWithoutEventScheduleInterviewersInput}),
  connect: t.field({"required":false,"type":EventScheduleWhereUniqueInput}),
  update: t.field({"required":false,"type":EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput>>('EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput').implement({
  fields: EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEventScheduleInterviewersInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutEventScheduleInterviewersInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput}),
});
export const HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput>>('HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInputFields,
});

export const EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventScheduleCreateWithoutEventScheduleEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInput}),
  connect: t.field({"required":false,"type":EventScheduleWhereUniqueInput}),
});
export const EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInput>>('EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EvaluationCreateWithoutEventScheduleEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInput}),
  connect: t.field({"required":false,"type":EvaluationWhereUniqueInput}),
});
export const EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInput>>('EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInputFields,
});

export const EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventScheduleCreateWithoutEventScheduleEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInput}),
  upsert: t.field({"required":false,"type":EventScheduleUpsertWithoutEventScheduleEvaluationsInput}),
  connect: t.field({"required":false,"type":EventScheduleWhereUniqueInput}),
  update: t.field({"required":false,"type":EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput>>('EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput').implement({
  fields: EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInputFields,
});

export const EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EvaluationCreateWithoutEventScheduleEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInput}),
  upsert: t.field({"required":false,"type":EvaluationUpsertWithoutEventScheduleEvaluationsInput}),
  connect: t.field({"required":false,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":false,"type":EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput}),
});
export const EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput>>('EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput').implement({
  fields: EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInputFields,
});

export const CompanyCreateNestedOneWithoutEventsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutEventsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutEventsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutEventsInput>>('CompanyCreateNestedOneWithoutEventsInput').implement({
  fields: CompanyCreateNestedOneWithoutEventsInputFields,
});

export const HiringRoleCreateNestedManyWithoutInterviewerEventsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutInterviewerEventsInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutInterviewerEventsInput]}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
});
export const HiringRoleCreateNestedManyWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedManyWithoutInterviewerEventsInput>>('HiringRoleCreateNestedManyWithoutInterviewerEventsInput').implement({
  fields: HiringRoleCreateNestedManyWithoutInterviewerEventsInputFields,
});

export const EvaluationCreateNestedManyWithoutEventInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutEventInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutEventInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyEventInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
});
export const EvaluationCreateNestedManyWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedManyWithoutEventInput>>('EvaluationCreateNestedManyWithoutEventInput').implement({
  fields: EvaluationCreateNestedManyWithoutEventInputFields,
});

export const CandidateCreateNestedManyWithoutEventsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutEventsInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutEventsInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
});
export const CandidateCreateNestedManyWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedManyWithoutEventsInput>>('CandidateCreateNestedManyWithoutEventsInput').implement({
  fields: CandidateCreateNestedManyWithoutEventsInputFields,
});

export const HiringRoleCreateNestedOneWithoutCreatedEventsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutCreatedEventsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutCreatedEventsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutCreatedEventsInput>>('HiringRoleCreateNestedOneWithoutCreatedEventsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutCreatedEventsInputFields,
});

export const EventInterviewerCreateNestedManyWithoutEventInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventInterviewerCreateWithoutEventInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventInterviewerCreateOrConnectWithoutEventInput]}),
  createMany: t.field({"required":false,"type":EventInterviewerCreateManyEventInputEnvelope}),
  connect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
});
export const EventInterviewerCreateNestedManyWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateNestedManyWithoutEventInput>>('EventInterviewerCreateNestedManyWithoutEventInput').implement({
  fields: EventInterviewerCreateNestedManyWithoutEventInputFields,
});

export const CompanyUpdateOneRequiredWithoutEventsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutEventsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutEventsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutEventsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutEventsInput}),
});
export const CompanyUpdateOneRequiredWithoutEventsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutEventsNestedInput>>('CompanyUpdateOneRequiredWithoutEventsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutEventsNestedInputFields,
});

export const HiringRoleUpdateManyWithoutInterviewerEventsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[HiringRoleCreateWithoutInterviewerEventsInput]}),
  connectOrCreate: t.field({"required":false,"type":[HiringRoleCreateOrConnectWithoutInterviewerEventsInput]}),
  upsert: t.field({"required":false,"type":[HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInput]}),
  set: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[HiringRoleWhereUniqueInput]}),
  update: t.field({"required":false,"type":[HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInput]}),
  updateMany: t.field({"required":false,"type":[HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInput]}),
  deleteMany: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
});
export const HiringRoleUpdateManyWithoutInterviewerEventsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithoutInterviewerEventsNestedInput>>('HiringRoleUpdateManyWithoutInterviewerEventsNestedInput').implement({
  fields: HiringRoleUpdateManyWithoutInterviewerEventsNestedInputFields,
});

export const EvaluationUpdateManyWithoutEventNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutEventInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutEventInput]}),
  upsert: t.field({"required":false,"type":[EvaluationUpsertWithWhereUniqueWithoutEventInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyEventInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationUpdateWithWhereUniqueWithoutEventInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationUpdateManyWithWhereWithoutEventInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
});
export const EvaluationUpdateManyWithoutEventNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithoutEventNestedInput>>('EvaluationUpdateManyWithoutEventNestedInput').implement({
  fields: EvaluationUpdateManyWithoutEventNestedInputFields,
});

export const CandidateUpdateManyWithoutEventsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutEventsInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutEventsInput]}),
  upsert: t.field({"required":false,"type":[CandidateUpsertWithWhereUniqueWithoutEventsInput]}),
  set: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateUpdateWithWhereUniqueWithoutEventsInput]}),
  updateMany: t.field({"required":false,"type":[CandidateUpdateManyWithWhereWithoutEventsInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
});
export const CandidateUpdateManyWithoutEventsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithoutEventsNestedInput>>('CandidateUpdateManyWithoutEventsNestedInput').implement({
  fields: CandidateUpdateManyWithoutEventsNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutCreatedEventsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutCreatedEventsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutCreatedEventsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInput}),
});
export const HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput>>('HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInputFields,
});

export const EventInterviewerUpdateManyWithoutEventNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventInterviewerCreateWithoutEventInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventInterviewerCreateOrConnectWithoutEventInput]}),
  upsert: t.field({"required":false,"type":[EventInterviewerUpsertWithWhereUniqueWithoutEventInput]}),
  createMany: t.field({"required":false,"type":EventInterviewerCreateManyEventInputEnvelope}),
  set: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventInterviewerWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventInterviewerUpdateWithWhereUniqueWithoutEventInput]}),
  updateMany: t.field({"required":false,"type":[EventInterviewerUpdateManyWithWhereWithoutEventInput]}),
  deleteMany: t.field({"required":false,"type":[EventInterviewerScalarWhereInput]}),
});
export const EventInterviewerUpdateManyWithoutEventNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateManyWithoutEventNestedInput>>('EventInterviewerUpdateManyWithoutEventNestedInput').implement({
  fields: EventInterviewerUpdateManyWithoutEventNestedInputFields,
});

export const EventCreateNestedOneWithoutEventInterviewerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventCreateWithoutEventInterviewerInput}),
  connectOrCreate: t.field({"required":false,"type":EventCreateOrConnectWithoutEventInterviewerInput}),
  connect: t.field({"required":false,"type":EventWhereUniqueInput}),
});
export const EventCreateNestedOneWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedOneWithoutEventInterviewerInput>>('EventCreateNestedOneWithoutEventInterviewerInput').implement({
  fields: EventCreateNestedOneWithoutEventInterviewerInputFields,
});

export const HiringRoleCreateNestedOneWithoutEventInterviewerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEventInterviewerInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEventInterviewerInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutEventInterviewerInput>>('HiringRoleCreateNestedOneWithoutEventInterviewerInput').implement({
  fields: HiringRoleCreateNestedOneWithoutEventInterviewerInputFields,
});

export const EventUpdateOneRequiredWithoutEventInterviewerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventCreateWithoutEventInterviewerInput}),
  connectOrCreate: t.field({"required":false,"type":EventCreateOrConnectWithoutEventInterviewerInput}),
  upsert: t.field({"required":false,"type":EventUpsertWithoutEventInterviewerInput}),
  connect: t.field({"required":false,"type":EventWhereUniqueInput}),
  update: t.field({"required":false,"type":EventUpdateToOneWithWhereWithoutEventInterviewerInput}),
});
export const EventUpdateOneRequiredWithoutEventInterviewerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateOneRequiredWithoutEventInterviewerNestedInput>>('EventUpdateOneRequiredWithoutEventInterviewerNestedInput').implement({
  fields: EventUpdateOneRequiredWithoutEventInterviewerNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEventInterviewerInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEventInterviewerInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutEventInterviewerInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInput}),
});
export const HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInput>>('HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInputFields,
});

export const CompanyCreateNestedOneWithoutOffersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutOffersInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutOffersInput>>('CompanyCreateNestedOneWithoutOffersInput').implement({
  fields: CompanyCreateNestedOneWithoutOffersInputFields,
});

export const DepartmentCreateNestedOneWithoutOffersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":DepartmentCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":DepartmentCreateOrConnectWithoutOffersInput}),
  connect: t.field({"required":false,"type":DepartmentWhereUniqueInput}),
});
export const DepartmentCreateNestedOneWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateNestedOneWithoutOffersInput>>('DepartmentCreateNestedOneWithoutOffersInput').implement({
  fields: DepartmentCreateNestedOneWithoutOffersInputFields,
});

export const HiringRoleCreateNestedOneWithoutOfferRecruiterInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutOfferRecruiterInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutOfferRecruiterInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutOfferRecruiterInput>>('HiringRoleCreateNestedOneWithoutOfferRecruiterInput').implement({
  fields: HiringRoleCreateNestedOneWithoutOfferRecruiterInputFields,
});

export const HiringRoleCreateNestedOneWithoutOfferHiringManagerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutOfferHiringManagerInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutOfferHiringManagerInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutOfferHiringManagerInput>>('HiringRoleCreateNestedOneWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleCreateNestedOneWithoutOfferHiringManagerInputFields,
});

export const TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutScreeningQuestionsTemplateInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
});
export const TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput>>('TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateCreateNestedOneWithoutPipelineTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutPipelineTemplateInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutPipelineTemplateInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
});
export const TemplateCreateNestedOneWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedOneWithoutPipelineTemplateInput>>('TemplateCreateNestedOneWithoutPipelineTemplateInput').implement({
  fields: TemplateCreateNestedOneWithoutPipelineTemplateInputFields,
});

export const TemplateCreateNestedOneWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutAutoConfirmationEmailInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutAutoConfirmationEmailInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
});
export const TemplateCreateNestedOneWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedOneWithoutAutoConfirmationEmailInput>>('TemplateCreateNestedOneWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateCreateNestedOneWithoutAutoConfirmationEmailInputFields,
});

export const AuditLogCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
});
export const AuditLogCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateNestedManyWithoutOfferInput>>('AuditLogCreateNestedManyWithoutOfferInput').implement({
  fields: AuditLogCreateNestedManyWithoutOfferInputFields,
});

export const OfferFileCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferFileCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferFileCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":OfferFileCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
});
export const OfferFileCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateNestedManyWithoutOfferInput>>('OfferFileCreateNestedManyWithoutOfferInput').implement({
  fields: OfferFileCreateNestedManyWithoutOfferInputFields,
});

export const OfferTagCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferTagCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferTagCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":OfferTagCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
});
export const OfferTagCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateNestedManyWithoutOfferInput>>('OfferTagCreateNestedManyWithoutOfferInput').implement({
  fields: OfferTagCreateNestedManyWithoutOfferInputFields,
});

export const MembershipCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
});
export const MembershipCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateNestedManyWithoutOfferInput>>('MembershipCreateNestedManyWithoutOfferInput').implement({
  fields: MembershipCreateNestedManyWithoutOfferInputFields,
});

export const MatchCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
});
export const MatchCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateNestedManyWithoutOfferInput>>('MatchCreateNestedManyWithoutOfferInput').implement({
  fields: MatchCreateNestedManyWithoutOfferInputFields,
});

export const CandidateCreateNestedManyWithoutHiredAtInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutHiredAtInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutHiredAtInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyHiredAtInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
});
export const CandidateCreateNestedManyWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedManyWithoutHiredAtInput>>('CandidateCreateNestedManyWithoutHiredAtInput').implement({
  fields: CandidateCreateNestedManyWithoutHiredAtInputFields,
});

export const EvaluationCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
});
export const EvaluationCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedManyWithoutOfferInput>>('EvaluationCreateNestedManyWithoutOfferInput').implement({
  fields: EvaluationCreateNestedManyWithoutOfferInputFields,
});

export const FollowCreateNestedManyWithoutOfferInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyOfferInputEnvelope}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
});
export const FollowCreateNestedManyWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateNestedManyWithoutOfferInput>>('FollowCreateNestedManyWithoutOfferInput').implement({
  fields: FollowCreateNestedManyWithoutOfferInputFields,
});

export const EnumOfferPersonalItemsFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":OfferPersonalItems}),
});
export const EnumOfferPersonalItemsFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumOfferPersonalItemsFieldUpdateOperationsInput>>('EnumOfferPersonalItemsFieldUpdateOperationsInput').implement({
  fields: EnumOfferPersonalItemsFieldUpdateOperationsInputFields,
});

export const CompanyUpdateOneRequiredWithoutOffersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutOffersInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutOffersInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutOffersInput}),
});
export const CompanyUpdateOneRequiredWithoutOffersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutOffersNestedInput>>('CompanyUpdateOneRequiredWithoutOffersNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutOffersNestedInputFields,
});

export const DepartmentUpdateOneWithoutOffersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":DepartmentCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":DepartmentCreateOrConnectWithoutOffersInput}),
  upsert: t.field({"required":false,"type":DepartmentUpsertWithoutOffersInput}),
  disconnect: t.field({"required":false,"type":DepartmentWhereInput}),
  delete: t.field({"required":false,"type":DepartmentWhereInput}),
  connect: t.field({"required":false,"type":DepartmentWhereUniqueInput}),
  update: t.field({"required":false,"type":DepartmentUpdateToOneWithWhereWithoutOffersInput}),
});
export const DepartmentUpdateOneWithoutOffersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateOneWithoutOffersNestedInput>>('DepartmentUpdateOneWithoutOffersNestedInput').implement({
  fields: DepartmentUpdateOneWithoutOffersNestedInputFields,
});

export const HiringRoleUpdateOneWithoutOfferRecruiterNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutOfferRecruiterInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutOfferRecruiterInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutOfferRecruiterInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInput}),
});
export const HiringRoleUpdateOneWithoutOfferRecruiterNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutOfferRecruiterNestedInput>>('HiringRoleUpdateOneWithoutOfferRecruiterNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutOfferRecruiterNestedInputFields,
});

export const HiringRoleUpdateOneWithoutOfferHiringManagerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutOfferHiringManagerInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutOfferHiringManagerInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutOfferHiringManagerInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInput}),
});
export const HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput>>('HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutOfferHiringManagerNestedInputFields,
});

export const TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutScreeningQuestionsTemplateInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInput}),
  upsert: t.field({"required":false,"type":TemplateUpsertWithoutScreeningQuestionsTemplateInput}),
  disconnect: t.field({"required":false,"type":TemplateWhereInput}),
  delete: t.field({"required":false,"type":TemplateWhereInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":false,"type":TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInput}),
});
export const TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput>>('TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput').implement({
  fields: TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInputFields,
});

export const TemplateUpdateOneWithoutPipelineTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutPipelineTemplateInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutPipelineTemplateInput}),
  upsert: t.field({"required":false,"type":TemplateUpsertWithoutPipelineTemplateInput}),
  disconnect: t.field({"required":false,"type":TemplateWhereInput}),
  delete: t.field({"required":false,"type":TemplateWhereInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":false,"type":TemplateUpdateToOneWithWhereWithoutPipelineTemplateInput}),
});
export const TemplateUpdateOneWithoutPipelineTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateOneWithoutPipelineTemplateNestedInput>>('TemplateUpdateOneWithoutPipelineTemplateNestedInput').implement({
  fields: TemplateUpdateOneWithoutPipelineTemplateNestedInputFields,
});

export const TemplateUpdateOneWithoutAutoConfirmationEmailNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutAutoConfirmationEmailInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutAutoConfirmationEmailInput}),
  upsert: t.field({"required":false,"type":TemplateUpsertWithoutAutoConfirmationEmailInput}),
  disconnect: t.field({"required":false,"type":TemplateWhereInput}),
  delete: t.field({"required":false,"type":TemplateWhereInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":false,"type":TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInput}),
});
export const TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput>>('TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput').implement({
  fields: TemplateUpdateOneWithoutAutoConfirmationEmailNestedInputFields,
});

export const AuditLogUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[AuditLogUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AuditLogUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[AuditLogUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
});
export const AuditLogUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithoutOfferNestedInput>>('AuditLogUpdateManyWithoutOfferNestedInput').implement({
  fields: AuditLogUpdateManyWithoutOfferNestedInputFields,
});

export const OfferFileUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferFileCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferFileCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[OfferFileUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":OfferFileCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferFileWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferFileUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[OfferFileUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[OfferFileScalarWhereInput]}),
});
export const OfferFileUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateManyWithoutOfferNestedInput>>('OfferFileUpdateManyWithoutOfferNestedInput').implement({
  fields: OfferFileUpdateManyWithoutOfferNestedInputFields,
});

export const OfferTagUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferTagCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferTagCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[OfferTagUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":OfferTagCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferTagWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferTagUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[OfferTagUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[OfferTagScalarWhereInput]}),
});
export const OfferTagUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateManyWithoutOfferNestedInput>>('OfferTagUpdateManyWithoutOfferNestedInput').implement({
  fields: OfferTagUpdateManyWithoutOfferNestedInputFields,
});

export const MembershipUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MembershipCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[MembershipCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[MembershipUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":MembershipCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MembershipWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MembershipUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[MembershipUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
});
export const MembershipUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithoutOfferNestedInput>>('MembershipUpdateManyWithoutOfferNestedInput').implement({
  fields: MembershipUpdateManyWithoutOfferNestedInputFields,
});

export const MatchUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[MatchUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MatchUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[MatchUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[MatchScalarWhereInput]}),
});
export const MatchUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithoutOfferNestedInput>>('MatchUpdateManyWithoutOfferNestedInput').implement({
  fields: MatchUpdateManyWithoutOfferNestedInputFields,
});

export const CandidateUpdateManyWithoutHiredAtNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCreateWithoutHiredAtInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCreateOrConnectWithoutHiredAtInput]}),
  upsert: t.field({"required":false,"type":[CandidateUpsertWithWhereUniqueWithoutHiredAtInput]}),
  createMany: t.field({"required":false,"type":CandidateCreateManyHiredAtInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateUpdateWithWhereUniqueWithoutHiredAtInput]}),
  updateMany: t.field({"required":false,"type":[CandidateUpdateManyWithWhereWithoutHiredAtInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
});
export const CandidateUpdateManyWithoutHiredAtNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithoutHiredAtNestedInput>>('CandidateUpdateManyWithoutHiredAtNestedInput').implement({
  fields: CandidateUpdateManyWithoutHiredAtNestedInputFields,
});

export const EvaluationUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[EvaluationUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
});
export const EvaluationUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithoutOfferNestedInput>>('EvaluationUpdateManyWithoutOfferNestedInput').implement({
  fields: EvaluationUpdateManyWithoutOfferNestedInputFields,
});

export const FollowUpdateManyWithoutOfferNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutOfferInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutOfferInput]}),
  upsert: t.field({"required":false,"type":[FollowUpsertWithWhereUniqueWithoutOfferInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyOfferInputEnvelope}),
  set: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  update: t.field({"required":false,"type":[FollowUpdateWithWhereUniqueWithoutOfferInput]}),
  updateMany: t.field({"required":false,"type":[FollowUpdateManyWithWhereWithoutOfferInput]}),
  deleteMany: t.field({"required":false,"type":[FollowScalarWhereInput]}),
});
export const FollowUpdateManyWithoutOfferNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithoutOfferNestedInput>>('FollowUpdateManyWithoutOfferNestedInput').implement({
  fields: FollowUpdateManyWithoutOfferNestedInputFields,
});

export const OfferCreateNestedOneWithoutFilesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutFilesInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutFilesInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutFilesInput>>('OfferCreateNestedOneWithoutFilesInput').implement({
  fields: OfferCreateNestedOneWithoutFilesInputFields,
});

export const AttachmentCreateNestedOneWithoutOfferFilesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutOfferFilesInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutOfferFilesInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutOfferFilesInput>>('AttachmentCreateNestedOneWithoutOfferFilesInput').implement({
  fields: AttachmentCreateNestedOneWithoutOfferFilesInputFields,
});

export const OfferUpdateOneRequiredWithoutFilesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutFilesInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutFilesInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutFilesInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutFilesInput}),
});
export const OfferUpdateOneRequiredWithoutFilesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneRequiredWithoutFilesNestedInput>>('OfferUpdateOneRequiredWithoutFilesNestedInput').implement({
  fields: OfferUpdateOneRequiredWithoutFilesNestedInputFields,
});

export const AttachmentUpdateOneRequiredWithoutOfferFilesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutOfferFilesInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutOfferFilesInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutOfferFilesInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutOfferFilesInput}),
});
export const AttachmentUpdateOneRequiredWithoutOfferFilesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneRequiredWithoutOfferFilesNestedInput>>('AttachmentUpdateOneRequiredWithoutOfferFilesNestedInput').implement({
  fields: AttachmentUpdateOneRequiredWithoutOfferFilesNestedInputFields,
});

export const OfferCreateNestedOneWithoutMatchesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutMatchesInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutMatchesInput>>('OfferCreateNestedOneWithoutMatchesInput').implement({
  fields: OfferCreateNestedOneWithoutMatchesInputFields,
});

export const CandidateCreateNestedOneWithoutOffersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutOffersInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutOffersInput>>('CandidateCreateNestedOneWithoutOffersInput').implement({
  fields: CandidateCreateNestedOneWithoutOffersInputFields,
});

export const StageCreateNestedOneWithoutMatchesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutMatchesInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
});
export const StageCreateNestedOneWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateNestedOneWithoutMatchesInput>>('StageCreateNestedOneWithoutMatchesInput').implement({
  fields: StageCreateNestedOneWithoutMatchesInputFields,
});

export const DisqualifyReasonCreateNestedOneWithoutMatchesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":DisqualifyReasonCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":DisqualifyReasonCreateOrConnectWithoutMatchesInput}),
  connect: t.field({"required":false,"type":DisqualifyReasonWhereUniqueInput}),
});
export const DisqualifyReasonCreateNestedOneWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateNestedOneWithoutMatchesInput>>('DisqualifyReasonCreateNestedOneWithoutMatchesInput').implement({
  fields: DisqualifyReasonCreateNestedOneWithoutMatchesInputFields,
});

export const OfferUpdateOneRequiredWithoutMatchesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutMatchesInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutMatchesInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutMatchesInput}),
});
export const OfferUpdateOneRequiredWithoutMatchesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneRequiredWithoutMatchesNestedInput>>('OfferUpdateOneRequiredWithoutMatchesNestedInput').implement({
  fields: OfferUpdateOneRequiredWithoutMatchesNestedInputFields,
});

export const CandidateUpdateOneRequiredWithoutOffersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutOffersInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutOffersInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutOffersInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutOffersInput}),
});
export const CandidateUpdateOneRequiredWithoutOffersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutOffersNestedInput>>('CandidateUpdateOneRequiredWithoutOffersNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutOffersNestedInputFields,
});

export const StageUpdateOneWithoutMatchesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutMatchesInput}),
  upsert: t.field({"required":false,"type":StageUpsertWithoutMatchesInput}),
  disconnect: t.field({"required":false,"type":StageWhereInput}),
  delete: t.field({"required":false,"type":StageWhereInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
  update: t.field({"required":false,"type":StageUpdateToOneWithWhereWithoutMatchesInput}),
});
export const StageUpdateOneWithoutMatchesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateOneWithoutMatchesNestedInput>>('StageUpdateOneWithoutMatchesNestedInput').implement({
  fields: StageUpdateOneWithoutMatchesNestedInputFields,
});

export const DisqualifyReasonUpdateOneWithoutMatchesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":DisqualifyReasonCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":DisqualifyReasonCreateOrConnectWithoutMatchesInput}),
  upsert: t.field({"required":false,"type":DisqualifyReasonUpsertWithoutMatchesInput}),
  disconnect: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  delete: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  connect: t.field({"required":false,"type":DisqualifyReasonWhereUniqueInput}),
  update: t.field({"required":false,"type":DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInput}),
});
export const DisqualifyReasonUpdateOneWithoutMatchesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateOneWithoutMatchesNestedInput>>('DisqualifyReasonUpdateOneWithoutMatchesNestedInput').implement({
  fields: DisqualifyReasonUpdateOneWithoutMatchesNestedInputFields,
});

export const OfferCreateNestedOneWithoutOfferTagsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutOfferTagsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutOfferTagsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutOfferTagsInput>>('OfferCreateNestedOneWithoutOfferTagsInput').implement({
  fields: OfferCreateNestedOneWithoutOfferTagsInputFields,
});

export const TagSourceCreateNestedOneWithoutOfferTagsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutOfferTagsInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutOfferTagsInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
});
export const TagSourceCreateNestedOneWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateNestedOneWithoutOfferTagsInput>>('TagSourceCreateNestedOneWithoutOfferTagsInput').implement({
  fields: TagSourceCreateNestedOneWithoutOfferTagsInputFields,
});

export const OfferUpdateOneRequiredWithoutOfferTagsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutOfferTagsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutOfferTagsInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutOfferTagsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutOfferTagsInput}),
});
export const OfferUpdateOneRequiredWithoutOfferTagsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneRequiredWithoutOfferTagsNestedInput>>('OfferUpdateOneRequiredWithoutOfferTagsNestedInput').implement({
  fields: OfferUpdateOneRequiredWithoutOfferTagsNestedInputFields,
});

export const TagSourceUpdateOneRequiredWithoutOfferTagsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutOfferTagsInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutOfferTagsInput}),
  upsert: t.field({"required":false,"type":TagSourceUpsertWithoutOfferTagsInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
  update: t.field({"required":false,"type":TagSourceUpdateToOneWithWhereWithoutOfferTagsInput}),
});
export const TagSourceUpdateOneRequiredWithoutOfferTagsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateOneRequiredWithoutOfferTagsNestedInput>>('TagSourceUpdateOneRequiredWithoutOfferTagsNestedInput').implement({
  fields: TagSourceUpdateOneRequiredWithoutOfferTagsNestedInputFields,
});

export const HiringRoleCreateNestedOneWithoutMembershipsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutMembershipsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutMembershipsInput>>('HiringRoleCreateNestedOneWithoutMembershipsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutMembershipsInputFields,
});

export const RoleCreateNestedOneWithoutMembershipsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutMembershipsInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
});
export const RoleCreateNestedOneWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateNestedOneWithoutMembershipsInput>>('RoleCreateNestedOneWithoutMembershipsInput').implement({
  fields: RoleCreateNestedOneWithoutMembershipsInputFields,
});

export const OfferCreateNestedOneWithoutMembershipsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutMembershipsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutMembershipsInput>>('OfferCreateNestedOneWithoutMembershipsInput').implement({
  fields: OfferCreateNestedOneWithoutMembershipsInputFields,
});

export const EnumMembershipTypesFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":MembershipTypes}),
});
export const EnumMembershipTypesFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumMembershipTypesFieldUpdateOperationsInput>>('EnumMembershipTypesFieldUpdateOperationsInput').implement({
  fields: EnumMembershipTypesFieldUpdateOperationsInputFields,
});

export const HiringRoleUpdateOneWithoutMembershipsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutMembershipsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutMembershipsInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutMembershipsInput}),
});
export const HiringRoleUpdateOneWithoutMembershipsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutMembershipsNestedInput>>('HiringRoleUpdateOneWithoutMembershipsNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutMembershipsNestedInputFields,
});

export const RoleUpdateOneWithoutMembershipsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutMembershipsInput}),
  upsert: t.field({"required":false,"type":RoleUpsertWithoutMembershipsInput}),
  disconnect: t.field({"required":false,"type":RoleWhereInput}),
  delete: t.field({"required":false,"type":RoleWhereInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
  update: t.field({"required":false,"type":RoleUpdateToOneWithWhereWithoutMembershipsInput}),
});
export const RoleUpdateOneWithoutMembershipsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateOneWithoutMembershipsNestedInput>>('RoleUpdateOneWithoutMembershipsNestedInput').implement({
  fields: RoleUpdateOneWithoutMembershipsNestedInputFields,
});

export const OfferUpdateOneRequiredWithoutMembershipsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutMembershipsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutMembershipsInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutMembershipsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutMembershipsInput}),
});
export const OfferUpdateOneRequiredWithoutMembershipsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneRequiredWithoutMembershipsNestedInput>>('OfferUpdateOneRequiredWithoutMembershipsNestedInput').implement({
  fields: OfferUpdateOneRequiredWithoutMembershipsNestedInputFields,
});

export const TalentPoolFileCreateNestedManyWithoutTalentPoolInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolFileCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolFileCreateOrConnectWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":TalentPoolFileCreateManyTalentPoolInputEnvelope}),
  connect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
});
export const TalentPoolFileCreateNestedManyWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateNestedManyWithoutTalentPoolInput>>('TalentPoolFileCreateNestedManyWithoutTalentPoolInput').implement({
  fields: TalentPoolFileCreateNestedManyWithoutTalentPoolInputFields,
});

export const TalentPoolMatchCreateNestedManyWithoutTalentPoolInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolMatchCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolMatchCreateOrConnectWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":TalentPoolMatchCreateManyTalentPoolInputEnvelope}),
  connect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
});
export const TalentPoolMatchCreateNestedManyWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateNestedManyWithoutTalentPoolInput>>('TalentPoolMatchCreateNestedManyWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchCreateNestedManyWithoutTalentPoolInputFields,
});

export const FollowCreateNestedManyWithoutTalentPoolInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyTalentPoolInputEnvelope}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
});
export const FollowCreateNestedManyWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateNestedManyWithoutTalentPoolInput>>('FollowCreateNestedManyWithoutTalentPoolInput').implement({
  fields: FollowCreateNestedManyWithoutTalentPoolInputFields,
});

export const CompanyCreateNestedOneWithoutTalentPoolInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTalentPoolInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTalentPoolInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutTalentPoolInput>>('CompanyCreateNestedOneWithoutTalentPoolInput').implement({
  fields: CompanyCreateNestedOneWithoutTalentPoolInputFields,
});

export const TalentPoolFileUpdateManyWithoutTalentPoolNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolFileCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolFileCreateOrConnectWithoutTalentPoolInput]}),
  upsert: t.field({"required":false,"type":[TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":TalentPoolFileCreateManyTalentPoolInputEnvelope}),
  set: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TalentPoolFileWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInput]}),
  updateMany: t.field({"required":false,"type":[TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInput]}),
  deleteMany: t.field({"required":false,"type":[TalentPoolFileScalarWhereInput]}),
});
export const TalentPoolFileUpdateManyWithoutTalentPoolNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateManyWithoutTalentPoolNestedInput>>('TalentPoolFileUpdateManyWithoutTalentPoolNestedInput').implement({
  fields: TalentPoolFileUpdateManyWithoutTalentPoolNestedInputFields,
});

export const TalentPoolMatchUpdateManyWithoutTalentPoolNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolMatchCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolMatchCreateOrConnectWithoutTalentPoolInput]}),
  upsert: t.field({"required":false,"type":[TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":TalentPoolMatchCreateManyTalentPoolInputEnvelope}),
  set: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInput]}),
  updateMany: t.field({"required":false,"type":[TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInput]}),
  deleteMany: t.field({"required":false,"type":[TalentPoolMatchScalarWhereInput]}),
});
export const TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput>>('TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput').implement({
  fields: TalentPoolMatchUpdateManyWithoutTalentPoolNestedInputFields,
});

export const FollowUpdateManyWithoutTalentPoolNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutTalentPoolInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutTalentPoolInput]}),
  upsert: t.field({"required":false,"type":[FollowUpsertWithWhereUniqueWithoutTalentPoolInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyTalentPoolInputEnvelope}),
  set: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  update: t.field({"required":false,"type":[FollowUpdateWithWhereUniqueWithoutTalentPoolInput]}),
  updateMany: t.field({"required":false,"type":[FollowUpdateManyWithWhereWithoutTalentPoolInput]}),
  deleteMany: t.field({"required":false,"type":[FollowScalarWhereInput]}),
});
export const FollowUpdateManyWithoutTalentPoolNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithoutTalentPoolNestedInput>>('FollowUpdateManyWithoutTalentPoolNestedInput').implement({
  fields: FollowUpdateManyWithoutTalentPoolNestedInputFields,
});

export const CompanyUpdateOneRequiredWithoutTalentPoolNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTalentPoolInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTalentPoolInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutTalentPoolInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutTalentPoolInput}),
});
export const CompanyUpdateOneRequiredWithoutTalentPoolNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutTalentPoolNestedInput>>('CompanyUpdateOneRequiredWithoutTalentPoolNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutTalentPoolNestedInputFields,
});

export const TalentPoolCreateNestedOneWithoutFilesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutFilesInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutFilesInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
});
export const TalentPoolCreateNestedOneWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateNestedOneWithoutFilesInput>>('TalentPoolCreateNestedOneWithoutFilesInput').implement({
  fields: TalentPoolCreateNestedOneWithoutFilesInputFields,
});

export const AttachmentCreateNestedOneWithoutTalentPoolFilesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutTalentPoolFilesInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutTalentPoolFilesInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutTalentPoolFilesInput>>('AttachmentCreateNestedOneWithoutTalentPoolFilesInput').implement({
  fields: AttachmentCreateNestedOneWithoutTalentPoolFilesInputFields,
});

export const TalentPoolUpdateOneRequiredWithoutFilesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutFilesInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutFilesInput}),
  upsert: t.field({"required":false,"type":TalentPoolUpsertWithoutFilesInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
  update: t.field({"required":false,"type":TalentPoolUpdateToOneWithWhereWithoutFilesInput}),
});
export const TalentPoolUpdateOneRequiredWithoutFilesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateOneRequiredWithoutFilesNestedInput>>('TalentPoolUpdateOneRequiredWithoutFilesNestedInput').implement({
  fields: TalentPoolUpdateOneRequiredWithoutFilesNestedInputFields,
});

export const AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutTalentPoolFilesInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutTalentPoolFilesInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutTalentPoolFilesInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInput}),
});
export const AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInput>>('AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInput').implement({
  fields: AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInputFields,
});

export const TalentPoolCreateNestedOneWithoutMatchesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutMatchesInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
});
export const TalentPoolCreateNestedOneWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateNestedOneWithoutMatchesInput>>('TalentPoolCreateNestedOneWithoutMatchesInput').implement({
  fields: TalentPoolCreateNestedOneWithoutMatchesInputFields,
});

export const CandidateCreateNestedOneWithoutTalentPoolsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutTalentPoolsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutTalentPoolsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutTalentPoolsInput>>('CandidateCreateNestedOneWithoutTalentPoolsInput').implement({
  fields: CandidateCreateNestedOneWithoutTalentPoolsInputFields,
});

export const TalentPoolUpdateOneRequiredWithoutMatchesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutMatchesInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutMatchesInput}),
  upsert: t.field({"required":false,"type":TalentPoolUpsertWithoutMatchesInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
  update: t.field({"required":false,"type":TalentPoolUpdateToOneWithWhereWithoutMatchesInput}),
});
export const TalentPoolUpdateOneRequiredWithoutMatchesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateOneRequiredWithoutMatchesNestedInput>>('TalentPoolUpdateOneRequiredWithoutMatchesNestedInput').implement({
  fields: TalentPoolUpdateOneRequiredWithoutMatchesNestedInputFields,
});

export const CandidateUpdateOneRequiredWithoutTalentPoolsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutTalentPoolsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutTalentPoolsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutTalentPoolsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutTalentPoolsInput}),
});
export const CandidateUpdateOneRequiredWithoutTalentPoolsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutTalentPoolsNestedInput>>('CandidateUpdateOneRequiredWithoutTalentPoolsNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutTalentPoolsNestedInputFields,
});

export const CompanyCreateNestedOneWithoutTemplatesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTemplatesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTemplatesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutTemplatesInput>>('CompanyCreateNestedOneWithoutTemplatesInput').implement({
  fields: CompanyCreateNestedOneWithoutTemplatesInputFields,
});

export const OfferCreateNestedManyWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutScreeningQuestionsTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutScreeningQuestionsTemplateInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyScreeningQuestionsTemplateInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
});
export const OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput>>('OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferCreateNestedManyWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferCreateNestedManyWithoutPipelineTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutPipelineTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutPipelineTemplateInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyPipelineTemplateInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
});
export const OfferCreateNestedManyWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedManyWithoutPipelineTemplateInput>>('OfferCreateNestedManyWithoutPipelineTemplateInput').implement({
  fields: OfferCreateNestedManyWithoutPipelineTemplateInputFields,
});

export const OfferCreateNestedManyWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutAutoConfirmationEmailInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutAutoConfirmationEmailInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyAutoConfirmationEmailInputEnvelope}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
});
export const OfferCreateNestedManyWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedManyWithoutAutoConfirmationEmailInput>>('OfferCreateNestedManyWithoutAutoConfirmationEmailInput').implement({
  fields: OfferCreateNestedManyWithoutAutoConfirmationEmailInputFields,
});

export const StageCreateNestedManyWithoutTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageCreateWithoutTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageCreateOrConnectWithoutTemplateInput]}),
  createMany: t.field({"required":false,"type":StageCreateManyTemplateInputEnvelope}),
  connect: t.field({"required":false,"type":[StageWhereUniqueInput]}),
});
export const StageCreateNestedManyWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateNestedManyWithoutTemplateInput>>('StageCreateNestedManyWithoutTemplateInput').implement({
  fields: StageCreateNestedManyWithoutTemplateInputFields,
});

export const EvaluationCreateNestedManyWithoutTemplateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutTemplateInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyTemplateInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
});
export const EvaluationCreateNestedManyWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedManyWithoutTemplateInput>>('EvaluationCreateNestedManyWithoutTemplateInput').implement({
  fields: EvaluationCreateNestedManyWithoutTemplateInputFields,
});

export const EnumTemplateTypesFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":TemplateTypes}),
});
export const EnumTemplateTypesFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumTemplateTypesFieldUpdateOperationsInput>>('EnumTemplateTypesFieldUpdateOperationsInput').implement({
  fields: EnumTemplateTypesFieldUpdateOperationsInputFields,
});

export const CompanyUpdateOneRequiredWithoutTemplatesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTemplatesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTemplatesInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutTemplatesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutTemplatesInput}),
});
export const CompanyUpdateOneRequiredWithoutTemplatesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutTemplatesNestedInput>>('CompanyUpdateOneRequiredWithoutTemplatesNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutTemplatesNestedInputFields,
});

export const OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutScreeningQuestionsTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutScreeningQuestionsTemplateInput]}),
  upsert: t.field({"required":false,"type":[OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyScreeningQuestionsTemplateInputEnvelope}),
  set: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInput]}),
  updateMany: t.field({"required":false,"type":[OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInput]}),
  deleteMany: t.field({"required":false,"type":[OfferScalarWhereInput]}),
});
export const OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput>>('OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput').implement({
  fields: OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInputFields,
});

export const OfferUpdateManyWithoutPipelineTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutPipelineTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutPipelineTemplateInput]}),
  upsert: t.field({"required":false,"type":[OfferUpsertWithWhereUniqueWithoutPipelineTemplateInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyPipelineTemplateInputEnvelope}),
  set: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferUpdateWithWhereUniqueWithoutPipelineTemplateInput]}),
  updateMany: t.field({"required":false,"type":[OfferUpdateManyWithWhereWithoutPipelineTemplateInput]}),
  deleteMany: t.field({"required":false,"type":[OfferScalarWhereInput]}),
});
export const OfferUpdateManyWithoutPipelineTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithoutPipelineTemplateNestedInput>>('OfferUpdateManyWithoutPipelineTemplateNestedInput').implement({
  fields: OfferUpdateManyWithoutPipelineTemplateNestedInputFields,
});

export const OfferUpdateManyWithoutAutoConfirmationEmailNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[OfferCreateWithoutAutoConfirmationEmailInput]}),
  connectOrCreate: t.field({"required":false,"type":[OfferCreateOrConnectWithoutAutoConfirmationEmailInput]}),
  upsert: t.field({"required":false,"type":[OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInput]}),
  createMany: t.field({"required":false,"type":OfferCreateManyAutoConfirmationEmailInputEnvelope}),
  set: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[OfferWhereUniqueInput]}),
  update: t.field({"required":false,"type":[OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInput]}),
  updateMany: t.field({"required":false,"type":[OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInput]}),
  deleteMany: t.field({"required":false,"type":[OfferScalarWhereInput]}),
});
export const OfferUpdateManyWithoutAutoConfirmationEmailNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithoutAutoConfirmationEmailNestedInput>>('OfferUpdateManyWithoutAutoConfirmationEmailNestedInput').implement({
  fields: OfferUpdateManyWithoutAutoConfirmationEmailNestedInputFields,
});

export const StageUpdateManyWithoutTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageCreateWithoutTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageCreateOrConnectWithoutTemplateInput]}),
  upsert: t.field({"required":false,"type":[StageUpsertWithWhereUniqueWithoutTemplateInput]}),
  createMany: t.field({"required":false,"type":StageCreateManyTemplateInputEnvelope}),
  set: t.field({"required":false,"type":[StageWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[StageWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[StageWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[StageWhereUniqueInput]}),
  update: t.field({"required":false,"type":[StageUpdateWithWhereUniqueWithoutTemplateInput]}),
  updateMany: t.field({"required":false,"type":[StageUpdateManyWithWhereWithoutTemplateInput]}),
  deleteMany: t.field({"required":false,"type":[StageScalarWhereInput]}),
});
export const StageUpdateManyWithoutTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateManyWithoutTemplateNestedInput>>('StageUpdateManyWithoutTemplateNestedInput').implement({
  fields: StageUpdateManyWithoutTemplateNestedInputFields,
});

export const EvaluationUpdateManyWithoutTemplateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutTemplateInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutTemplateInput]}),
  upsert: t.field({"required":false,"type":[EvaluationUpsertWithWhereUniqueWithoutTemplateInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyTemplateInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationUpdateWithWhereUniqueWithoutTemplateInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationUpdateManyWithWhereWithoutTemplateInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
});
export const EvaluationUpdateManyWithoutTemplateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithoutTemplateNestedInput>>('EvaluationUpdateManyWithoutTemplateNestedInput').implement({
  fields: EvaluationUpdateManyWithoutTemplateNestedInputFields,
});

export const TemplateCreateNestedOneWithoutStagesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutStagesInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutStagesInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
});
export const TemplateCreateNestedOneWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedOneWithoutStagesInput>>('TemplateCreateNestedOneWithoutStagesInput').implement({
  fields: TemplateCreateNestedOneWithoutStagesInputFields,
});

export const MatchCreateNestedManyWithoutStageInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutStageInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyStageInputEnvelope}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
});
export const MatchCreateNestedManyWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateNestedManyWithoutStageInput>>('MatchCreateNestedManyWithoutStageInput').implement({
  fields: MatchCreateNestedManyWithoutStageInputFields,
});

export const StageVisibilityCreateNestedManyWithoutStageInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutStageInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyStageInputEnvelope}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
});
export const StageVisibilityCreateNestedManyWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateNestedManyWithoutStageInput>>('StageVisibilityCreateNestedManyWithoutStageInput').implement({
  fields: StageVisibilityCreateNestedManyWithoutStageInputFields,
});

export const StageMetadataCreateNestedManyWithoutStageInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageMetadataCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageMetadataCreateOrConnectWithoutStageInput]}),
  createMany: t.field({"required":false,"type":StageMetadataCreateManyStageInputEnvelope}),
  connect: t.field({"required":false,"type":[StageMetadataWhereUniqueInput]}),
});
export const StageMetadataCreateNestedManyWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateNestedManyWithoutStageInput>>('StageMetadataCreateNestedManyWithoutStageInput').implement({
  fields: StageMetadataCreateNestedManyWithoutStageInputFields,
});

export const TemplateUpdateOneRequiredWithoutStagesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutStagesInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutStagesInput}),
  upsert: t.field({"required":false,"type":TemplateUpsertWithoutStagesInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":false,"type":TemplateUpdateToOneWithWhereWithoutStagesInput}),
});
export const TemplateUpdateOneRequiredWithoutStagesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateOneRequiredWithoutStagesNestedInput>>('TemplateUpdateOneRequiredWithoutStagesNestedInput').implement({
  fields: TemplateUpdateOneRequiredWithoutStagesNestedInputFields,
});

export const MatchUpdateManyWithoutStageNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutStageInput]}),
  upsert: t.field({"required":false,"type":[MatchUpsertWithWhereUniqueWithoutStageInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyStageInputEnvelope}),
  set: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MatchUpdateWithWhereUniqueWithoutStageInput]}),
  updateMany: t.field({"required":false,"type":[MatchUpdateManyWithWhereWithoutStageInput]}),
  deleteMany: t.field({"required":false,"type":[MatchScalarWhereInput]}),
});
export const MatchUpdateManyWithoutStageNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithoutStageNestedInput>>('MatchUpdateManyWithoutStageNestedInput').implement({
  fields: MatchUpdateManyWithoutStageNestedInputFields,
});

export const StageVisibilityUpdateManyWithoutStageNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageVisibilityCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageVisibilityCreateOrConnectWithoutStageInput]}),
  upsert: t.field({"required":false,"type":[StageVisibilityUpsertWithWhereUniqueWithoutStageInput]}),
  createMany: t.field({"required":false,"type":StageVisibilityCreateManyStageInputEnvelope}),
  set: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[StageVisibilityWhereUniqueInput]}),
  update: t.field({"required":false,"type":[StageVisibilityUpdateWithWhereUniqueWithoutStageInput]}),
  updateMany: t.field({"required":false,"type":[StageVisibilityUpdateManyWithWhereWithoutStageInput]}),
  deleteMany: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
});
export const StageVisibilityUpdateManyWithoutStageNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithoutStageNestedInput>>('StageVisibilityUpdateManyWithoutStageNestedInput').implement({
  fields: StageVisibilityUpdateManyWithoutStageNestedInputFields,
});

export const StageMetadataUpdateManyWithoutStageNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[StageMetadataCreateWithoutStageInput]}),
  connectOrCreate: t.field({"required":false,"type":[StageMetadataCreateOrConnectWithoutStageInput]}),
  upsert: t.field({"required":false,"type":[StageMetadataUpsertWithWhereUniqueWithoutStageInput]}),
  createMany: t.field({"required":false,"type":StageMetadataCreateManyStageInputEnvelope}),
  set: t.field({"required":false,"type":[StageMetadataWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[StageMetadataWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[StageMetadataWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[StageMetadataWhereUniqueInput]}),
  update: t.field({"required":false,"type":[StageMetadataUpdateWithWhereUniqueWithoutStageInput]}),
  updateMany: t.field({"required":false,"type":[StageMetadataUpdateManyWithWhereWithoutStageInput]}),
  deleteMany: t.field({"required":false,"type":[StageMetadataScalarWhereInput]}),
});
export const StageMetadataUpdateManyWithoutStageNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateManyWithoutStageNestedInput>>('StageMetadataUpdateManyWithoutStageNestedInput').implement({
  fields: StageMetadataUpdateManyWithoutStageNestedInputFields,
});

export const HiringRoleCreateNestedOneWithoutStageVisibilitiesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutStageVisibilitiesInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutStageVisibilitiesInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutStageVisibilitiesInput>>('HiringRoleCreateNestedOneWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleCreateNestedOneWithoutStageVisibilitiesInputFields,
});

export const RoleCreateNestedOneWithoutStageVisibilityInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutStageVisibilityInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutStageVisibilityInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
});
export const RoleCreateNestedOneWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateNestedOneWithoutStageVisibilityInput>>('RoleCreateNestedOneWithoutStageVisibilityInput').implement({
  fields: RoleCreateNestedOneWithoutStageVisibilityInputFields,
});

export const StageCreateNestedOneWithoutVisibilityInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutVisibilityInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutVisibilityInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
});
export const StageCreateNestedOneWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateNestedOneWithoutVisibilityInput>>('StageCreateNestedOneWithoutVisibilityInput').implement({
  fields: StageCreateNestedOneWithoutVisibilityInputFields,
});

export const HiringRoleUpdateOneWithoutStageVisibilitiesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutStageVisibilitiesInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutStageVisibilitiesInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutStageVisibilitiesInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInput}),
});
export const HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput>>('HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutStageVisibilitiesNestedInputFields,
});

export const RoleUpdateOneWithoutStageVisibilityNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":RoleCreateWithoutStageVisibilityInput}),
  connectOrCreate: t.field({"required":false,"type":RoleCreateOrConnectWithoutStageVisibilityInput}),
  upsert: t.field({"required":false,"type":RoleUpsertWithoutStageVisibilityInput}),
  disconnect: t.field({"required":false,"type":RoleWhereInput}),
  delete: t.field({"required":false,"type":RoleWhereInput}),
  connect: t.field({"required":false,"type":RoleWhereUniqueInput}),
  update: t.field({"required":false,"type":RoleUpdateToOneWithWhereWithoutStageVisibilityInput}),
});
export const RoleUpdateOneWithoutStageVisibilityNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateOneWithoutStageVisibilityNestedInput>>('RoleUpdateOneWithoutStageVisibilityNestedInput').implement({
  fields: RoleUpdateOneWithoutStageVisibilityNestedInputFields,
});

export const StageUpdateOneRequiredWithoutVisibilityNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutVisibilityInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutVisibilityInput}),
  upsert: t.field({"required":false,"type":StageUpsertWithoutVisibilityInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
  update: t.field({"required":false,"type":StageUpdateToOneWithWhereWithoutVisibilityInput}),
});
export const StageUpdateOneRequiredWithoutVisibilityNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateOneRequiredWithoutVisibilityNestedInput>>('StageUpdateOneRequiredWithoutVisibilityNestedInput').implement({
  fields: StageUpdateOneRequiredWithoutVisibilityNestedInputFields,
});

export const StageCreateNestedOneWithoutMetadataInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutMetadataInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutMetadataInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
});
export const StageCreateNestedOneWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateNestedOneWithoutMetadataInput>>('StageCreateNestedOneWithoutMetadataInput').implement({
  fields: StageCreateNestedOneWithoutMetadataInputFields,
});

export const StageUpdateOneRequiredWithoutMetadataNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":StageCreateWithoutMetadataInput}),
  connectOrCreate: t.field({"required":false,"type":StageCreateOrConnectWithoutMetadataInput}),
  upsert: t.field({"required":false,"type":StageUpsertWithoutMetadataInput}),
  connect: t.field({"required":false,"type":StageWhereUniqueInput}),
  update: t.field({"required":false,"type":StageUpdateToOneWithWhereWithoutMetadataInput}),
});
export const StageUpdateOneRequiredWithoutMetadataNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateOneRequiredWithoutMetadataNestedInput>>('StageUpdateOneRequiredWithoutMetadataNestedInput').implement({
  fields: StageUpdateOneRequiredWithoutMetadataNestedInputFields,
});

export const CandidateCreateskillsInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const CandidateCreateskillsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateskillsInput>>('CandidateCreateskillsInput').implement({
  fields: CandidateCreateskillsInputFields,
});

export const CandidateCreatelanguagesInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const CandidateCreatelanguagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreatelanguagesInput>>('CandidateCreatelanguagesInput').implement({
  fields: CandidateCreatelanguagesInputFields,
});

export const CandidateCreatesocialsInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const CandidateCreatesocialsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreatesocialsInput>>('CandidateCreatesocialsInput').implement({
  fields: CandidateCreatesocialsInputFields,
});

export const CandidateCreatelinksInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const CandidateCreatelinksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreatelinksInput>>('CandidateCreatelinksInput').implement({
  fields: CandidateCreatelinksInputFields,
});

export const TagSourceCreateNestedOneWithoutCandidateReferrerInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutCandidateReferrerInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutCandidateReferrerInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
});
export const TagSourceCreateNestedOneWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateNestedOneWithoutCandidateReferrerInput>>('TagSourceCreateNestedOneWithoutCandidateReferrerInput').implement({
  fields: TagSourceCreateNestedOneWithoutCandidateReferrerInputFields,
});

export const AttachmentCreateNestedOneWithoutCandidateCvInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateCvInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateCvInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutCandidateCvInput>>('AttachmentCreateNestedOneWithoutCandidateCvInput').implement({
  fields: AttachmentCreateNestedOneWithoutCandidateCvInputFields,
});

export const AttachmentCreateNestedOneWithoutCandidateAvatarInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateAvatarInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateAvatarInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutCandidateAvatarInput>>('AttachmentCreateNestedOneWithoutCandidateAvatarInput').implement({
  fields: AttachmentCreateNestedOneWithoutCandidateAvatarInputFields,
});

export const AttachmentCreateNestedOneWithoutCandidateCoverLetterInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateCoverLetterInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateCoverLetterInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
});
export const AttachmentCreateNestedOneWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateNestedOneWithoutCandidateCoverLetterInput>>('AttachmentCreateNestedOneWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentCreateNestedOneWithoutCandidateCoverLetterInputFields,
});

export const OfferCreateNestedOneWithoutHiredInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutHiredInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutHiredInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutHiredInput>>('OfferCreateNestedOneWithoutHiredInput').implement({
  fields: OfferCreateNestedOneWithoutHiredInputFields,
});

export const HiringRoleCreateNestedOneWithoutHiredCandidatesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutHiredCandidatesInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutHiredCandidatesInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutHiredCandidatesInput>>('HiringRoleCreateNestedOneWithoutHiredCandidatesInput').implement({
  fields: HiringRoleCreateNestedOneWithoutHiredCandidatesInputFields,
});

export const AuditLogCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
});
export const AuditLogCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateNestedManyWithoutCandidateInput>>('AuditLogCreateNestedManyWithoutCandidateInput').implement({
  fields: AuditLogCreateNestedManyWithoutCandidateInputFields,
});

export const MatchCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
});
export const MatchCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateNestedManyWithoutCandidateInput>>('MatchCreateNestedManyWithoutCandidateInput').implement({
  fields: MatchCreateNestedManyWithoutCandidateInputFields,
});

export const TalentPoolMatchCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolMatchCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolMatchCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":TalentPoolMatchCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
});
export const TalentPoolMatchCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateNestedManyWithoutCandidateInput>>('TalentPoolMatchCreateNestedManyWithoutCandidateInput').implement({
  fields: TalentPoolMatchCreateNestedManyWithoutCandidateInputFields,
});

export const CandidateTagCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateTagCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateTagCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":CandidateTagCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
});
export const CandidateTagCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateNestedManyWithoutCandidateInput>>('CandidateTagCreateNestedManyWithoutCandidateInput').implement({
  fields: CandidateTagCreateNestedManyWithoutCandidateInputFields,
});

export const CandidateCustomFieldCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCustomFieldCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCustomFieldCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":CandidateCustomFieldCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
});
export const CandidateCustomFieldCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateNestedManyWithoutCandidateInput>>('CandidateCustomFieldCreateNestedManyWithoutCandidateInput').implement({
  fields: CandidateCustomFieldCreateNestedManyWithoutCandidateInputFields,
});

export const EvaluationCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
});
export const EvaluationCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedManyWithoutCandidateInput>>('EvaluationCreateNestedManyWithoutCandidateInput').implement({
  fields: EvaluationCreateNestedManyWithoutCandidateInputFields,
});

export const TaskCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":TaskCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
});
export const TaskCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateNestedManyWithoutCandidateInput>>('TaskCreateNestedManyWithoutCandidateInput').implement({
  fields: TaskCreateNestedManyWithoutCandidateInputFields,
});

export const FollowCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
});
export const FollowCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateNestedManyWithoutCandidateInput>>('FollowCreateNestedManyWithoutCandidateInput').implement({
  fields: FollowCreateNestedManyWithoutCandidateInputFields,
});

export const SharedCandidateLinkCreateNestedManyWithoutCandidateInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[SharedCandidateLinkCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[SharedCandidateLinkCreateOrConnectWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":SharedCandidateLinkCreateManyCandidateInputEnvelope}),
  connect: t.field({"required":false,"type":[SharedCandidateLinkWhereUniqueInput]}),
});
export const SharedCandidateLinkCreateNestedManyWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateNestedManyWithoutCandidateInput>>('SharedCandidateLinkCreateNestedManyWithoutCandidateInput').implement({
  fields: SharedCandidateLinkCreateNestedManyWithoutCandidateInputFields,
});

export const CompanyCreateNestedOneWithoutCandidatesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutCandidatesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutCandidatesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutCandidatesInput>>('CompanyCreateNestedOneWithoutCandidatesInput').implement({
  fields: CompanyCreateNestedOneWithoutCandidatesInputFields,
});

export const EventCreateNestedManyWithoutCandidatesInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCandidatesInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCandidatesInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
});
export const EventCreateNestedManyWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedManyWithoutCandidatesInput>>('EventCreateNestedManyWithoutCandidatesInput').implement({
  fields: EventCreateNestedManyWithoutCandidatesInputFields,
});

export const CandidateUpdateskillsInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const CandidateUpdateskillsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateskillsInput>>('CandidateUpdateskillsInput').implement({
  fields: CandidateUpdateskillsInputFields,
});

export const CandidateUpdatelanguagesInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const CandidateUpdatelanguagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdatelanguagesInput>>('CandidateUpdatelanguagesInput').implement({
  fields: CandidateUpdatelanguagesInputFields,
});

export const CandidateUpdatesocialsInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const CandidateUpdatesocialsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdatesocialsInput>>('CandidateUpdatesocialsInput').implement({
  fields: CandidateUpdatesocialsInputFields,
});

export const CandidateUpdatelinksInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const CandidateUpdatelinksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdatelinksInput>>('CandidateUpdatelinksInput').implement({
  fields: CandidateUpdatelinksInputFields,
});

export const TagSourceUpdateOneWithoutCandidateReferrerNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutCandidateReferrerInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutCandidateReferrerInput}),
  upsert: t.field({"required":false,"type":TagSourceUpsertWithoutCandidateReferrerInput}),
  disconnect: t.field({"required":false,"type":TagSourceWhereInput}),
  delete: t.field({"required":false,"type":TagSourceWhereInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
  update: t.field({"required":false,"type":TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInput}),
});
export const TagSourceUpdateOneWithoutCandidateReferrerNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateOneWithoutCandidateReferrerNestedInput>>('TagSourceUpdateOneWithoutCandidateReferrerNestedInput').implement({
  fields: TagSourceUpdateOneWithoutCandidateReferrerNestedInputFields,
});

export const AttachmentUpdateOneWithoutCandidateCvNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateCvInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateCvInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutCandidateCvInput}),
  disconnect: t.field({"required":false,"type":AttachmentWhereInput}),
  delete: t.field({"required":false,"type":AttachmentWhereInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutCandidateCvInput}),
});
export const AttachmentUpdateOneWithoutCandidateCvNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneWithoutCandidateCvNestedInput>>('AttachmentUpdateOneWithoutCandidateCvNestedInput').implement({
  fields: AttachmentUpdateOneWithoutCandidateCvNestedInputFields,
});

export const AttachmentUpdateOneWithoutCandidateAvatarNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateAvatarInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateAvatarInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutCandidateAvatarInput}),
  disconnect: t.field({"required":false,"type":AttachmentWhereInput}),
  delete: t.field({"required":false,"type":AttachmentWhereInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInput}),
});
export const AttachmentUpdateOneWithoutCandidateAvatarNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneWithoutCandidateAvatarNestedInput>>('AttachmentUpdateOneWithoutCandidateAvatarNestedInput').implement({
  fields: AttachmentUpdateOneWithoutCandidateAvatarNestedInputFields,
});

export const AttachmentUpdateOneWithoutCandidateCoverLetterNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":AttachmentCreateWithoutCandidateCoverLetterInput}),
  connectOrCreate: t.field({"required":false,"type":AttachmentCreateOrConnectWithoutCandidateCoverLetterInput}),
  upsert: t.field({"required":false,"type":AttachmentUpsertWithoutCandidateCoverLetterInput}),
  disconnect: t.field({"required":false,"type":AttachmentWhereInput}),
  delete: t.field({"required":false,"type":AttachmentWhereInput}),
  connect: t.field({"required":false,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":false,"type":AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInput}),
});
export const AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput>>('AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput').implement({
  fields: AttachmentUpdateOneWithoutCandidateCoverLetterNestedInputFields,
});

export const OfferUpdateOneWithoutHiredNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutHiredInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutHiredInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutHiredInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutHiredInput}),
});
export const OfferUpdateOneWithoutHiredNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutHiredNestedInput>>('OfferUpdateOneWithoutHiredNestedInput').implement({
  fields: OfferUpdateOneWithoutHiredNestedInputFields,
});

export const HiringRoleUpdateOneWithoutHiredCandidatesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutHiredCandidatesInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutHiredCandidatesInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutHiredCandidatesInput}),
  disconnect: t.field({"required":false,"type":HiringRoleWhereInput}),
  delete: t.field({"required":false,"type":HiringRoleWhereInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInput}),
});
export const HiringRoleUpdateOneWithoutHiredCandidatesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneWithoutHiredCandidatesNestedInput>>('HiringRoleUpdateOneWithoutHiredCandidatesNestedInput').implement({
  fields: HiringRoleUpdateOneWithoutHiredCandidatesNestedInputFields,
});

export const AuditLogUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[AuditLogCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[AuditLogCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[AuditLogUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":AuditLogCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[AuditLogWhereUniqueInput]}),
  update: t.field({"required":false,"type":[AuditLogUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[AuditLogUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
});
export const AuditLogUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithoutCandidateNestedInput>>('AuditLogUpdateManyWithoutCandidateNestedInput').implement({
  fields: AuditLogUpdateManyWithoutCandidateNestedInputFields,
});

export const MatchUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[MatchCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[MatchCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[MatchUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":MatchCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[MatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[MatchUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[MatchUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[MatchScalarWhereInput]}),
});
export const MatchUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithoutCandidateNestedInput>>('MatchUpdateManyWithoutCandidateNestedInput').implement({
  fields: MatchUpdateManyWithoutCandidateNestedInputFields,
});

export const TalentPoolMatchUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TalentPoolMatchCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[TalentPoolMatchCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":TalentPoolMatchCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TalentPoolMatchWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[TalentPoolMatchUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[TalentPoolMatchScalarWhereInput]}),
});
export const TalentPoolMatchUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateManyWithoutCandidateNestedInput>>('TalentPoolMatchUpdateManyWithoutCandidateNestedInput').implement({
  fields: TalentPoolMatchUpdateManyWithoutCandidateNestedInputFields,
});

export const CandidateTagUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateTagCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateTagCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[CandidateTagUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":CandidateTagCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateTagWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateTagUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[CandidateTagUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateTagScalarWhereInput]}),
});
export const CandidateTagUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateManyWithoutCandidateNestedInput>>('CandidateTagUpdateManyWithoutCandidateNestedInput').implement({
  fields: CandidateTagUpdateManyWithoutCandidateNestedInputFields,
});

export const CandidateCustomFieldUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCustomFieldCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCustomFieldCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":CandidateCustomFieldCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereInput]}),
});
export const CandidateCustomFieldUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateManyWithoutCandidateNestedInput>>('CandidateCustomFieldUpdateManyWithoutCandidateNestedInput').implement({
  fields: CandidateCustomFieldUpdateManyWithoutCandidateNestedInputFields,
});

export const EvaluationUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[EvaluationUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":EvaluationCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
});
export const EvaluationUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithoutCandidateNestedInput>>('EvaluationUpdateManyWithoutCandidateNestedInput').implement({
  fields: EvaluationUpdateManyWithoutCandidateNestedInputFields,
});

export const TaskUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[TaskUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":TaskCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TaskWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TaskUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[TaskUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[TaskScalarWhereInput]}),
});
export const TaskUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateManyWithoutCandidateNestedInput>>('TaskUpdateManyWithoutCandidateNestedInput').implement({
  fields: TaskUpdateManyWithoutCandidateNestedInputFields,
});

export const FollowUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[FollowCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[FollowCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[FollowUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":FollowCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[FollowWhereUniqueInput]}),
  update: t.field({"required":false,"type":[FollowUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[FollowUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[FollowScalarWhereInput]}),
});
export const FollowUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithoutCandidateNestedInput>>('FollowUpdateManyWithoutCandidateNestedInput').implement({
  fields: FollowUpdateManyWithoutCandidateNestedInputFields,
});

export const SharedCandidateLinkUpdateManyWithoutCandidateNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[SharedCandidateLinkCreateWithoutCandidateInput]}),
  connectOrCreate: t.field({"required":false,"type":[SharedCandidateLinkCreateOrConnectWithoutCandidateInput]}),
  upsert: t.field({"required":false,"type":[SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInput]}),
  createMany: t.field({"required":false,"type":SharedCandidateLinkCreateManyCandidateInputEnvelope}),
  set: t.field({"required":false,"type":[SharedCandidateLinkWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[SharedCandidateLinkWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[SharedCandidateLinkWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[SharedCandidateLinkWhereUniqueInput]}),
  update: t.field({"required":false,"type":[SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInput]}),
  updateMany: t.field({"required":false,"type":[SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInput]}),
  deleteMany: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereInput]}),
});
export const SharedCandidateLinkUpdateManyWithoutCandidateNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateManyWithoutCandidateNestedInput>>('SharedCandidateLinkUpdateManyWithoutCandidateNestedInput').implement({
  fields: SharedCandidateLinkUpdateManyWithoutCandidateNestedInputFields,
});

export const CompanyUpdateOneRequiredWithoutCandidatesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutCandidatesInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutCandidatesInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutCandidatesInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutCandidatesInput}),
});
export const CompanyUpdateOneRequiredWithoutCandidatesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutCandidatesNestedInput>>('CompanyUpdateOneRequiredWithoutCandidatesNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutCandidatesNestedInputFields,
});

export const EventUpdateManyWithoutCandidatesNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventCreateWithoutCandidatesInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventCreateOrConnectWithoutCandidatesInput]}),
  upsert: t.field({"required":false,"type":[EventUpsertWithWhereUniqueWithoutCandidatesInput]}),
  set: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventUpdateWithWhereUniqueWithoutCandidatesInput]}),
  updateMany: t.field({"required":false,"type":[EventUpdateManyWithWhereWithoutCandidatesInput]}),
  deleteMany: t.field({"required":false,"type":[EventScalarWhereInput]}),
});
export const EventUpdateManyWithoutCandidatesNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithoutCandidatesNestedInput>>('EventUpdateManyWithoutCandidatesNestedInput').implement({
  fields: EventUpdateManyWithoutCandidatesNestedInputFields,
});

export const CandidateCreateNestedOneWithoutCandidateTagsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCandidateTagsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCandidateTagsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutCandidateTagsInput>>('CandidateCreateNestedOneWithoutCandidateTagsInput').implement({
  fields: CandidateCreateNestedOneWithoutCandidateTagsInputFields,
});

export const TagSourceCreateNestedOneWithoutCandidateTagsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutCandidateTagsInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutCandidateTagsInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
});
export const TagSourceCreateNestedOneWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateNestedOneWithoutCandidateTagsInput>>('TagSourceCreateNestedOneWithoutCandidateTagsInput').implement({
  fields: TagSourceCreateNestedOneWithoutCandidateTagsInputFields,
});

export const CandidateUpdateOneRequiredWithoutCandidateTagsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCandidateTagsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCandidateTagsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutCandidateTagsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutCandidateTagsInput}),
});
export const CandidateUpdateOneRequiredWithoutCandidateTagsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutCandidateTagsNestedInput>>('CandidateUpdateOneRequiredWithoutCandidateTagsNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutCandidateTagsNestedInputFields,
});

export const TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TagSourceCreateWithoutCandidateTagsInput}),
  connectOrCreate: t.field({"required":false,"type":TagSourceCreateOrConnectWithoutCandidateTagsInput}),
  upsert: t.field({"required":false,"type":TagSourceUpsertWithoutCandidateTagsInput}),
  connect: t.field({"required":false,"type":TagSourceWhereUniqueInput}),
  update: t.field({"required":false,"type":TagSourceUpdateToOneWithWhereWithoutCandidateTagsInput}),
});
export const TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInput>>('TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInput').implement({
  fields: TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInputFields,
});

export const CandidateCreateNestedOneWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCandidateCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCandidateCustomFieldsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutCandidateCustomFieldsInput>>('CandidateCreateNestedOneWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateCreateNestedOneWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CustomFieldCreateWithoutCandidateCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInput}),
  connect: t.field({"required":false,"type":CustomFieldWhereUniqueInput}),
});
export const CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInput>>('CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInputFields,
});

export const CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutCandidateCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutCandidateCustomFieldsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutCandidateCustomFieldsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInput}),
});
export const CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput>>('CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInputFields,
});

export const CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CustomFieldCreateWithoutCandidateCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInput}),
  upsert: t.field({"required":false,"type":CustomFieldUpsertWithoutCandidateCustomFieldsInput}),
  connect: t.field({"required":false,"type":CustomFieldWhereUniqueInput}),
  update: t.field({"required":false,"type":CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInput}),
});
export const CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput>>('CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput').implement({
  fields: CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInputFields,
});

export const CompanyCreateNestedOneWithoutCustomFieldsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutCustomFieldsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutCustomFieldsInput>>('CompanyCreateNestedOneWithoutCustomFieldsInput').implement({
  fields: CompanyCreateNestedOneWithoutCustomFieldsInputFields,
});

export const CandidateCustomFieldCreateNestedManyWithoutCustomFieldInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCustomFieldCreateWithoutCustomFieldInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCustomFieldCreateOrConnectWithoutCustomFieldInput]}),
  createMany: t.field({"required":false,"type":CandidateCustomFieldCreateManyCustomFieldInputEnvelope}),
  connect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
});
export const CandidateCustomFieldCreateNestedManyWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateNestedManyWithoutCustomFieldInput>>('CandidateCustomFieldCreateNestedManyWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldCreateNestedManyWithoutCustomFieldInputFields,
});

export const CompanyUpdateOneRequiredWithoutCustomFieldsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutCustomFieldsInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutCustomFieldsInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutCustomFieldsInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutCustomFieldsInput}),
});
export const CompanyUpdateOneRequiredWithoutCustomFieldsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutCustomFieldsNestedInput>>('CompanyUpdateOneRequiredWithoutCustomFieldsNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutCustomFieldsNestedInputFields,
});

export const CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[CandidateCustomFieldCreateWithoutCustomFieldInput]}),
  connectOrCreate: t.field({"required":false,"type":[CandidateCustomFieldCreateOrConnectWithoutCustomFieldInput]}),
  upsert: t.field({"required":false,"type":[CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInput]}),
  createMany: t.field({"required":false,"type":CandidateCustomFieldCreateManyCustomFieldInputEnvelope}),
  set: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[CandidateCustomFieldWhereUniqueInput]}),
  update: t.field({"required":false,"type":[CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInput]}),
  updateMany: t.field({"required":false,"type":[CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInput]}),
  deleteMany: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereInput]}),
});
export const CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInput>>('CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInput').implement({
  fields: CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInputFields,
});

export const TemplateCreateNestedOneWithoutEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
});
export const TemplateCreateNestedOneWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateNestedOneWithoutEvaluationsInput>>('TemplateCreateNestedOneWithoutEvaluationsInput').implement({
  fields: TemplateCreateNestedOneWithoutEvaluationsInputFields,
});

export const OfferCreateNestedOneWithoutEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutEvaluationsInput>>('OfferCreateNestedOneWithoutEvaluationsInput').implement({
  fields: OfferCreateNestedOneWithoutEvaluationsInputFields,
});

export const CandidateCreateNestedOneWithoutEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutEvaluationsInput>>('CandidateCreateNestedOneWithoutEvaluationsInput').implement({
  fields: CandidateCreateNestedOneWithoutEvaluationsInputFields,
});

export const HiringRoleCreateNestedOneWithoutEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutEvaluationsInput>>('HiringRoleCreateNestedOneWithoutEvaluationsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutEvaluationsInputFields,
});

export const EventScheduleEvaluationCreateNestedManyWithoutEvaluationInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleEvaluationCreateWithoutEvaluationInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleEvaluationCreateOrConnectWithoutEvaluationInput]}),
  createMany: t.field({"required":false,"type":EventScheduleEvaluationCreateManyEvaluationInputEnvelope}),
  connect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
});
export const EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput>>('EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationCreateNestedManyWithoutEvaluationInputFields,
});

export const EventCreateNestedOneWithoutEvaluationsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EventCreateOrConnectWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":EventWhereUniqueInput}),
});
export const EventCreateNestedOneWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateNestedOneWithoutEvaluationsInput>>('EventCreateNestedOneWithoutEvaluationsInput').implement({
  fields: EventCreateNestedOneWithoutEvaluationsInputFields,
});

export const EvaluationQuestionCreateNestedManyWithoutEvaluationInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationQuestionCreateWithoutEvaluationInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationQuestionCreateOrConnectWithoutEvaluationInput]}),
  createMany: t.field({"required":false,"type":EvaluationQuestionCreateManyEvaluationInputEnvelope}),
  connect: t.field({"required":false,"type":[EvaluationQuestionWhereUniqueInput]}),
});
export const EvaluationQuestionCreateNestedManyWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateNestedManyWithoutEvaluationInput>>('EvaluationQuestionCreateNestedManyWithoutEvaluationInput').implement({
  fields: EvaluationQuestionCreateNestedManyWithoutEvaluationInputFields,
});

export const EnumSCORE_TYPESFieldUpdateOperationsInputFields = (t: any) => ({
  set: t.field({"required":false,"type":SCORE_TYPES}),
});
export const EnumSCORE_TYPESFieldUpdateOperationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EnumSCORE_TYPESFieldUpdateOperationsInput>>('EnumSCORE_TYPESFieldUpdateOperationsInput').implement({
  fields: EnumSCORE_TYPESFieldUpdateOperationsInputFields,
});

export const TemplateUpdateOneWithoutEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TemplateCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":TemplateCreateOrConnectWithoutEvaluationsInput}),
  upsert: t.field({"required":false,"type":TemplateUpsertWithoutEvaluationsInput}),
  disconnect: t.field({"required":false,"type":TemplateWhereInput}),
  delete: t.field({"required":false,"type":TemplateWhereInput}),
  connect: t.field({"required":false,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":false,"type":TemplateUpdateToOneWithWhereWithoutEvaluationsInput}),
});
export const TemplateUpdateOneWithoutEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateOneWithoutEvaluationsNestedInput>>('TemplateUpdateOneWithoutEvaluationsNestedInput').implement({
  fields: TemplateUpdateOneWithoutEvaluationsNestedInputFields,
});

export const OfferUpdateOneWithoutEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutEvaluationsInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutEvaluationsInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutEvaluationsInput}),
});
export const OfferUpdateOneWithoutEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutEvaluationsNestedInput>>('OfferUpdateOneWithoutEvaluationsNestedInput').implement({
  fields: OfferUpdateOneWithoutEvaluationsNestedInputFields,
});

export const CandidateUpdateOneRequiredWithoutEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutEvaluationsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutEvaluationsInput}),
});
export const CandidateUpdateOneRequiredWithoutEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutEvaluationsNestedInput>>('CandidateUpdateOneRequiredWithoutEvaluationsNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutEvaluationsNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutEvaluationsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutEvaluationsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutEvaluationsInput}),
});
export const HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput>>('HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInputFields,
});

export const EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EventScheduleEvaluationCreateWithoutEvaluationInput]}),
  connectOrCreate: t.field({"required":false,"type":[EventScheduleEvaluationCreateOrConnectWithoutEvaluationInput]}),
  upsert: t.field({"required":false,"type":[EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInput]}),
  createMany: t.field({"required":false,"type":EventScheduleEvaluationCreateManyEvaluationInputEnvelope}),
  set: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EventScheduleEvaluationWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInput]}),
  updateMany: t.field({"required":false,"type":[EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInput]}),
  deleteMany: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereInput]}),
});
export const EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput>>('EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput').implement({
  fields: EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInputFields,
});

export const EventUpdateOneWithoutEvaluationsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EventCreateWithoutEvaluationsInput}),
  connectOrCreate: t.field({"required":false,"type":EventCreateOrConnectWithoutEvaluationsInput}),
  upsert: t.field({"required":false,"type":EventUpsertWithoutEvaluationsInput}),
  disconnect: t.field({"required":false,"type":EventWhereInput}),
  delete: t.field({"required":false,"type":EventWhereInput}),
  connect: t.field({"required":false,"type":EventWhereUniqueInput}),
  update: t.field({"required":false,"type":EventUpdateToOneWithWhereWithoutEvaluationsInput}),
});
export const EventUpdateOneWithoutEvaluationsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateOneWithoutEvaluationsNestedInput>>('EventUpdateOneWithoutEvaluationsNestedInput').implement({
  fields: EventUpdateOneWithoutEvaluationsNestedInputFields,
});

export const EvaluationQuestionUpdateManyWithoutEvaluationNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[EvaluationQuestionCreateWithoutEvaluationInput]}),
  connectOrCreate: t.field({"required":false,"type":[EvaluationQuestionCreateOrConnectWithoutEvaluationInput]}),
  upsert: t.field({"required":false,"type":[EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInput]}),
  createMany: t.field({"required":false,"type":EvaluationQuestionCreateManyEvaluationInputEnvelope}),
  set: t.field({"required":false,"type":[EvaluationQuestionWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[EvaluationQuestionWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[EvaluationQuestionWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[EvaluationQuestionWhereUniqueInput]}),
  update: t.field({"required":false,"type":[EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInput]}),
  updateMany: t.field({"required":false,"type":[EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInput]}),
  deleteMany: t.field({"required":false,"type":[EvaluationQuestionScalarWhereInput]}),
});
export const EvaluationQuestionUpdateManyWithoutEvaluationNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateManyWithoutEvaluationNestedInput>>('EvaluationQuestionUpdateManyWithoutEvaluationNestedInput').implement({
  fields: EvaluationQuestionUpdateManyWithoutEvaluationNestedInputFields,
});

export const EvaluationCreateNestedOneWithoutAnswersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EvaluationCreateWithoutAnswersInput}),
  connectOrCreate: t.field({"required":false,"type":EvaluationCreateOrConnectWithoutAnswersInput}),
  connect: t.field({"required":false,"type":EvaluationWhereUniqueInput}),
});
export const EvaluationCreateNestedOneWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateNestedOneWithoutAnswersInput>>('EvaluationCreateNestedOneWithoutAnswersInput').implement({
  fields: EvaluationCreateNestedOneWithoutAnswersInputFields,
});

export const EvaluationUpdateOneRequiredWithoutAnswersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":EvaluationCreateWithoutAnswersInput}),
  connectOrCreate: t.field({"required":false,"type":EvaluationCreateOrConnectWithoutAnswersInput}),
  upsert: t.field({"required":false,"type":EvaluationUpsertWithoutAnswersInput}),
  connect: t.field({"required":false,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":false,"type":EvaluationUpdateToOneWithWhereWithoutAnswersInput}),
});
export const EvaluationUpdateOneRequiredWithoutAnswersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateOneRequiredWithoutAnswersNestedInput>>('EvaluationUpdateOneRequiredWithoutAnswersNestedInput').implement({
  fields: EvaluationUpdateOneRequiredWithoutAnswersNestedInputFields,
});

export const SharedCandidateLinkCreatevisibleSectionsInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const SharedCandidateLinkCreatevisibleSectionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreatevisibleSectionsInput>>('SharedCandidateLinkCreatevisibleSectionsInput').implement({
  fields: SharedCandidateLinkCreatevisibleSectionsInputFields,
});

export const SharedCandidateLinkCreateeditModelSectionsInputFields = (t: any) => ({
  set: t.stringList({"required":true}),
});
export const SharedCandidateLinkCreateeditModelSectionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateeditModelSectionsInput>>('SharedCandidateLinkCreateeditModelSectionsInput').implement({
  fields: SharedCandidateLinkCreateeditModelSectionsInputFields,
});

export const CandidateCreateNestedOneWithoutSharedCandidateLinkInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutSharedCandidateLinkInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutSharedCandidateLinkInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutSharedCandidateLinkInput>>('CandidateCreateNestedOneWithoutSharedCandidateLinkInput').implement({
  fields: CandidateCreateNestedOneWithoutSharedCandidateLinkInputFields,
});

export const SharedCandidateLinkUpdatevisibleSectionsInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const SharedCandidateLinkUpdatevisibleSectionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdatevisibleSectionsInput>>('SharedCandidateLinkUpdatevisibleSectionsInput').implement({
  fields: SharedCandidateLinkUpdatevisibleSectionsInputFields,
});

export const SharedCandidateLinkUpdateeditModelSectionsInputFields = (t: any) => ({
  set: t.stringList({"required":false}),
  push: t.stringList({"required":false}),
});
export const SharedCandidateLinkUpdateeditModelSectionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateeditModelSectionsInput>>('SharedCandidateLinkUpdateeditModelSectionsInput').implement({
  fields: SharedCandidateLinkUpdateeditModelSectionsInputFields,
});

export const CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutSharedCandidateLinkInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutSharedCandidateLinkInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutSharedCandidateLinkInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInput}),
});
export const CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInput>>('CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInput').implement({
  fields: CandidateUpdateOneRequiredWithoutSharedCandidateLinkNestedInputFields,
});

export const CompanyCreateNestedOneWithoutTasksInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTasksInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
});
export const CompanyCreateNestedOneWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateNestedOneWithoutTasksInput>>('CompanyCreateNestedOneWithoutTasksInput').implement({
  fields: CompanyCreateNestedOneWithoutTasksInputFields,
});

export const TaskMemberCreateNestedManyWithoutTaskInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskMemberCreateWithoutTaskInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskMemberCreateOrConnectWithoutTaskInput]}),
  createMany: t.field({"required":false,"type":TaskMemberCreateManyTaskInputEnvelope}),
  connect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
});
export const TaskMemberCreateNestedManyWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateNestedManyWithoutTaskInput>>('TaskMemberCreateNestedManyWithoutTaskInput').implement({
  fields: TaskMemberCreateNestedManyWithoutTaskInputFields,
});

export const CandidateCreateNestedOneWithoutTasksInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutTasksInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutTasksInput>>('CandidateCreateNestedOneWithoutTasksInput').implement({
  fields: CandidateCreateNestedOneWithoutTasksInputFields,
});

export const CompanyUpdateOneRequiredWithoutTasksNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CompanyCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":CompanyCreateOrConnectWithoutTasksInput}),
  upsert: t.field({"required":false,"type":CompanyUpsertWithoutTasksInput}),
  connect: t.field({"required":false,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":false,"type":CompanyUpdateToOneWithWhereWithoutTasksInput}),
});
export const CompanyUpdateOneRequiredWithoutTasksNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateOneRequiredWithoutTasksNestedInput>>('CompanyUpdateOneRequiredWithoutTasksNestedInput').implement({
  fields: CompanyUpdateOneRequiredWithoutTasksNestedInputFields,
});

export const TaskMemberUpdateManyWithoutTaskNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":[TaskMemberCreateWithoutTaskInput]}),
  connectOrCreate: t.field({"required":false,"type":[TaskMemberCreateOrConnectWithoutTaskInput]}),
  upsert: t.field({"required":false,"type":[TaskMemberUpsertWithWhereUniqueWithoutTaskInput]}),
  createMany: t.field({"required":false,"type":TaskMemberCreateManyTaskInputEnvelope}),
  set: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  disconnect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  delete: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  connect: t.field({"required":false,"type":[TaskMemberWhereUniqueInput]}),
  update: t.field({"required":false,"type":[TaskMemberUpdateWithWhereUniqueWithoutTaskInput]}),
  updateMany: t.field({"required":false,"type":[TaskMemberUpdateManyWithWhereWithoutTaskInput]}),
  deleteMany: t.field({"required":false,"type":[TaskMemberScalarWhereInput]}),
});
export const TaskMemberUpdateManyWithoutTaskNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateManyWithoutTaskNestedInput>>('TaskMemberUpdateManyWithoutTaskNestedInput').implement({
  fields: TaskMemberUpdateManyWithoutTaskNestedInputFields,
});

export const CandidateUpdateOneWithoutTasksNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutTasksInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutTasksInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutTasksInput}),
});
export const CandidateUpdateOneWithoutTasksNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutTasksNestedInput>>('CandidateUpdateOneWithoutTasksNestedInput').implement({
  fields: CandidateUpdateOneWithoutTasksNestedInputFields,
});

export const TaskCreateNestedOneWithoutTaskMembersInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TaskCreateWithoutTaskMembersInput}),
  connectOrCreate: t.field({"required":false,"type":TaskCreateOrConnectWithoutTaskMembersInput}),
  connect: t.field({"required":false,"type":TaskWhereUniqueInput}),
});
export const TaskCreateNestedOneWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateNestedOneWithoutTaskMembersInput>>('TaskCreateNestedOneWithoutTaskMembersInput').implement({
  fields: TaskCreateNestedOneWithoutTaskMembersInputFields,
});

export const HiringRoleCreateNestedOneWithoutTasksInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutTasksInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutTasksInput>>('HiringRoleCreateNestedOneWithoutTasksInput').implement({
  fields: HiringRoleCreateNestedOneWithoutTasksInputFields,
});

export const TaskUpdateOneRequiredWithoutTaskMembersNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TaskCreateWithoutTaskMembersInput}),
  connectOrCreate: t.field({"required":false,"type":TaskCreateOrConnectWithoutTaskMembersInput}),
  upsert: t.field({"required":false,"type":TaskUpsertWithoutTaskMembersInput}),
  connect: t.field({"required":false,"type":TaskWhereUniqueInput}),
  update: t.field({"required":false,"type":TaskUpdateToOneWithWhereWithoutTaskMembersInput}),
});
export const TaskUpdateOneRequiredWithoutTaskMembersNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateOneRequiredWithoutTaskMembersNestedInput>>('TaskUpdateOneRequiredWithoutTaskMembersNestedInput').implement({
  fields: TaskUpdateOneRequiredWithoutTaskMembersNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutTasksNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutTasksInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutTasksInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutTasksInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutTasksInput}),
});
export const HiringRoleUpdateOneRequiredWithoutTasksNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutTasksNestedInput>>('HiringRoleUpdateOneRequiredWithoutTasksNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutTasksNestedInputFields,
});

export const OfferCreateNestedOneWithoutFollowsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutFollowsInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
});
export const OfferCreateNestedOneWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateNestedOneWithoutFollowsInput>>('OfferCreateNestedOneWithoutFollowsInput').implement({
  fields: OfferCreateNestedOneWithoutFollowsInputFields,
});

export const CandidateCreateNestedOneWithoutFollowsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutFollowsInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
});
export const CandidateCreateNestedOneWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateNestedOneWithoutFollowsInput>>('CandidateCreateNestedOneWithoutFollowsInput').implement({
  fields: CandidateCreateNestedOneWithoutFollowsInputFields,
});

export const TalentPoolCreateNestedOneWithoutFollowsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutFollowsInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
});
export const TalentPoolCreateNestedOneWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateNestedOneWithoutFollowsInput>>('TalentPoolCreateNestedOneWithoutFollowsInput').implement({
  fields: TalentPoolCreateNestedOneWithoutFollowsInputFields,
});

export const HiringRoleCreateNestedOneWithoutFollowsInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutFollowsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
});
export const HiringRoleCreateNestedOneWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateNestedOneWithoutFollowsInput>>('HiringRoleCreateNestedOneWithoutFollowsInput').implement({
  fields: HiringRoleCreateNestedOneWithoutFollowsInputFields,
});

export const OfferUpdateOneWithoutFollowsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":OfferCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":OfferCreateOrConnectWithoutFollowsInput}),
  upsert: t.field({"required":false,"type":OfferUpsertWithoutFollowsInput}),
  disconnect: t.field({"required":false,"type":OfferWhereInput}),
  delete: t.field({"required":false,"type":OfferWhereInput}),
  connect: t.field({"required":false,"type":OfferWhereUniqueInput}),
  update: t.field({"required":false,"type":OfferUpdateToOneWithWhereWithoutFollowsInput}),
});
export const OfferUpdateOneWithoutFollowsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateOneWithoutFollowsNestedInput>>('OfferUpdateOneWithoutFollowsNestedInput').implement({
  fields: OfferUpdateOneWithoutFollowsNestedInputFields,
});

export const CandidateUpdateOneWithoutFollowsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":CandidateCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":CandidateCreateOrConnectWithoutFollowsInput}),
  upsert: t.field({"required":false,"type":CandidateUpsertWithoutFollowsInput}),
  disconnect: t.field({"required":false,"type":CandidateWhereInput}),
  delete: t.field({"required":false,"type":CandidateWhereInput}),
  connect: t.field({"required":false,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":false,"type":CandidateUpdateToOneWithWhereWithoutFollowsInput}),
});
export const CandidateUpdateOneWithoutFollowsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateOneWithoutFollowsNestedInput>>('CandidateUpdateOneWithoutFollowsNestedInput').implement({
  fields: CandidateUpdateOneWithoutFollowsNestedInputFields,
});

export const TalentPoolUpdateOneWithoutFollowsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":TalentPoolCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":TalentPoolCreateOrConnectWithoutFollowsInput}),
  upsert: t.field({"required":false,"type":TalentPoolUpsertWithoutFollowsInput}),
  disconnect: t.field({"required":false,"type":TalentPoolWhereInput}),
  delete: t.field({"required":false,"type":TalentPoolWhereInput}),
  connect: t.field({"required":false,"type":TalentPoolWhereUniqueInput}),
  update: t.field({"required":false,"type":TalentPoolUpdateToOneWithWhereWithoutFollowsInput}),
});
export const TalentPoolUpdateOneWithoutFollowsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateOneWithoutFollowsNestedInput>>('TalentPoolUpdateOneWithoutFollowsNestedInput').implement({
  fields: TalentPoolUpdateOneWithoutFollowsNestedInputFields,
});

export const HiringRoleUpdateOneRequiredWithoutFollowsNestedInputFields = (t: any) => ({
  create: t.field({"required":false,"type":HiringRoleCreateWithoutFollowsInput}),
  connectOrCreate: t.field({"required":false,"type":HiringRoleCreateOrConnectWithoutFollowsInput}),
  upsert: t.field({"required":false,"type":HiringRoleUpsertWithoutFollowsInput}),
  connect: t.field({"required":false,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":false,"type":HiringRoleUpdateToOneWithWhereWithoutFollowsInput}),
});
export const HiringRoleUpdateOneRequiredWithoutFollowsNestedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateOneRequiredWithoutFollowsNestedInput>>('HiringRoleUpdateOneRequiredWithoutFollowsNestedInput').implement({
  fields: HiringRoleUpdateOneRequiredWithoutFollowsNestedInputFields,
});

export const NestedStringFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  not: t.field({"required":false,"type":NestedStringFilter}),
});
export const NestedStringFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedStringFilter>>('NestedStringFilter').implement({
  fields: NestedStringFilterFields,
});

export const NestedStringNullableFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  not: t.field({"required":false,"type":NestedStringNullableFilter}),
});
export const NestedStringNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedStringNullableFilter>>('NestedStringNullableFilter').implement({
  fields: NestedStringNullableFilterFields,
});

export const NestedDateTimeNullableFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
});
export const NestedDateTimeNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedDateTimeNullableFilter>>('NestedDateTimeNullableFilter').implement({
  fields: NestedDateTimeNullableFilterFields,
});

export const NestedBoolFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolFilter}),
});
export const NestedBoolFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedBoolFilter>>('NestedBoolFilter').implement({
  fields: NestedBoolFilterFields,
});

export const NestedIntNullableFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntNullableFilter}),
});
export const NestedIntNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedIntNullableFilter>>('NestedIntNullableFilter').implement({
  fields: NestedIntNullableFilterFields,
});

export const NestedDateTimeFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeFilter}),
});
export const NestedDateTimeFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedDateTimeFilter>>('NestedDateTimeFilter').implement({
  fields: NestedDateTimeFilterFields,
});

export const NestedEnumUserRolesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":UserRoles}),
  in: t.field({"required":false,"type":[UserRoles]}),
  notIn: t.field({"required":false,"type":[UserRoles]}),
  not: t.field({"required":false,"type":UserRoles}),
});
export const NestedEnumUserRolesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumUserRolesFilter>>('NestedEnumUserRolesFilter').implement({
  fields: NestedEnumUserRolesFilterFields,
});

export const NestedStringWithAggregatesFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  not: t.field({"required":false,"type":NestedStringWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedStringFilter}),
  _max: t.field({"required":false,"type":NestedStringFilter}),
});
export const NestedStringWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedStringWithAggregatesFilter>>('NestedStringWithAggregatesFilter').implement({
  fields: NestedStringWithAggregatesFilterFields,
});

export const NestedIntFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntFilter}),
});
export const NestedIntFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedIntFilter>>('NestedIntFilter').implement({
  fields: NestedIntFilterFields,
});

export const NestedStringNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.string({"required":false}),
  in: t.stringList({"required":false}),
  notIn: t.stringList({"required":false}),
  lt: t.string({"required":false}),
  lte: t.string({"required":false}),
  gt: t.string({"required":false}),
  gte: t.string({"required":false}),
  contains: t.string({"required":false}),
  startsWith: t.string({"required":false}),
  endsWith: t.string({"required":false}),
  not: t.field({"required":false,"type":NestedStringNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedStringNullableFilter}),
  _max: t.field({"required":false,"type":NestedStringNullableFilter}),
});
export const NestedStringNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedStringNullableWithAggregatesFilter>>('NestedStringNullableWithAggregatesFilter').implement({
  fields: NestedStringNullableWithAggregatesFilterFields,
});

export const NestedDateTimeNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
  _max: t.field({"required":false,"type":NestedDateTimeNullableFilter}),
});
export const NestedDateTimeNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedDateTimeNullableWithAggregatesFilter>>('NestedDateTimeNullableWithAggregatesFilter').implement({
  fields: NestedDateTimeNullableWithAggregatesFilterFields,
});

export const NestedBoolWithAggregatesFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedBoolFilter}),
  _max: t.field({"required":false,"type":NestedBoolFilter}),
});
export const NestedBoolWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedBoolWithAggregatesFilter>>('NestedBoolWithAggregatesFilter').implement({
  fields: NestedBoolWithAggregatesFilterFields,
});

export const NestedIntNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _avg: t.field({"required":false,"type":NestedFloatNullableFilter}),
  _sum: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedIntNullableFilter}),
  _max: t.field({"required":false,"type":NestedIntNullableFilter}),
});
export const NestedIntNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedIntNullableWithAggregatesFilter>>('NestedIntNullableWithAggregatesFilter').implement({
  fields: NestedIntNullableWithAggregatesFilterFields,
});

export const NestedFloatNullableFilterFields = (t: any) => ({
  equals: t.float({"required":false}),
  in: t.floatList({"required":false}),
  notIn: t.floatList({"required":false}),
  lt: t.float({"required":false}),
  lte: t.float({"required":false}),
  gt: t.float({"required":false}),
  gte: t.float({"required":false}),
  not: t.field({"required":false,"type":NestedFloatNullableFilter}),
});
export const NestedFloatNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedFloatNullableFilter>>('NestedFloatNullableFilter').implement({
  fields: NestedFloatNullableFilterFields,
});

export const NestedJsonNullableFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
});
export const NestedJsonNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedJsonNullableFilter>>('NestedJsonNullableFilter').implement({
  fields: NestedJsonNullableFilterFields,
});

export const NestedDateTimeWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":DateTime}),
  in: t.field({"required":false,"type":[DateTime]}),
  notIn: t.field({"required":false,"type":[DateTime]}),
  lt: t.field({"required":false,"type":DateTime}),
  lte: t.field({"required":false,"type":DateTime}),
  gt: t.field({"required":false,"type":DateTime}),
  gte: t.field({"required":false,"type":DateTime}),
  not: t.field({"required":false,"type":NestedDateTimeWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedDateTimeFilter}),
  _max: t.field({"required":false,"type":NestedDateTimeFilter}),
});
export const NestedDateTimeWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedDateTimeWithAggregatesFilter>>('NestedDateTimeWithAggregatesFilter').implement({
  fields: NestedDateTimeWithAggregatesFilterFields,
});

export const NestedEnumUserRolesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":UserRoles}),
  in: t.field({"required":false,"type":[UserRoles]}),
  notIn: t.field({"required":false,"type":[UserRoles]}),
  not: t.field({"required":false,"type":UserRoles}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumUserRolesFilter}),
  _max: t.field({"required":false,"type":NestedEnumUserRolesFilter}),
});
export const NestedEnumUserRolesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumUserRolesWithAggregatesFilter>>('NestedEnumUserRolesWithAggregatesFilter').implement({
  fields: NestedEnumUserRolesWithAggregatesFilterFields,
});

export const NestedIntWithAggregatesFilterFields = (t: any) => ({
  equals: t.int({"required":false}),
  in: t.intList({"required":false}),
  notIn: t.intList({"required":false}),
  lt: t.int({"required":false}),
  lte: t.int({"required":false}),
  gt: t.int({"required":false}),
  gte: t.int({"required":false}),
  not: t.field({"required":false,"type":NestedIntWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _avg: t.field({"required":false,"type":NestedFloatFilter}),
  _sum: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedIntFilter}),
  _max: t.field({"required":false,"type":NestedIntFilter}),
});
export const NestedIntWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedIntWithAggregatesFilter>>('NestedIntWithAggregatesFilter').implement({
  fields: NestedIntWithAggregatesFilterFields,
});

export const NestedFloatFilterFields = (t: any) => ({
  equals: t.float({"required":false}),
  in: t.floatList({"required":false}),
  notIn: t.floatList({"required":false}),
  lt: t.float({"required":false}),
  lte: t.float({"required":false}),
  gt: t.float({"required":false}),
  gte: t.float({"required":false}),
  not: t.field({"required":false,"type":NestedFloatFilter}),
});
export const NestedFloatFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedFloatFilter>>('NestedFloatFilter').implement({
  fields: NestedFloatFilterFields,
});

export const NestedBoolNullableFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolNullableFilter}),
});
export const NestedBoolNullableFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedBoolNullableFilter>>('NestedBoolNullableFilter').implement({
  fields: NestedBoolNullableFilterFields,
});

export const NestedBoolNullableWithAggregatesFilterFields = (t: any) => ({
  equals: t.boolean({"required":false}),
  not: t.field({"required":false,"type":NestedBoolNullableWithAggregatesFilter}),
  _count: t.field({"required":false,"type":NestedIntNullableFilter}),
  _min: t.field({"required":false,"type":NestedBoolNullableFilter}),
  _max: t.field({"required":false,"type":NestedBoolNullableFilter}),
});
export const NestedBoolNullableWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedBoolNullableWithAggregatesFilter>>('NestedBoolNullableWithAggregatesFilter').implement({
  fields: NestedBoolNullableWithAggregatesFilterFields,
});

export const NestedJsonFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":Json}),
  path: t.stringList({"required":false}),
  string_contains: t.string({"required":false}),
  string_starts_with: t.string({"required":false}),
  string_ends_with: t.string({"required":false}),
  array_contains: t.field({"required":false,"type":Json}),
  array_starts_with: t.field({"required":false,"type":Json}),
  array_ends_with: t.field({"required":false,"type":Json}),
  lt: t.field({"required":false,"type":Json}),
  lte: t.field({"required":false,"type":Json}),
  gt: t.field({"required":false,"type":Json}),
  gte: t.field({"required":false,"type":Json}),
  not: t.field({"required":false,"type":Json}),
});
export const NestedJsonFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedJsonFilter>>('NestedJsonFilter').implement({
  fields: NestedJsonFilterFields,
});

export const NestedEnumTagSourceTypeFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TagSourceType}),
  in: t.field({"required":false,"type":[TagSourceType]}),
  notIn: t.field({"required":false,"type":[TagSourceType]}),
  not: t.field({"required":false,"type":TagSourceType}),
});
export const NestedEnumTagSourceTypeFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumTagSourceTypeFilter>>('NestedEnumTagSourceTypeFilter').implement({
  fields: NestedEnumTagSourceTypeFilterFields,
});

export const NestedEnumTagSourceTypeWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TagSourceType}),
  in: t.field({"required":false,"type":[TagSourceType]}),
  notIn: t.field({"required":false,"type":[TagSourceType]}),
  not: t.field({"required":false,"type":TagSourceType}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumTagSourceTypeFilter}),
  _max: t.field({"required":false,"type":NestedEnumTagSourceTypeFilter}),
});
export const NestedEnumTagSourceTypeWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumTagSourceTypeWithAggregatesFilter>>('NestedEnumTagSourceTypeWithAggregatesFilter').implement({
  fields: NestedEnumTagSourceTypeWithAggregatesFilterFields,
});

export const NestedEnumOfferPersonalItemsFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":OfferPersonalItems}),
  in: t.field({"required":false,"type":[OfferPersonalItems]}),
  notIn: t.field({"required":false,"type":[OfferPersonalItems]}),
  not: t.field({"required":false,"type":OfferPersonalItems}),
});
export const NestedEnumOfferPersonalItemsFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumOfferPersonalItemsFilter>>('NestedEnumOfferPersonalItemsFilter').implement({
  fields: NestedEnumOfferPersonalItemsFilterFields,
});

export const NestedEnumOfferPersonalItemsWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":OfferPersonalItems}),
  in: t.field({"required":false,"type":[OfferPersonalItems]}),
  notIn: t.field({"required":false,"type":[OfferPersonalItems]}),
  not: t.field({"required":false,"type":OfferPersonalItems}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumOfferPersonalItemsFilter}),
  _max: t.field({"required":false,"type":NestedEnumOfferPersonalItemsFilter}),
});
export const NestedEnumOfferPersonalItemsWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumOfferPersonalItemsWithAggregatesFilter>>('NestedEnumOfferPersonalItemsWithAggregatesFilter').implement({
  fields: NestedEnumOfferPersonalItemsWithAggregatesFilterFields,
});

export const NestedEnumMembershipTypesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":MembershipTypes}),
  in: t.field({"required":false,"type":[MembershipTypes]}),
  notIn: t.field({"required":false,"type":[MembershipTypes]}),
  not: t.field({"required":false,"type":MembershipTypes}),
});
export const NestedEnumMembershipTypesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumMembershipTypesFilter>>('NestedEnumMembershipTypesFilter').implement({
  fields: NestedEnumMembershipTypesFilterFields,
});

export const NestedEnumMembershipTypesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":MembershipTypes}),
  in: t.field({"required":false,"type":[MembershipTypes]}),
  notIn: t.field({"required":false,"type":[MembershipTypes]}),
  not: t.field({"required":false,"type":MembershipTypes}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumMembershipTypesFilter}),
  _max: t.field({"required":false,"type":NestedEnumMembershipTypesFilter}),
});
export const NestedEnumMembershipTypesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumMembershipTypesWithAggregatesFilter>>('NestedEnumMembershipTypesWithAggregatesFilter').implement({
  fields: NestedEnumMembershipTypesWithAggregatesFilterFields,
});

export const NestedEnumTemplateTypesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TemplateTypes}),
  in: t.field({"required":false,"type":[TemplateTypes]}),
  notIn: t.field({"required":false,"type":[TemplateTypes]}),
  not: t.field({"required":false,"type":TemplateTypes}),
});
export const NestedEnumTemplateTypesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumTemplateTypesFilter>>('NestedEnumTemplateTypesFilter').implement({
  fields: NestedEnumTemplateTypesFilterFields,
});

export const NestedEnumTemplateTypesWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":TemplateTypes}),
  in: t.field({"required":false,"type":[TemplateTypes]}),
  notIn: t.field({"required":false,"type":[TemplateTypes]}),
  not: t.field({"required":false,"type":TemplateTypes}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumTemplateTypesFilter}),
  _max: t.field({"required":false,"type":NestedEnumTemplateTypesFilter}),
});
export const NestedEnumTemplateTypesWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumTemplateTypesWithAggregatesFilter>>('NestedEnumTemplateTypesWithAggregatesFilter').implement({
  fields: NestedEnumTemplateTypesWithAggregatesFilterFields,
});

export const NestedEnumSCORE_TYPESFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":SCORE_TYPES}),
  in: t.field({"required":false,"type":[SCORE_TYPES]}),
  notIn: t.field({"required":false,"type":[SCORE_TYPES]}),
  not: t.field({"required":false,"type":SCORE_TYPES}),
});
export const NestedEnumSCORE_TYPESFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumSCORE_TYPESFilter>>('NestedEnumSCORE_TYPESFilter').implement({
  fields: NestedEnumSCORE_TYPESFilterFields,
});

export const NestedEnumSCORE_TYPESWithAggregatesFilterFields = (t: any) => ({
  equals: t.field({"required":false,"type":SCORE_TYPES}),
  in: t.field({"required":false,"type":[SCORE_TYPES]}),
  notIn: t.field({"required":false,"type":[SCORE_TYPES]}),
  not: t.field({"required":false,"type":SCORE_TYPES}),
  _count: t.field({"required":false,"type":NestedIntFilter}),
  _min: t.field({"required":false,"type":NestedEnumSCORE_TYPESFilter}),
  _max: t.field({"required":false,"type":NestedEnumSCORE_TYPESFilter}),
});
export const NestedEnumSCORE_TYPESWithAggregatesFilter = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.NestedEnumSCORE_TYPESWithAggregatesFilter>>('NestedEnumSCORE_TYPESWithAggregatesFilter').implement({
  fields: NestedEnumSCORE_TYPESWithAggregatesFilterFields,
});

export const AttachmentCreateWithoutUserProfilePhotoInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutUserProfilePhotoInput>>('AttachmentCreateWithoutUserProfilePhotoInput').implement({
  fields: AttachmentCreateWithoutUserProfilePhotoInputFields,
});

export const AttachmentCreateOrConnectWithoutUserProfilePhotoInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutUserProfilePhotoInput}),
});
export const AttachmentCreateOrConnectWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutUserProfilePhotoInput>>('AttachmentCreateOrConnectWithoutUserProfilePhotoInput').implement({
  fields: AttachmentCreateOrConnectWithoutUserProfilePhotoInputFields,
});

export const AccountCreateWithoutUserInputFields = (t: any) => ({
  id: t.string({"required":false}),
  type: t.string({"required":true}),
  provider: t.string({"required":true}),
  providerAccountId: t.string({"required":true}),
  refresh_token: t.string({"required":false}),
  access_token: t.string({"required":false}),
  expires_at: t.int({"required":false}),
  token_type: t.string({"required":false}),
  scope: t.string({"required":false}),
  id_token: t.string({"required":false}),
  session_state: t.string({"required":false}),
});
export const AccountCreateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateWithoutUserInput>>('AccountCreateWithoutUserInput').implement({
  fields: AccountCreateWithoutUserInputFields,
});

export const AccountCreateOrConnectWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AccountWhereUniqueInput}),
  create: t.field({"required":true,"type":AccountCreateWithoutUserInput}),
});
export const AccountCreateOrConnectWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateOrConnectWithoutUserInput>>('AccountCreateOrConnectWithoutUserInput').implement({
  fields: AccountCreateOrConnectWithoutUserInputFields,
});

export const AccountCreateManyUserInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AccountCreateManyUserInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AccountCreateManyUserInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateManyUserInputEnvelope>>('AccountCreateManyUserInputEnvelope').implement({
  fields: AccountCreateManyUserInputEnvelopeFields,
});

export const SessionCreateWithoutUserInputFields = (t: any) => ({
  id: t.string({"required":false}),
  sessionToken: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
});
export const SessionCreateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateWithoutUserInput>>('SessionCreateWithoutUserInput').implement({
  fields: SessionCreateWithoutUserInputFields,
});

export const SessionCreateOrConnectWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SessionWhereUniqueInput}),
  create: t.field({"required":true,"type":SessionCreateWithoutUserInput}),
});
export const SessionCreateOrConnectWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateOrConnectWithoutUserInput>>('SessionCreateOrConnectWithoutUserInput').implement({
  fields: SessionCreateOrConnectWithoutUserInputFields,
});

export const SessionCreateManyUserInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[SessionCreateManyUserInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const SessionCreateManyUserInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateManyUserInputEnvelope>>('SessionCreateManyUserInputEnvelope').implement({
  fields: SessionCreateManyUserInputEnvelopeFields,
});

export const HiringRoleCreateWithoutUserInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutUserInput>>('HiringRoleCreateWithoutUserInput').implement({
  fields: HiringRoleCreateWithoutUserInputFields,
});

export const HiringRoleCreateOrConnectWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutUserInput}),
});
export const HiringRoleCreateOrConnectWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutUserInput>>('HiringRoleCreateOrConnectWithoutUserInput').implement({
  fields: HiringRoleCreateOrConnectWithoutUserInputFields,
});

export const HiringRoleCreateManyUserInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[HiringRoleCreateManyUserInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const HiringRoleCreateManyUserInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyUserInputEnvelope>>('HiringRoleCreateManyUserInputEnvelope').implement({
  fields: HiringRoleCreateManyUserInputEnvelopeFields,
});

export const CompanyCreateWithoutOwnerInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutOwnerInput>>('CompanyCreateWithoutOwnerInput').implement({
  fields: CompanyCreateWithoutOwnerInputFields,
});

export const CompanyCreateOrConnectWithoutOwnerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutOwnerInput}),
});
export const CompanyCreateOrConnectWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutOwnerInput>>('CompanyCreateOrConnectWithoutOwnerInput').implement({
  fields: CompanyCreateOrConnectWithoutOwnerInputFields,
});

export const CompanyCreateManyOwnerInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CompanyCreateManyOwnerInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CompanyCreateManyOwnerInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateManyOwnerInputEnvelope>>('CompanyCreateManyOwnerInputEnvelope').implement({
  fields: CompanyCreateManyOwnerInputEnvelopeFields,
});

export const AttachmentUpsertWithoutUserProfilePhotoInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutUserProfilePhotoInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutUserProfilePhotoInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutUserProfilePhotoInput>>('AttachmentUpsertWithoutUserProfilePhotoInput').implement({
  fields: AttachmentUpsertWithoutUserProfilePhotoInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutUserProfilePhotoInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInput>>('AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutUserProfilePhotoInputFields,
});

export const AttachmentUpdateWithoutUserProfilePhotoInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutUserProfilePhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutUserProfilePhotoInput>>('AttachmentUpdateWithoutUserProfilePhotoInput').implement({
  fields: AttachmentUpdateWithoutUserProfilePhotoInputFields,
});

export const AccountUpsertWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AccountWhereUniqueInput}),
  update: t.field({"required":true,"type":AccountUpdateWithoutUserInput}),
  create: t.field({"required":true,"type":AccountCreateWithoutUserInput}),
});
export const AccountUpsertWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpsertWithWhereUniqueWithoutUserInput>>('AccountUpsertWithWhereUniqueWithoutUserInput').implement({
  fields: AccountUpsertWithWhereUniqueWithoutUserInputFields,
});

export const AccountUpdateWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AccountWhereUniqueInput}),
  data: t.field({"required":true,"type":AccountUpdateWithoutUserInput}),
});
export const AccountUpdateWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateWithWhereUniqueWithoutUserInput>>('AccountUpdateWithWhereUniqueWithoutUserInput').implement({
  fields: AccountUpdateWithWhereUniqueWithoutUserInputFields,
});

export const AccountUpdateManyWithWhereWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AccountScalarWhereInput}),
  data: t.field({"required":true,"type":AccountUpdateManyMutationInput}),
});
export const AccountUpdateManyWithWhereWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateManyWithWhereWithoutUserInput>>('AccountUpdateManyWithWhereWithoutUserInput').implement({
  fields: AccountUpdateManyWithWhereWithoutUserInputFields,
});

export const AccountScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AccountScalarWhereInput]}),
  OR: t.field({"required":false,"type":[AccountScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[AccountScalarWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  provider: t.field({"required":false,"type":StringFilter}),
  providerAccountId: t.field({"required":false,"type":StringFilter}),
  refresh_token: t.field({"required":false,"type":StringNullableFilter}),
  access_token: t.field({"required":false,"type":StringNullableFilter}),
  expires_at: t.field({"required":false,"type":IntNullableFilter}),
  token_type: t.field({"required":false,"type":StringNullableFilter}),
  scope: t.field({"required":false,"type":StringNullableFilter}),
  id_token: t.field({"required":false,"type":StringNullableFilter}),
  session_state: t.field({"required":false,"type":StringNullableFilter}),
});
export const AccountScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountScalarWhereInput>>('AccountScalarWhereInput').implement({
  fields: AccountScalarWhereInputFields,
});

export const SessionUpsertWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SessionWhereUniqueInput}),
  update: t.field({"required":true,"type":SessionUpdateWithoutUserInput}),
  create: t.field({"required":true,"type":SessionCreateWithoutUserInput}),
});
export const SessionUpsertWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpsertWithWhereUniqueWithoutUserInput>>('SessionUpsertWithWhereUniqueWithoutUserInput').implement({
  fields: SessionUpsertWithWhereUniqueWithoutUserInputFields,
});

export const SessionUpdateWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SessionWhereUniqueInput}),
  data: t.field({"required":true,"type":SessionUpdateWithoutUserInput}),
});
export const SessionUpdateWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateWithWhereUniqueWithoutUserInput>>('SessionUpdateWithWhereUniqueWithoutUserInput').implement({
  fields: SessionUpdateWithWhereUniqueWithoutUserInputFields,
});

export const SessionUpdateManyWithWhereWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SessionScalarWhereInput}),
  data: t.field({"required":true,"type":SessionUpdateManyMutationInput}),
});
export const SessionUpdateManyWithWhereWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateManyWithWhereWithoutUserInput>>('SessionUpdateManyWithWhereWithoutUserInput').implement({
  fields: SessionUpdateManyWithWhereWithoutUserInputFields,
});

export const SessionScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SessionScalarWhereInput]}),
  OR: t.field({"required":false,"type":[SessionScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[SessionScalarWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  sessionToken: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  expires: t.field({"required":false,"type":DateTimeFilter}),
});
export const SessionScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionScalarWhereInput>>('SessionScalarWhereInput').implement({
  fields: SessionScalarWhereInputFields,
});

export const HiringRoleUpsertWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutUserInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutUserInput}),
});
export const HiringRoleUpsertWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithWhereUniqueWithoutUserInput>>('HiringRoleUpsertWithWhereUniqueWithoutUserInput').implement({
  fields: HiringRoleUpsertWithWhereUniqueWithoutUserInputFields,
});

export const HiringRoleUpdateWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutUserInput}),
});
export const HiringRoleUpdateWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithWhereUniqueWithoutUserInput>>('HiringRoleUpdateWithWhereUniqueWithoutUserInput').implement({
  fields: HiringRoleUpdateWithWhereUniqueWithoutUserInputFields,
});

export const HiringRoleUpdateManyWithWhereWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleScalarWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateManyMutationInput}),
});
export const HiringRoleUpdateManyWithWhereWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithWhereWithoutUserInput>>('HiringRoleUpdateManyWithWhereWithoutUserInput').implement({
  fields: HiringRoleUpdateManyWithWhereWithoutUserInputFields,
});

export const HiringRoleScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
  OR: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[HiringRoleScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  userId: t.field({"required":false,"type":StringFilter}),
  roleId: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  extraAbilities: t.field({"required":false,"type":StringNullableListFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const HiringRoleScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleScalarWhereInput>>('HiringRoleScalarWhereInput').implement({
  fields: HiringRoleScalarWhereInputFields,
});

export const CompanyUpsertWithWhereUniqueWithoutOwnerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  update: t.field({"required":true,"type":CompanyUpdateWithoutOwnerInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutOwnerInput}),
});
export const CompanyUpsertWithWhereUniqueWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithWhereUniqueWithoutOwnerInput>>('CompanyUpsertWithWhereUniqueWithoutOwnerInput').implement({
  fields: CompanyUpsertWithWhereUniqueWithoutOwnerInputFields,
});

export const CompanyUpdateWithWhereUniqueWithoutOwnerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutOwnerInput}),
});
export const CompanyUpdateWithWhereUniqueWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithWhereUniqueWithoutOwnerInput>>('CompanyUpdateWithWhereUniqueWithoutOwnerInput').implement({
  fields: CompanyUpdateWithWhereUniqueWithoutOwnerInputFields,
});

export const CompanyUpdateManyWithWhereWithoutOwnerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyScalarWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateManyMutationInput}),
});
export const CompanyUpdateManyWithWhereWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateManyWithWhereWithoutOwnerInput>>('CompanyUpdateManyWithWhereWithoutOwnerInput').implement({
  fields: CompanyUpdateManyWithWhereWithoutOwnerInputFields,
});

export const CompanyScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyScalarWhereInput]}),
  id: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  address: t.field({"required":false,"type":StringNullableFilter}),
  city: t.field({"required":false,"type":StringNullableFilter}),
  state: t.field({"required":false,"type":StringNullableFilter}),
  country: t.field({"required":false,"type":StringNullableFilter}),
  companyInbox: t.field({"required":false,"type":StringNullableFilter}),
  subdomain: t.field({"required":false,"type":StringNullableFilter}),
  gdprEnable: t.field({"required":false,"type":BoolNullableFilter}),
  gdprRetention: t.field({"required":false,"type":IntNullableFilter}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":StringNullableFilter}),
  gdprEmailFooter: t.field({"required":false,"type":StringNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  ownerId: t.field({"required":false,"type":StringFilter}),
  logoId: t.field({"required":false,"type":IntNullableFilter}),
});
export const CompanyScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyScalarWhereInput>>('CompanyScalarWhereInput').implement({
  fields: CompanyScalarWhereInputFields,
});

export const UserCreateWithoutAccountsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  photo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutUserProfilePhotoInput}),
  sessions: t.field({"required":false,"type":SessionCreateNestedManyWithoutUserInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutUserInput}),
  companiesOwned: t.field({"required":false,"type":CompanyCreateNestedManyWithoutOwnerInput}),
});
export const UserCreateWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateWithoutAccountsInput>>('UserCreateWithoutAccountsInput').implement({
  fields: UserCreateWithoutAccountsInputFields,
});

export const UserCreateOrConnectWithoutAccountsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":UserWhereUniqueInput}),
  create: t.field({"required":true,"type":UserCreateWithoutAccountsInput}),
});
export const UserCreateOrConnectWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateOrConnectWithoutAccountsInput>>('UserCreateOrConnectWithoutAccountsInput').implement({
  fields: UserCreateOrConnectWithoutAccountsInputFields,
});

export const UserUpsertWithoutAccountsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":UserUpdateWithoutAccountsInput}),
  create: t.field({"required":true,"type":UserCreateWithoutAccountsInput}),
  where: t.field({"required":false,"type":UserWhereInput}),
});
export const UserUpsertWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpsertWithoutAccountsInput>>('UserUpsertWithoutAccountsInput').implement({
  fields: UserUpsertWithoutAccountsInputFields,
});

export const UserUpdateToOneWithWhereWithoutAccountsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":UserWhereInput}),
  data: t.field({"required":true,"type":UserUpdateWithoutAccountsInput}),
});
export const UserUpdateToOneWithWhereWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateToOneWithWhereWithoutAccountsInput>>('UserUpdateToOneWithWhereWithoutAccountsInput').implement({
  fields: UserUpdateToOneWithWhereWithoutAccountsInputFields,
});

export const UserUpdateWithoutAccountsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  photo: t.field({"required":false,"type":AttachmentUpdateOneWithoutUserProfilePhotoNestedInput}),
  sessions: t.field({"required":false,"type":SessionUpdateManyWithoutUserNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutUserNestedInput}),
  companiesOwned: t.field({"required":false,"type":CompanyUpdateManyWithoutOwnerNestedInput}),
});
export const UserUpdateWithoutAccountsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateWithoutAccountsInput>>('UserUpdateWithoutAccountsInput').implement({
  fields: UserUpdateWithoutAccountsInputFields,
});

export const UserCreateWithoutSessionsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  photo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutUserProfilePhotoInput}),
  accounts: t.field({"required":false,"type":AccountCreateNestedManyWithoutUserInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutUserInput}),
  companiesOwned: t.field({"required":false,"type":CompanyCreateNestedManyWithoutOwnerInput}),
});
export const UserCreateWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateWithoutSessionsInput>>('UserCreateWithoutSessionsInput').implement({
  fields: UserCreateWithoutSessionsInputFields,
});

export const UserCreateOrConnectWithoutSessionsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":UserWhereUniqueInput}),
  create: t.field({"required":true,"type":UserCreateWithoutSessionsInput}),
});
export const UserCreateOrConnectWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateOrConnectWithoutSessionsInput>>('UserCreateOrConnectWithoutSessionsInput').implement({
  fields: UserCreateOrConnectWithoutSessionsInputFields,
});

export const UserUpsertWithoutSessionsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":UserUpdateWithoutSessionsInput}),
  create: t.field({"required":true,"type":UserCreateWithoutSessionsInput}),
  where: t.field({"required":false,"type":UserWhereInput}),
});
export const UserUpsertWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpsertWithoutSessionsInput>>('UserUpsertWithoutSessionsInput').implement({
  fields: UserUpsertWithoutSessionsInputFields,
});

export const UserUpdateToOneWithWhereWithoutSessionsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":UserWhereInput}),
  data: t.field({"required":true,"type":UserUpdateWithoutSessionsInput}),
});
export const UserUpdateToOneWithWhereWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateToOneWithWhereWithoutSessionsInput>>('UserUpdateToOneWithWhereWithoutSessionsInput').implement({
  fields: UserUpdateToOneWithWhereWithoutSessionsInputFields,
});

export const UserUpdateWithoutSessionsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  photo: t.field({"required":false,"type":AttachmentUpdateOneWithoutUserProfilePhotoNestedInput}),
  accounts: t.field({"required":false,"type":AccountUpdateManyWithoutUserNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutUserNestedInput}),
  companiesOwned: t.field({"required":false,"type":CompanyUpdateManyWithoutOwnerNestedInput}),
});
export const UserUpdateWithoutSessionsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateWithoutSessionsInput>>('UserUpdateWithoutSessionsInput').implement({
  fields: UserUpdateWithoutSessionsInputFields,
});

export const UserCreateWithoutPhotoInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  accounts: t.field({"required":false,"type":AccountCreateNestedManyWithoutUserInput}),
  sessions: t.field({"required":false,"type":SessionCreateNestedManyWithoutUserInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutUserInput}),
  companiesOwned: t.field({"required":false,"type":CompanyCreateNestedManyWithoutOwnerInput}),
});
export const UserCreateWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateWithoutPhotoInput>>('UserCreateWithoutPhotoInput').implement({
  fields: UserCreateWithoutPhotoInputFields,
});

export const UserCreateOrConnectWithoutPhotoInputFields = (t: any) => ({
  where: t.field({"required":true,"type":UserWhereUniqueInput}),
  create: t.field({"required":true,"type":UserCreateWithoutPhotoInput}),
});
export const UserCreateOrConnectWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateOrConnectWithoutPhotoInput>>('UserCreateOrConnectWithoutPhotoInput').implement({
  fields: UserCreateOrConnectWithoutPhotoInputFields,
});

export const CandidateCreateWithoutCvInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutCvInput>>('CandidateCreateWithoutCvInput').implement({
  fields: CandidateCreateWithoutCvInputFields,
});

export const CandidateCreateOrConnectWithoutCvInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCvInput}),
});
export const CandidateCreateOrConnectWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutCvInput>>('CandidateCreateOrConnectWithoutCvInput').implement({
  fields: CandidateCreateOrConnectWithoutCvInputFields,
});

export const CandidateCreateWithoutAvatarInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutAvatarInput>>('CandidateCreateWithoutAvatarInput').implement({
  fields: CandidateCreateWithoutAvatarInputFields,
});

export const CandidateCreateOrConnectWithoutAvatarInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutAvatarInput}),
});
export const CandidateCreateOrConnectWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutAvatarInput>>('CandidateCreateOrConnectWithoutAvatarInput').implement({
  fields: CandidateCreateOrConnectWithoutAvatarInputFields,
});

export const CandidateCreateWithoutCoverLetterInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutCoverLetterInput>>('CandidateCreateWithoutCoverLetterInput').implement({
  fields: CandidateCreateWithoutCoverLetterInputFields,
});

export const CandidateCreateOrConnectWithoutCoverLetterInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCoverLetterInput}),
});
export const CandidateCreateOrConnectWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutCoverLetterInput>>('CandidateCreateOrConnectWithoutCoverLetterInput').implement({
  fields: CandidateCreateOrConnectWithoutCoverLetterInputFields,
});

export const CompanyCreateWithoutLogoInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutLogoInput>>('CompanyCreateWithoutLogoInput').implement({
  fields: CompanyCreateWithoutLogoInputFields,
});

export const CompanyCreateOrConnectWithoutLogoInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutLogoInput}),
});
export const CompanyCreateOrConnectWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutLogoInput>>('CompanyCreateOrConnectWithoutLogoInput').implement({
  fields: CompanyCreateOrConnectWithoutLogoInputFields,
});

export const HiringRoleCreateWithoutAttachmentsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutAttachmentsInput>>('HiringRoleCreateWithoutAttachmentsInput').implement({
  fields: HiringRoleCreateWithoutAttachmentsInputFields,
});

export const HiringRoleCreateOrConnectWithoutAttachmentsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutAttachmentsInput}),
});
export const HiringRoleCreateOrConnectWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutAttachmentsInput>>('HiringRoleCreateOrConnectWithoutAttachmentsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutAttachmentsInputFields,
});

export const OfferFileCreateWithoutAttachmentInputFields = (t: any) => ({
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutFilesInput}),
});
export const OfferFileCreateWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateWithoutAttachmentInput>>('OfferFileCreateWithoutAttachmentInput').implement({
  fields: OfferFileCreateWithoutAttachmentInputFields,
});

export const OfferFileCreateOrConnectWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferFileCreateWithoutAttachmentInput}),
});
export const OfferFileCreateOrConnectWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateOrConnectWithoutAttachmentInput>>('OfferFileCreateOrConnectWithoutAttachmentInput').implement({
  fields: OfferFileCreateOrConnectWithoutAttachmentInputFields,
});

export const OfferFileCreateManyAttachmentInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferFileCreateManyAttachmentInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferFileCreateManyAttachmentInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateManyAttachmentInputEnvelope>>('OfferFileCreateManyAttachmentInputEnvelope').implement({
  fields: OfferFileCreateManyAttachmentInputEnvelopeFields,
});

export const TalentPoolFileCreateWithoutAttachmentInputFields = (t: any) => ({
  talentPool: t.field({"required":true,"type":TalentPoolCreateNestedOneWithoutFilesInput}),
});
export const TalentPoolFileCreateWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateWithoutAttachmentInput>>('TalentPoolFileCreateWithoutAttachmentInput').implement({
  fields: TalentPoolFileCreateWithoutAttachmentInputFields,
});

export const TalentPoolFileCreateOrConnectWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolFileCreateWithoutAttachmentInput}),
});
export const TalentPoolFileCreateOrConnectWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateOrConnectWithoutAttachmentInput>>('TalentPoolFileCreateOrConnectWithoutAttachmentInput').implement({
  fields: TalentPoolFileCreateOrConnectWithoutAttachmentInputFields,
});

export const TalentPoolFileCreateManyAttachmentInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TalentPoolFileCreateManyAttachmentInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TalentPoolFileCreateManyAttachmentInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateManyAttachmentInputEnvelope>>('TalentPoolFileCreateManyAttachmentInputEnvelope').implement({
  fields: TalentPoolFileCreateManyAttachmentInputEnvelopeFields,
});

export const CompanyCreateWithoutAttachmentsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
});
export const CompanyCreateWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutAttachmentsInput>>('CompanyCreateWithoutAttachmentsInput').implement({
  fields: CompanyCreateWithoutAttachmentsInputFields,
});

export const CompanyCreateOrConnectWithoutAttachmentsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutAttachmentsInput}),
});
export const CompanyCreateOrConnectWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutAttachmentsInput>>('CompanyCreateOrConnectWithoutAttachmentsInput').implement({
  fields: CompanyCreateOrConnectWithoutAttachmentsInputFields,
});

export const UserUpsertWithoutPhotoInputFields = (t: any) => ({
  update: t.field({"required":true,"type":UserUpdateWithoutPhotoInput}),
  create: t.field({"required":true,"type":UserCreateWithoutPhotoInput}),
  where: t.field({"required":false,"type":UserWhereInput}),
});
export const UserUpsertWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpsertWithoutPhotoInput>>('UserUpsertWithoutPhotoInput').implement({
  fields: UserUpsertWithoutPhotoInputFields,
});

export const UserUpdateToOneWithWhereWithoutPhotoInputFields = (t: any) => ({
  where: t.field({"required":false,"type":UserWhereInput}),
  data: t.field({"required":true,"type":UserUpdateWithoutPhotoInput}),
});
export const UserUpdateToOneWithWhereWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateToOneWithWhereWithoutPhotoInput>>('UserUpdateToOneWithWhereWithoutPhotoInput').implement({
  fields: UserUpdateToOneWithWhereWithoutPhotoInputFields,
});

export const UserUpdateWithoutPhotoInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  accounts: t.field({"required":false,"type":AccountUpdateManyWithoutUserNestedInput}),
  sessions: t.field({"required":false,"type":SessionUpdateManyWithoutUserNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutUserNestedInput}),
  companiesOwned: t.field({"required":false,"type":CompanyUpdateManyWithoutOwnerNestedInput}),
});
export const UserUpdateWithoutPhotoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateWithoutPhotoInput>>('UserUpdateWithoutPhotoInput').implement({
  fields: UserUpdateWithoutPhotoInputFields,
});

export const CandidateUpsertWithoutCvInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutCvInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCvInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutCvInput>>('CandidateUpsertWithoutCvInput').implement({
  fields: CandidateUpsertWithoutCvInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutCvInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutCvInput}),
});
export const CandidateUpdateToOneWithWhereWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutCvInput>>('CandidateUpdateToOneWithWhereWithoutCvInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutCvInputFields,
});

export const CandidateUpdateWithoutCvInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutCvInput>>('CandidateUpdateWithoutCvInput').implement({
  fields: CandidateUpdateWithoutCvInputFields,
});

export const CandidateUpsertWithoutAvatarInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutAvatarInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutAvatarInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutAvatarInput>>('CandidateUpsertWithoutAvatarInput').implement({
  fields: CandidateUpsertWithoutAvatarInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutAvatarInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutAvatarInput}),
});
export const CandidateUpdateToOneWithWhereWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutAvatarInput>>('CandidateUpdateToOneWithWhereWithoutAvatarInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutAvatarInputFields,
});

export const CandidateUpdateWithoutAvatarInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutAvatarInput>>('CandidateUpdateWithoutAvatarInput').implement({
  fields: CandidateUpdateWithoutAvatarInputFields,
});

export const CandidateUpsertWithoutCoverLetterInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutCoverLetterInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCoverLetterInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutCoverLetterInput>>('CandidateUpsertWithoutCoverLetterInput').implement({
  fields: CandidateUpsertWithoutCoverLetterInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutCoverLetterInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutCoverLetterInput}),
});
export const CandidateUpdateToOneWithWhereWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutCoverLetterInput>>('CandidateUpdateToOneWithWhereWithoutCoverLetterInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutCoverLetterInputFields,
});

export const CandidateUpdateWithoutCoverLetterInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutCoverLetterInput>>('CandidateUpdateWithoutCoverLetterInput').implement({
  fields: CandidateUpdateWithoutCoverLetterInputFields,
});

export const CompanyUpsertWithoutLogoInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutLogoInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutLogoInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutLogoInput>>('CompanyUpsertWithoutLogoInput').implement({
  fields: CompanyUpsertWithoutLogoInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutLogoInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutLogoInput}),
});
export const CompanyUpdateToOneWithWhereWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutLogoInput>>('CompanyUpdateToOneWithWhereWithoutLogoInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutLogoInputFields,
});

export const CompanyUpdateWithoutLogoInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutLogoInput>>('CompanyUpdateWithoutLogoInput').implement({
  fields: CompanyUpdateWithoutLogoInputFields,
});

export const HiringRoleUpsertWithoutAttachmentsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutAttachmentsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutAttachmentsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutAttachmentsInput>>('HiringRoleUpsertWithoutAttachmentsInput').implement({
  fields: HiringRoleUpsertWithoutAttachmentsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutAttachmentsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutAttachmentsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutAttachmentsInput>>('HiringRoleUpdateToOneWithWhereWithoutAttachmentsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutAttachmentsInputFields,
});

export const HiringRoleUpdateWithoutAttachmentsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutAttachmentsInput>>('HiringRoleUpdateWithoutAttachmentsInput').implement({
  fields: HiringRoleUpdateWithoutAttachmentsInputFields,
});

export const OfferFileUpsertWithWhereUniqueWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferFileUpdateWithoutAttachmentInput}),
  create: t.field({"required":true,"type":OfferFileCreateWithoutAttachmentInput}),
});
export const OfferFileUpsertWithWhereUniqueWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpsertWithWhereUniqueWithoutAttachmentInput>>('OfferFileUpsertWithWhereUniqueWithoutAttachmentInput').implement({
  fields: OfferFileUpsertWithWhereUniqueWithoutAttachmentInputFields,
});

export const OfferFileUpdateWithWhereUniqueWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferFileUpdateWithoutAttachmentInput}),
});
export const OfferFileUpdateWithWhereUniqueWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateWithWhereUniqueWithoutAttachmentInput>>('OfferFileUpdateWithWhereUniqueWithoutAttachmentInput').implement({
  fields: OfferFileUpdateWithWhereUniqueWithoutAttachmentInputFields,
});

export const OfferFileUpdateManyWithWhereWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileScalarWhereInput}),
  data: t.field({"required":true,"type":OfferFileUpdateManyMutationInput}),
});
export const OfferFileUpdateManyWithWhereWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateManyWithWhereWithoutAttachmentInput>>('OfferFileUpdateManyWithWhereWithoutAttachmentInput').implement({
  fields: OfferFileUpdateManyWithWhereWithoutAttachmentInputFields,
});

export const OfferFileScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferFileScalarWhereInput]}),
  OR: t.field({"required":false,"type":[OfferFileScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferFileScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
});
export const OfferFileScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileScalarWhereInput>>('OfferFileScalarWhereInput').implement({
  fields: OfferFileScalarWhereInputFields,
});

export const TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  update: t.field({"required":true,"type":TalentPoolFileUpdateWithoutAttachmentInput}),
  create: t.field({"required":true,"type":TalentPoolFileCreateWithoutAttachmentInput}),
});
export const TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInput>>('TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInput').implement({
  fields: TalentPoolFileUpsertWithWhereUniqueWithoutAttachmentInputFields,
});

export const TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  data: t.field({"required":true,"type":TalentPoolFileUpdateWithoutAttachmentInput}),
});
export const TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInput>>('TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInput').implement({
  fields: TalentPoolFileUpdateWithWhereUniqueWithoutAttachmentInputFields,
});

export const TalentPoolFileUpdateManyWithWhereWithoutAttachmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileScalarWhereInput}),
  data: t.field({"required":true,"type":TalentPoolFileUpdateManyMutationInput}),
});
export const TalentPoolFileUpdateManyWithWhereWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateManyWithWhereWithoutAttachmentInput>>('TalentPoolFileUpdateManyWithWhereWithoutAttachmentInput').implement({
  fields: TalentPoolFileUpdateManyWithWhereWithoutAttachmentInputFields,
});

export const TalentPoolFileScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolFileScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolFileScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolFileScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  attachmentId: t.field({"required":false,"type":IntFilter}),
});
export const TalentPoolFileScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileScalarWhereInput>>('TalentPoolFileScalarWhereInput').implement({
  fields: TalentPoolFileScalarWhereInputFields,
});

export const CompanyUpsertWithoutAttachmentsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutAttachmentsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutAttachmentsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutAttachmentsInput>>('CompanyUpsertWithoutAttachmentsInput').implement({
  fields: CompanyUpsertWithoutAttachmentsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutAttachmentsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutAttachmentsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutAttachmentsInput>>('CompanyUpdateToOneWithWhereWithoutAttachmentsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutAttachmentsInputFields,
});

export const CompanyUpdateWithoutAttachmentsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
});
export const CompanyUpdateWithoutAttachmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutAttachmentsInput>>('CompanyUpdateWithoutAttachmentsInput').implement({
  fields: CompanyUpdateWithoutAttachmentsInputFields,
});

export const UserCreateWithoutHiringRolesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  photo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutUserProfilePhotoInput}),
  accounts: t.field({"required":false,"type":AccountCreateNestedManyWithoutUserInput}),
  sessions: t.field({"required":false,"type":SessionCreateNestedManyWithoutUserInput}),
  companiesOwned: t.field({"required":false,"type":CompanyCreateNestedManyWithoutOwnerInput}),
});
export const UserCreateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateWithoutHiringRolesInput>>('UserCreateWithoutHiringRolesInput').implement({
  fields: UserCreateWithoutHiringRolesInputFields,
});

export const UserCreateOrConnectWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":UserWhereUniqueInput}),
  create: t.field({"required":true,"type":UserCreateWithoutHiringRolesInput}),
});
export const UserCreateOrConnectWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateOrConnectWithoutHiringRolesInput>>('UserCreateOrConnectWithoutHiringRolesInput').implement({
  fields: UserCreateOrConnectWithoutHiringRolesInputFields,
});

export const RoleCreateWithoutHiringRolesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutRolesInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutRoleInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutRoleInput}),
});
export const RoleCreateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateWithoutHiringRolesInput>>('RoleCreateWithoutHiringRolesInput').implement({
  fields: RoleCreateWithoutHiringRolesInputFields,
});

export const RoleCreateOrConnectWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutHiringRolesInput}),
});
export const RoleCreateOrConnectWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateOrConnectWithoutHiringRolesInput>>('RoleCreateOrConnectWithoutHiringRolesInput').implement({
  fields: RoleCreateOrConnectWithoutHiringRolesInputFields,
});

export const CompanyCreateWithoutHiringRolesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutHiringRolesInput>>('CompanyCreateWithoutHiringRolesInput').implement({
  fields: CompanyCreateWithoutHiringRolesInputFields,
});

export const CompanyCreateOrConnectWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutHiringRolesInput}),
});
export const CompanyCreateOrConnectWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutHiringRolesInput>>('CompanyCreateOrConnectWithoutHiringRolesInput').implement({
  fields: CompanyCreateOrConnectWithoutHiringRolesInputFields,
});

export const AttachmentCreateWithoutUploaderInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutUploaderInput>>('AttachmentCreateWithoutUploaderInput').implement({
  fields: AttachmentCreateWithoutUploaderInputFields,
});

export const AttachmentCreateOrConnectWithoutUploaderInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutUploaderInput}),
});
export const AttachmentCreateOrConnectWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutUploaderInput>>('AttachmentCreateOrConnectWithoutUploaderInput').implement({
  fields: AttachmentCreateOrConnectWithoutUploaderInputFields,
});

export const AttachmentCreateManyUploaderInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AttachmentCreateManyUploaderInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AttachmentCreateManyUploaderInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateManyUploaderInputEnvelope>>('AttachmentCreateManyUploaderInputEnvelope').implement({
  fields: AttachmentCreateManyUploaderInputEnvelopeFields,
});

export const AuditLogCreateWithoutUserInputFields = (t: any) => ({
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAuditLogsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutAuditLogsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAuditLogsInput}),
});
export const AuditLogCreateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateWithoutUserInput>>('AuditLogCreateWithoutUserInput').implement({
  fields: AuditLogCreateWithoutUserInputFields,
});

export const AuditLogCreateOrConnectWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutUserInput}),
});
export const AuditLogCreateOrConnectWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateOrConnectWithoutUserInput>>('AuditLogCreateOrConnectWithoutUserInput').implement({
  fields: AuditLogCreateOrConnectWithoutUserInputFields,
});

export const AuditLogCreateManyUserInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AuditLogCreateManyUserInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AuditLogCreateManyUserInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyUserInputEnvelope>>('AuditLogCreateManyUserInputEnvelope').implement({
  fields: AuditLogCreateManyUserInputEnvelopeFields,
});

export const EventScheduleInterviewerCreateWithoutTeamMemberInputFields = (t: any) => ({
  availability: t.field({"required":true,"type":Json}),
  eventSchedule: t.field({"required":true,"type":EventScheduleCreateNestedOneWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleInterviewerCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateWithoutTeamMemberInput>>('EventScheduleInterviewerCreateWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerCreateWithoutTeamMemberInputFields,
});

export const EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleInterviewerCreateWithoutTeamMemberInput}),
});
export const EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInput>>('EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerCreateOrConnectWithoutTeamMemberInputFields,
});

export const EventScheduleInterviewerCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventScheduleInterviewerCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventScheduleInterviewerCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateManyTeamMemberInputEnvelope>>('EventScheduleInterviewerCreateManyTeamMemberInputEnvelope').implement({
  fields: EventScheduleInterviewerCreateManyTeamMemberInputEnvelopeFields,
});

export const EventCreateWithoutCreatedByInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutCreatedByInput>>('EventCreateWithoutCreatedByInput').implement({
  fields: EventCreateWithoutCreatedByInputFields,
});

export const EventCreateOrConnectWithoutCreatedByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCreatedByInput}),
});
export const EventCreateOrConnectWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutCreatedByInput>>('EventCreateOrConnectWithoutCreatedByInput').implement({
  fields: EventCreateOrConnectWithoutCreatedByInputFields,
});

export const EventCreateManyCreatedByInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventCreateManyCreatedByInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventCreateManyCreatedByInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateManyCreatedByInputEnvelope>>('EventCreateManyCreatedByInputEnvelope').implement({
  fields: EventCreateManyCreatedByInputEnvelopeFields,
});

export const OfferCreateWithoutRecruiterInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutRecruiterInput>>('OfferCreateWithoutRecruiterInput').implement({
  fields: OfferCreateWithoutRecruiterInputFields,
});

export const OfferCreateOrConnectWithoutRecruiterInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutRecruiterInput}),
});
export const OfferCreateOrConnectWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutRecruiterInput>>('OfferCreateOrConnectWithoutRecruiterInput').implement({
  fields: OfferCreateOrConnectWithoutRecruiterInputFields,
});

export const OfferCreateWithoutHiringManagerInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutHiringManagerInput>>('OfferCreateWithoutHiringManagerInput').implement({
  fields: OfferCreateWithoutHiringManagerInputFields,
});

export const OfferCreateOrConnectWithoutHiringManagerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutHiringManagerInput}),
});
export const OfferCreateOrConnectWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutHiringManagerInput>>('OfferCreateOrConnectWithoutHiringManagerInput').implement({
  fields: OfferCreateOrConnectWithoutHiringManagerInputFields,
});

export const MembershipCreateWithoutTeamMemberInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutMembershipsInput}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMembershipsInput}),
});
export const MembershipCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateWithoutTeamMemberInput>>('MembershipCreateWithoutTeamMemberInput').implement({
  fields: MembershipCreateWithoutTeamMemberInputFields,
});

export const MembershipCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutTeamMemberInput}),
});
export const MembershipCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateOrConnectWithoutTeamMemberInput>>('MembershipCreateOrConnectWithoutTeamMemberInput').implement({
  fields: MembershipCreateOrConnectWithoutTeamMemberInputFields,
});

export const MembershipCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MembershipCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MembershipCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyTeamMemberInputEnvelope>>('MembershipCreateManyTeamMemberInputEnvelope').implement({
  fields: MembershipCreateManyTeamMemberInputEnvelopeFields,
});

export const StageVisibilityCreateWithoutTeamMemberInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutStageVisibilityInput}),
  stage: t.field({"required":true,"type":StageCreateNestedOneWithoutVisibilityInput}),
});
export const StageVisibilityCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateWithoutTeamMemberInput>>('StageVisibilityCreateWithoutTeamMemberInput').implement({
  fields: StageVisibilityCreateWithoutTeamMemberInputFields,
});

export const StageVisibilityCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutTeamMemberInput}),
});
export const StageVisibilityCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateOrConnectWithoutTeamMemberInput>>('StageVisibilityCreateOrConnectWithoutTeamMemberInput').implement({
  fields: StageVisibilityCreateOrConnectWithoutTeamMemberInputFields,
});

export const StageVisibilityCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[StageVisibilityCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const StageVisibilityCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyTeamMemberInputEnvelope>>('StageVisibilityCreateManyTeamMemberInputEnvelope').implement({
  fields: StageVisibilityCreateManyTeamMemberInputEnvelopeFields,
});

export const CandidateCreateWithoutHiredByInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutHiredByInput>>('CandidateCreateWithoutHiredByInput').implement({
  fields: CandidateCreateWithoutHiredByInputFields,
});

export const CandidateCreateOrConnectWithoutHiredByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutHiredByInput}),
});
export const CandidateCreateOrConnectWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutHiredByInput>>('CandidateCreateOrConnectWithoutHiredByInput').implement({
  fields: CandidateCreateOrConnectWithoutHiredByInputFields,
});

export const CandidateCreateManyHiredByInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCreateManyHiredByInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCreateManyHiredByInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyHiredByInputEnvelope>>('CandidateCreateManyHiredByInputEnvelope').implement({
  fields: CandidateCreateManyHiredByInputEnvelopeFields,
});

export const EvaluationCreateWithoutTeamMemberInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutTeamMemberInput>>('EvaluationCreateWithoutTeamMemberInput').implement({
  fields: EvaluationCreateWithoutTeamMemberInputFields,
});

export const EvaluationCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutTeamMemberInput}),
});
export const EvaluationCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutTeamMemberInput>>('EvaluationCreateOrConnectWithoutTeamMemberInput').implement({
  fields: EvaluationCreateOrConnectWithoutTeamMemberInputFields,
});

export const EvaluationCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyTeamMemberInputEnvelope>>('EvaluationCreateManyTeamMemberInputEnvelope').implement({
  fields: EvaluationCreateManyTeamMemberInputEnvelopeFields,
});

export const TaskMemberCreateWithoutTeamMemberInputFields = (t: any) => ({
  task: t.field({"required":true,"type":TaskCreateNestedOneWithoutTaskMembersInput}),
});
export const TaskMemberCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateWithoutTeamMemberInput>>('TaskMemberCreateWithoutTeamMemberInput').implement({
  fields: TaskMemberCreateWithoutTeamMemberInputFields,
});

export const TaskMemberCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  create: t.field({"required":true,"type":TaskMemberCreateWithoutTeamMemberInput}),
});
export const TaskMemberCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateOrConnectWithoutTeamMemberInput>>('TaskMemberCreateOrConnectWithoutTeamMemberInput').implement({
  fields: TaskMemberCreateOrConnectWithoutTeamMemberInputFields,
});

export const TaskMemberCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TaskMemberCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TaskMemberCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateManyTeamMemberInputEnvelope>>('TaskMemberCreateManyTeamMemberInputEnvelope').implement({
  fields: TaskMemberCreateManyTeamMemberInputEnvelopeFields,
});

export const FollowCreateWithoutTeamMemberInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutFollowsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutFollowsInput}),
  talentPool: t.field({"required":false,"type":TalentPoolCreateNestedOneWithoutFollowsInput}),
});
export const FollowCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateWithoutTeamMemberInput>>('FollowCreateWithoutTeamMemberInput').implement({
  fields: FollowCreateWithoutTeamMemberInputFields,
});

export const FollowCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutTeamMemberInput}),
});
export const FollowCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateOrConnectWithoutTeamMemberInput>>('FollowCreateOrConnectWithoutTeamMemberInput').implement({
  fields: FollowCreateOrConnectWithoutTeamMemberInputFields,
});

export const FollowCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[FollowCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const FollowCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyTeamMemberInputEnvelope>>('FollowCreateManyTeamMemberInputEnvelope').implement({
  fields: FollowCreateManyTeamMemberInputEnvelopeFields,
});

export const EventCreateWithoutInterviewersInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutInterviewersInput>>('EventCreateWithoutInterviewersInput').implement({
  fields: EventCreateWithoutInterviewersInputFields,
});

export const EventCreateOrConnectWithoutInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutInterviewersInput}),
});
export const EventCreateOrConnectWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutInterviewersInput>>('EventCreateOrConnectWithoutInterviewersInput').implement({
  fields: EventCreateOrConnectWithoutInterviewersInputFields,
});

export const EventInterviewerCreateWithoutTeamMemberInputFields = (t: any) => ({
  event: t.field({"required":true,"type":EventCreateNestedOneWithoutEventInterviewerInput}),
});
export const EventInterviewerCreateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateWithoutTeamMemberInput>>('EventInterviewerCreateWithoutTeamMemberInput').implement({
  fields: EventInterviewerCreateWithoutTeamMemberInputFields,
});

export const EventInterviewerCreateOrConnectWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  create: t.field({"required":true,"type":EventInterviewerCreateWithoutTeamMemberInput}),
});
export const EventInterviewerCreateOrConnectWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateOrConnectWithoutTeamMemberInput>>('EventInterviewerCreateOrConnectWithoutTeamMemberInput').implement({
  fields: EventInterviewerCreateOrConnectWithoutTeamMemberInputFields,
});

export const EventInterviewerCreateManyTeamMemberInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventInterviewerCreateManyTeamMemberInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventInterviewerCreateManyTeamMemberInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateManyTeamMemberInputEnvelope>>('EventInterviewerCreateManyTeamMemberInputEnvelope').implement({
  fields: EventInterviewerCreateManyTeamMemberInputEnvelopeFields,
});

export const UserUpsertWithoutHiringRolesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":UserUpdateWithoutHiringRolesInput}),
  create: t.field({"required":true,"type":UserCreateWithoutHiringRolesInput}),
  where: t.field({"required":false,"type":UserWhereInput}),
});
export const UserUpsertWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpsertWithoutHiringRolesInput>>('UserUpsertWithoutHiringRolesInput').implement({
  fields: UserUpsertWithoutHiringRolesInputFields,
});

export const UserUpdateToOneWithWhereWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":UserWhereInput}),
  data: t.field({"required":true,"type":UserUpdateWithoutHiringRolesInput}),
});
export const UserUpdateToOneWithWhereWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateToOneWithWhereWithoutHiringRolesInput>>('UserUpdateToOneWithWhereWithoutHiringRolesInput').implement({
  fields: UserUpdateToOneWithWhereWithoutHiringRolesInputFields,
});

export const UserUpdateWithoutHiringRolesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  photo: t.field({"required":false,"type":AttachmentUpdateOneWithoutUserProfilePhotoNestedInput}),
  accounts: t.field({"required":false,"type":AccountUpdateManyWithoutUserNestedInput}),
  sessions: t.field({"required":false,"type":SessionUpdateManyWithoutUserNestedInput}),
  companiesOwned: t.field({"required":false,"type":CompanyUpdateManyWithoutOwnerNestedInput}),
});
export const UserUpdateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateWithoutHiringRolesInput>>('UserUpdateWithoutHiringRolesInput').implement({
  fields: UserUpdateWithoutHiringRolesInputFields,
});

export const RoleUpsertWithoutHiringRolesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":RoleUpdateWithoutHiringRolesInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutHiringRolesInput}),
  where: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleUpsertWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpsertWithoutHiringRolesInput>>('RoleUpsertWithoutHiringRolesInput').implement({
  fields: RoleUpsertWithoutHiringRolesInputFields,
});

export const RoleUpdateToOneWithWhereWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":RoleWhereInput}),
  data: t.field({"required":true,"type":RoleUpdateWithoutHiringRolesInput}),
});
export const RoleUpdateToOneWithWhereWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateToOneWithWhereWithoutHiringRolesInput>>('RoleUpdateToOneWithWhereWithoutHiringRolesInput').implement({
  fields: RoleUpdateToOneWithWhereWithoutHiringRolesInputFields,
});

export const RoleUpdateWithoutHiringRolesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutRolesNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutRoleNestedInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutRoleNestedInput}),
});
export const RoleUpdateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateWithoutHiringRolesInput>>('RoleUpdateWithoutHiringRolesInput').implement({
  fields: RoleUpdateWithoutHiringRolesInputFields,
});

export const CompanyUpsertWithoutHiringRolesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutHiringRolesInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutHiringRolesInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutHiringRolesInput>>('CompanyUpsertWithoutHiringRolesInput').implement({
  fields: CompanyUpsertWithoutHiringRolesInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutHiringRolesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutHiringRolesInput}),
});
export const CompanyUpdateToOneWithWhereWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutHiringRolesInput>>('CompanyUpdateToOneWithWhereWithoutHiringRolesInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutHiringRolesInputFields,
});

export const CompanyUpdateWithoutHiringRolesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutHiringRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutHiringRolesInput>>('CompanyUpdateWithoutHiringRolesInput').implement({
  fields: CompanyUpdateWithoutHiringRolesInputFields,
});

export const AttachmentUpsertWithWhereUniqueWithoutUploaderInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":true,"type":AttachmentUpdateWithoutUploaderInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutUploaderInput}),
});
export const AttachmentUpsertWithWhereUniqueWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithWhereUniqueWithoutUploaderInput>>('AttachmentUpsertWithWhereUniqueWithoutUploaderInput').implement({
  fields: AttachmentUpsertWithWhereUniqueWithoutUploaderInputFields,
});

export const AttachmentUpdateWithWhereUniqueWithoutUploaderInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutUploaderInput}),
});
export const AttachmentUpdateWithWhereUniqueWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithWhereUniqueWithoutUploaderInput>>('AttachmentUpdateWithWhereUniqueWithoutUploaderInput').implement({
  fields: AttachmentUpdateWithWhereUniqueWithoutUploaderInputFields,
});

export const AttachmentUpdateManyWithWhereWithoutUploaderInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentScalarWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateManyMutationInput}),
});
export const AttachmentUpdateManyWithWhereWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateManyWithWhereWithoutUploaderInput>>('AttachmentUpdateManyWithWhereWithoutUploaderInput').implement({
  fields: AttachmentUpdateManyWithWhereWithoutUploaderInputFields,
});

export const AttachmentScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AttachmentScalarWhereInput]}),
  OR: t.field({"required":false,"type":[AttachmentScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[AttachmentScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  contentType: t.field({"required":false,"type":StringFilter}),
  filename: t.field({"required":false,"type":StringFilter}),
  path: t.field({"required":false,"type":StringFilter}),
  size: t.field({"required":false,"type":IntNullableFilter}),
  uploaderId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const AttachmentScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentScalarWhereInput>>('AttachmentScalarWhereInput').implement({
  fields: AttachmentScalarWhereInputFields,
});

export const AuditLogUpsertWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  update: t.field({"required":true,"type":AuditLogUpdateWithoutUserInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutUserInput}),
});
export const AuditLogUpsertWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpsertWithWhereUniqueWithoutUserInput>>('AuditLogUpsertWithWhereUniqueWithoutUserInput').implement({
  fields: AuditLogUpsertWithWhereUniqueWithoutUserInputFields,
});

export const AuditLogUpdateWithWhereUniqueWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  data: t.field({"required":true,"type":AuditLogUpdateWithoutUserInput}),
});
export const AuditLogUpdateWithWhereUniqueWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithWhereUniqueWithoutUserInput>>('AuditLogUpdateWithWhereUniqueWithoutUserInput').implement({
  fields: AuditLogUpdateWithWhereUniqueWithoutUserInputFields,
});

export const AuditLogUpdateManyWithWhereWithoutUserInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogScalarWhereInput}),
  data: t.field({"required":true,"type":AuditLogUpdateManyMutationInput}),
});
export const AuditLogUpdateManyWithWhereWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithWhereWithoutUserInput>>('AuditLogUpdateManyWithWhereWithoutUserInput').implement({
  fields: AuditLogUpdateManyWithWhereWithoutUserInputFields,
});

export const AuditLogScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
  OR: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[AuditLogScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  userId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  actor: t.field({"required":false,"type":StringFilter}),
  actorType: t.field({"required":false,"type":StringFilter}),
  ip: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":StringFilter}),
  eventDetails: t.field({"required":false,"type":JsonFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const AuditLogScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogScalarWhereInput>>('AuditLogScalarWhereInput').implement({
  fields: AuditLogScalarWhereInputFields,
});

export const EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  update: t.field({"required":true,"type":EventScheduleInterviewerUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":EventScheduleInterviewerCreateWithoutTeamMemberInput}),
});
export const EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput>>('EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  data: t.field({"required":true,"type":EventScheduleInterviewerUpdateWithoutTeamMemberInput}),
});
export const EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput>>('EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerScalarWhereInput}),
  data: t.field({"required":true,"type":EventScheduleInterviewerUpdateManyMutationInput}),
});
export const EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInput>>('EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const EventScheduleInterviewerScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleInterviewerScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  availability: t.field({"required":false,"type":JsonFilter}),
});
export const EventScheduleInterviewerScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerScalarWhereInput>>('EventScheduleInterviewerScalarWhereInput').implement({
  fields: EventScheduleInterviewerScalarWhereInputFields,
});

export const EventUpsertWithWhereUniqueWithoutCreatedByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  update: t.field({"required":true,"type":EventUpdateWithoutCreatedByInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCreatedByInput}),
});
export const EventUpsertWithWhereUniqueWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithWhereUniqueWithoutCreatedByInput>>('EventUpsertWithWhereUniqueWithoutCreatedByInput').implement({
  fields: EventUpsertWithWhereUniqueWithoutCreatedByInputFields,
});

export const EventUpdateWithWhereUniqueWithoutCreatedByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutCreatedByInput}),
});
export const EventUpdateWithWhereUniqueWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithWhereUniqueWithoutCreatedByInput>>('EventUpdateWithWhereUniqueWithoutCreatedByInput').implement({
  fields: EventUpdateWithWhereUniqueWithoutCreatedByInputFields,
});

export const EventUpdateManyWithWhereWithoutCreatedByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScalarWhereInput}),
  data: t.field({"required":true,"type":EventUpdateManyMutationInput}),
});
export const EventUpdateManyWithWhereWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithWhereWithoutCreatedByInput>>('EventUpdateManyWithWhereWithoutCreatedByInput').implement({
  fields: EventUpdateManyWithWhereWithoutCreatedByInputFields,
});

export const EventScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EventScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  date: t.field({"required":false,"type":DateTimeFilter}),
  duration: t.field({"required":false,"type":IntNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringNullableFilter}),
  note: t.field({"required":false,"type":StringNullableFilter}),
  privateNote: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
  createdById: t.field({"required":false,"type":IntFilter}),
});
export const EventScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScalarWhereInput>>('EventScalarWhereInput').implement({
  fields: EventScalarWhereInputFields,
});

export const OfferUpsertWithoutRecruiterInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutRecruiterInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutRecruiterInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutRecruiterInput>>('OfferUpsertWithoutRecruiterInput').implement({
  fields: OfferUpsertWithoutRecruiterInputFields,
});

export const OfferUpdateToOneWithWhereWithoutRecruiterInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutRecruiterInput}),
});
export const OfferUpdateToOneWithWhereWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutRecruiterInput>>('OfferUpdateToOneWithWhereWithoutRecruiterInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutRecruiterInputFields,
});

export const OfferUpdateWithoutRecruiterInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutRecruiterInput>>('OfferUpdateWithoutRecruiterInput').implement({
  fields: OfferUpdateWithoutRecruiterInputFields,
});

export const OfferUpsertWithoutHiringManagerInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutHiringManagerInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutHiringManagerInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutHiringManagerInput>>('OfferUpsertWithoutHiringManagerInput').implement({
  fields: OfferUpsertWithoutHiringManagerInputFields,
});

export const OfferUpdateToOneWithWhereWithoutHiringManagerInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutHiringManagerInput}),
});
export const OfferUpdateToOneWithWhereWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutHiringManagerInput>>('OfferUpdateToOneWithWhereWithoutHiringManagerInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutHiringManagerInputFields,
});

export const OfferUpdateWithoutHiringManagerInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutHiringManagerInput>>('OfferUpdateWithoutHiringManagerInput').implement({
  fields: OfferUpdateWithoutHiringManagerInputFields,
});

export const MembershipUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  update: t.field({"required":true,"type":MembershipUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutTeamMemberInput}),
});
export const MembershipUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpsertWithWhereUniqueWithoutTeamMemberInput>>('MembershipUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: MembershipUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const MembershipUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  data: t.field({"required":true,"type":MembershipUpdateWithoutTeamMemberInput}),
});
export const MembershipUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithWhereUniqueWithoutTeamMemberInput>>('MembershipUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: MembershipUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const MembershipUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipScalarWhereInput}),
  data: t.field({"required":true,"type":MembershipUpdateManyMutationInput}),
});
export const MembershipUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithWhereWithoutTeamMemberInput>>('MembershipUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: MembershipUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const MembershipScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
  OR: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[MembershipScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
});
export const MembershipScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipScalarWhereInput>>('MembershipScalarWhereInput').implement({
  fields: MembershipScalarWhereInputFields,
});

export const StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  update: t.field({"required":true,"type":StageVisibilityUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutTeamMemberInput}),
});
export const StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInput>>('StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: StageVisibilityUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateWithoutTeamMemberInput}),
});
export const StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInput>>('StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: StageVisibilityUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const StageVisibilityUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityScalarWhereInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateManyMutationInput}),
});
export const StageVisibilityUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithWhereWithoutTeamMemberInput>>('StageVisibilityUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: StageVisibilityUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const StageVisibilityScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
  OR: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[StageVisibilityScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":EnumMembershipTypesFilter}),
  teamMemberId: t.field({"required":false,"type":IntNullableFilter}),
  roleId: t.field({"required":false,"type":IntNullableFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
});
export const StageVisibilityScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityScalarWhereInput>>('StageVisibilityScalarWhereInput').implement({
  fields: StageVisibilityScalarWhereInputFields,
});

export const CandidateUpsertWithWhereUniqueWithoutHiredByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateUpdateWithoutHiredByInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutHiredByInput}),
});
export const CandidateUpsertWithWhereUniqueWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithWhereUniqueWithoutHiredByInput>>('CandidateUpsertWithWhereUniqueWithoutHiredByInput').implement({
  fields: CandidateUpsertWithWhereUniqueWithoutHiredByInputFields,
});

export const CandidateUpdateWithWhereUniqueWithoutHiredByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutHiredByInput}),
});
export const CandidateUpdateWithWhereUniqueWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithWhereUniqueWithoutHiredByInput>>('CandidateUpdateWithWhereUniqueWithoutHiredByInput').implement({
  fields: CandidateUpdateWithWhereUniqueWithoutHiredByInputFields,
});

export const CandidateUpdateManyWithWhereWithoutHiredByInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateManyMutationInput}),
});
export const CandidateUpdateManyWithWhereWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithWhereWithoutHiredByInput>>('CandidateUpdateManyWithWhereWithoutHiredByInput').implement({
  fields: CandidateUpdateManyWithWhereWithoutHiredByInputFields,
});

export const CandidateScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  firstName: t.field({"required":false,"type":StringFilter}),
  lastName: t.field({"required":false,"type":StringFilter}),
  email: t.field({"required":false,"type":StringFilter}),
  phone: t.field({"required":false,"type":StringNullableFilter}),
  skills: t.field({"required":false,"type":StringNullableListFilter}),
  mainLanguage: t.field({"required":false,"type":StringFilter}),
  languages: t.field({"required":false,"type":StringNullableListFilter}),
  coverLetterText: t.field({"required":false,"type":StringNullableFilter}),
  birthday: t.field({"required":false,"type":DateTimeNullableFilter}),
  referrerId: t.field({"required":false,"type":IntNullableFilter}),
  cvId: t.field({"required":false,"type":IntNullableFilter}),
  avatarId: t.field({"required":false,"type":IntNullableFilter}),
  coverLetterId: t.field({"required":false,"type":IntNullableFilter}),
  educationLevel: t.field({"required":false,"type":StringNullableFilter}),
  socials: t.field({"required":false,"type":StringNullableListFilter}),
  links: t.field({"required":false,"type":StringNullableListFilter}),
  salaryExpectation: t.field({"required":false,"type":IntNullableFilter}),
  hiredAtId: t.field({"required":false,"type":IntNullableFilter}),
  hiredById: t.field({"required":false,"type":IntNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const CandidateScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateScalarWhereInput>>('CandidateScalarWhereInput').implement({
  fields: CandidateScalarWhereInputFields,
});

export const EvaluationUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutTeamMemberInput}),
});
export const EvaluationUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithWhereUniqueWithoutTeamMemberInput>>('EvaluationUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EvaluationUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EvaluationUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutTeamMemberInput}),
});
export const EvaluationUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithWhereUniqueWithoutTeamMemberInput>>('EvaluationUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EvaluationUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EvaluationUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateManyMutationInput}),
});
export const EvaluationUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithWhereWithoutTeamMemberInput>>('EvaluationUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: EvaluationUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const EvaluationScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  templateId: t.field({"required":false,"type":IntNullableFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
  isQuickEval: t.field({"required":false,"type":BoolFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFilter}),
  eventId: t.field({"required":false,"type":IntNullableFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const EvaluationScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationScalarWhereInput>>('EvaluationScalarWhereInput').implement({
  fields: EvaluationScalarWhereInputFields,
});

export const TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  update: t.field({"required":true,"type":TaskMemberUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":TaskMemberCreateWithoutTeamMemberInput}),
});
export const TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInput>>('TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: TaskMemberUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  data: t.field({"required":true,"type":TaskMemberUpdateWithoutTeamMemberInput}),
});
export const TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInput>>('TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: TaskMemberUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const TaskMemberUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberScalarWhereInput}),
  data: t.field({"required":true,"type":TaskMemberUpdateManyMutationInput}),
});
export const TaskMemberUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateManyWithWhereWithoutTeamMemberInput>>('TaskMemberUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: TaskMemberUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const TaskMemberScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskMemberScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TaskMemberScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskMemberScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  taskId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
});
export const TaskMemberScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberScalarWhereInput>>('TaskMemberScalarWhereInput').implement({
  fields: TaskMemberScalarWhereInputFields,
});

export const FollowUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  update: t.field({"required":true,"type":FollowUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutTeamMemberInput}),
});
export const FollowUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpsertWithWhereUniqueWithoutTeamMemberInput>>('FollowUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: FollowUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const FollowUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  data: t.field({"required":true,"type":FollowUpdateWithoutTeamMemberInput}),
});
export const FollowUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithWhereUniqueWithoutTeamMemberInput>>('FollowUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: FollowUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const FollowUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowScalarWhereInput}),
  data: t.field({"required":true,"type":FollowUpdateManyMutationInput}),
});
export const FollowUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithWhereWithoutTeamMemberInput>>('FollowUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: FollowUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const FollowScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[FollowScalarWhereInput]}),
  OR: t.field({"required":false,"type":[FollowScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[FollowScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntNullableFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
  talentPoolId: t.field({"required":false,"type":IntNullableFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
});
export const FollowScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowScalarWhereInput>>('FollowScalarWhereInput').implement({
  fields: FollowScalarWhereInputFields,
});

export const EventUpsertWithWhereUniqueWithoutInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  update: t.field({"required":true,"type":EventUpdateWithoutInterviewersInput}),
  create: t.field({"required":true,"type":EventCreateWithoutInterviewersInput}),
});
export const EventUpsertWithWhereUniqueWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithWhereUniqueWithoutInterviewersInput>>('EventUpsertWithWhereUniqueWithoutInterviewersInput').implement({
  fields: EventUpsertWithWhereUniqueWithoutInterviewersInputFields,
});

export const EventUpdateWithWhereUniqueWithoutInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutInterviewersInput}),
});
export const EventUpdateWithWhereUniqueWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithWhereUniqueWithoutInterviewersInput>>('EventUpdateWithWhereUniqueWithoutInterviewersInput').implement({
  fields: EventUpdateWithWhereUniqueWithoutInterviewersInputFields,
});

export const EventUpdateManyWithWhereWithoutInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScalarWhereInput}),
  data: t.field({"required":true,"type":EventUpdateManyMutationInput}),
});
export const EventUpdateManyWithWhereWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithWhereWithoutInterviewersInput>>('EventUpdateManyWithWhereWithoutInterviewersInput').implement({
  fields: EventUpdateManyWithWhereWithoutInterviewersInputFields,
});

export const EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  update: t.field({"required":true,"type":EventInterviewerUpdateWithoutTeamMemberInput}),
  create: t.field({"required":true,"type":EventInterviewerCreateWithoutTeamMemberInput}),
});
export const EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput>>('EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EventInterviewerUpsertWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  data: t.field({"required":true,"type":EventInterviewerUpdateWithoutTeamMemberInput}),
});
export const EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput>>('EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInput').implement({
  fields: EventInterviewerUpdateWithWhereUniqueWithoutTeamMemberInputFields,
});

export const EventInterviewerUpdateManyWithWhereWithoutTeamMemberInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerScalarWhereInput}),
  data: t.field({"required":true,"type":EventInterviewerUpdateManyMutationInput}),
});
export const EventInterviewerUpdateManyWithWhereWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateManyWithWhereWithoutTeamMemberInput>>('EventInterviewerUpdateManyWithWhereWithoutTeamMemberInput').implement({
  fields: EventInterviewerUpdateManyWithWhereWithoutTeamMemberInputFields,
});

export const EventInterviewerScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventInterviewerScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EventInterviewerScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EventInterviewerScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventId: t.field({"required":false,"type":IntFilter}),
  teamMemberId: t.field({"required":false,"type":IntFilter}),
});
export const EventInterviewerScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerScalarWhereInput>>('EventInterviewerScalarWhereInput').implement({
  fields: EventInterviewerScalarWhereInputFields,
});

export const CompanyCreateWithoutRolesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutRolesInput>>('CompanyCreateWithoutRolesInput').implement({
  fields: CompanyCreateWithoutRolesInputFields,
});

export const CompanyCreateOrConnectWithoutRolesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutRolesInput}),
});
export const CompanyCreateOrConnectWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutRolesInput>>('CompanyCreateOrConnectWithoutRolesInput').implement({
  fields: CompanyCreateOrConnectWithoutRolesInputFields,
});

export const HiringRoleCreateWithoutRoleInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutRoleInput>>('HiringRoleCreateWithoutRoleInput').implement({
  fields: HiringRoleCreateWithoutRoleInputFields,
});

export const HiringRoleCreateOrConnectWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutRoleInput}),
});
export const HiringRoleCreateOrConnectWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutRoleInput>>('HiringRoleCreateOrConnectWithoutRoleInput').implement({
  fields: HiringRoleCreateOrConnectWithoutRoleInputFields,
});

export const HiringRoleCreateManyRoleInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[HiringRoleCreateManyRoleInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const HiringRoleCreateManyRoleInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyRoleInputEnvelope>>('HiringRoleCreateManyRoleInputEnvelope').implement({
  fields: HiringRoleCreateManyRoleInputEnvelopeFields,
});

export const MembershipCreateWithoutRoleInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutMembershipsInput}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMembershipsInput}),
});
export const MembershipCreateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateWithoutRoleInput>>('MembershipCreateWithoutRoleInput').implement({
  fields: MembershipCreateWithoutRoleInputFields,
});

export const MembershipCreateOrConnectWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutRoleInput}),
});
export const MembershipCreateOrConnectWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateOrConnectWithoutRoleInput>>('MembershipCreateOrConnectWithoutRoleInput').implement({
  fields: MembershipCreateOrConnectWithoutRoleInputFields,
});

export const MembershipCreateManyRoleInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MembershipCreateManyRoleInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MembershipCreateManyRoleInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyRoleInputEnvelope>>('MembershipCreateManyRoleInputEnvelope').implement({
  fields: MembershipCreateManyRoleInputEnvelopeFields,
});

export const StageVisibilityCreateWithoutRoleInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutStageVisibilitiesInput}),
  stage: t.field({"required":true,"type":StageCreateNestedOneWithoutVisibilityInput}),
});
export const StageVisibilityCreateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateWithoutRoleInput>>('StageVisibilityCreateWithoutRoleInput').implement({
  fields: StageVisibilityCreateWithoutRoleInputFields,
});

export const StageVisibilityCreateOrConnectWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutRoleInput}),
});
export const StageVisibilityCreateOrConnectWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateOrConnectWithoutRoleInput>>('StageVisibilityCreateOrConnectWithoutRoleInput').implement({
  fields: StageVisibilityCreateOrConnectWithoutRoleInputFields,
});

export const StageVisibilityCreateManyRoleInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[StageVisibilityCreateManyRoleInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const StageVisibilityCreateManyRoleInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyRoleInputEnvelope>>('StageVisibilityCreateManyRoleInputEnvelope').implement({
  fields: StageVisibilityCreateManyRoleInputEnvelopeFields,
});

export const CompanyUpsertWithoutRolesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutRolesInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutRolesInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutRolesInput>>('CompanyUpsertWithoutRolesInput').implement({
  fields: CompanyUpsertWithoutRolesInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutRolesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutRolesInput}),
});
export const CompanyUpdateToOneWithWhereWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutRolesInput>>('CompanyUpdateToOneWithWhereWithoutRolesInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutRolesInputFields,
});

export const CompanyUpdateWithoutRolesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutRolesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutRolesInput>>('CompanyUpdateWithoutRolesInput').implement({
  fields: CompanyUpdateWithoutRolesInputFields,
});

export const HiringRoleUpsertWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutRoleInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutRoleInput}),
});
export const HiringRoleUpsertWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithWhereUniqueWithoutRoleInput>>('HiringRoleUpsertWithWhereUniqueWithoutRoleInput').implement({
  fields: HiringRoleUpsertWithWhereUniqueWithoutRoleInputFields,
});

export const HiringRoleUpdateWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutRoleInput}),
});
export const HiringRoleUpdateWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithWhereUniqueWithoutRoleInput>>('HiringRoleUpdateWithWhereUniqueWithoutRoleInput').implement({
  fields: HiringRoleUpdateWithWhereUniqueWithoutRoleInputFields,
});

export const HiringRoleUpdateManyWithWhereWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleScalarWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateManyMutationInput}),
});
export const HiringRoleUpdateManyWithWhereWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithWhereWithoutRoleInput>>('HiringRoleUpdateManyWithWhereWithoutRoleInput').implement({
  fields: HiringRoleUpdateManyWithWhereWithoutRoleInputFields,
});

export const MembershipUpsertWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  update: t.field({"required":true,"type":MembershipUpdateWithoutRoleInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutRoleInput}),
});
export const MembershipUpsertWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpsertWithWhereUniqueWithoutRoleInput>>('MembershipUpsertWithWhereUniqueWithoutRoleInput').implement({
  fields: MembershipUpsertWithWhereUniqueWithoutRoleInputFields,
});

export const MembershipUpdateWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  data: t.field({"required":true,"type":MembershipUpdateWithoutRoleInput}),
});
export const MembershipUpdateWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithWhereUniqueWithoutRoleInput>>('MembershipUpdateWithWhereUniqueWithoutRoleInput').implement({
  fields: MembershipUpdateWithWhereUniqueWithoutRoleInputFields,
});

export const MembershipUpdateManyWithWhereWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipScalarWhereInput}),
  data: t.field({"required":true,"type":MembershipUpdateManyMutationInput}),
});
export const MembershipUpdateManyWithWhereWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithWhereWithoutRoleInput>>('MembershipUpdateManyWithWhereWithoutRoleInput').implement({
  fields: MembershipUpdateManyWithWhereWithoutRoleInputFields,
});

export const StageVisibilityUpsertWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  update: t.field({"required":true,"type":StageVisibilityUpdateWithoutRoleInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutRoleInput}),
});
export const StageVisibilityUpsertWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpsertWithWhereUniqueWithoutRoleInput>>('StageVisibilityUpsertWithWhereUniqueWithoutRoleInput').implement({
  fields: StageVisibilityUpsertWithWhereUniqueWithoutRoleInputFields,
});

export const StageVisibilityUpdateWithWhereUniqueWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateWithoutRoleInput}),
});
export const StageVisibilityUpdateWithWhereUniqueWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithWhereUniqueWithoutRoleInput>>('StageVisibilityUpdateWithWhereUniqueWithoutRoleInput').implement({
  fields: StageVisibilityUpdateWithWhereUniqueWithoutRoleInputFields,
});

export const StageVisibilityUpdateManyWithWhereWithoutRoleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityScalarWhereInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateManyMutationInput}),
});
export const StageVisibilityUpdateManyWithWhereWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithWhereWithoutRoleInput>>('StageVisibilityUpdateManyWithWhereWithoutRoleInput').implement({
  fields: StageVisibilityUpdateManyWithWhereWithoutRoleInputFields,
});

export const RoleCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutRoleInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutRoleInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutRoleInput}),
});
export const RoleCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateWithoutCompanyInput>>('RoleCreateWithoutCompanyInput').implement({
  fields: RoleCreateWithoutCompanyInputFields,
});

export const RoleCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutCompanyInput}),
});
export const RoleCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateOrConnectWithoutCompanyInput>>('RoleCreateOrConnectWithoutCompanyInput').implement({
  fields: RoleCreateOrConnectWithoutCompanyInputFields,
});

export const RoleCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[RoleCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const RoleCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateManyCompanyInputEnvelope>>('RoleCreateManyCompanyInputEnvelope').implement({
  fields: RoleCreateManyCompanyInputEnvelopeFields,
});

export const SubscriptionDataCreateWithoutCompanyInputFields = (t: any) => ({
  active: t.boolean({"required":true}),
  currentPeriodStart: t.field({"required":true,"type":DateTime}),
  currentPeriodEnd: t.field({"required":true,"type":DateTime}),
  status: t.string({"required":true}),
});
export const SubscriptionDataCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCreateWithoutCompanyInput>>('SubscriptionDataCreateWithoutCompanyInput').implement({
  fields: SubscriptionDataCreateWithoutCompanyInputFields,
});

export const SubscriptionDataCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SubscriptionDataWhereUniqueInput}),
  create: t.field({"required":true,"type":SubscriptionDataCreateWithoutCompanyInput}),
});
export const SubscriptionDataCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataCreateOrConnectWithoutCompanyInput>>('SubscriptionDataCreateOrConnectWithoutCompanyInput').implement({
  fields: SubscriptionDataCreateOrConnectWithoutCompanyInputFields,
});

export const MeetingRoomCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.string({"required":true}),
  link: t.string({"required":true}),
});
export const MeetingRoomCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateWithoutCompanyInput>>('MeetingRoomCreateWithoutCompanyInput').implement({
  fields: MeetingRoomCreateWithoutCompanyInputFields,
});

export const MeetingRoomCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MeetingRoomWhereUniqueInput}),
  create: t.field({"required":true,"type":MeetingRoomCreateWithoutCompanyInput}),
});
export const MeetingRoomCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateOrConnectWithoutCompanyInput>>('MeetingRoomCreateOrConnectWithoutCompanyInput').implement({
  fields: MeetingRoomCreateOrConnectWithoutCompanyInputFields,
});

export const MeetingRoomCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MeetingRoomCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MeetingRoomCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateManyCompanyInputEnvelope>>('MeetingRoomCreateManyCompanyInputEnvelope').implement({
  fields: MeetingRoomCreateManyCompanyInputEnvelopeFields,
});

export const CompanyMetadataCreateWithoutCompanyInputFields = (t: any) => ({
  key: t.string({"required":true}),
  value: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  type: t.string({"required":false}),
});
export const CompanyMetadataCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateWithoutCompanyInput>>('CompanyMetadataCreateWithoutCompanyInput').implement({
  fields: CompanyMetadataCreateWithoutCompanyInputFields,
});

export const CompanyMetadataCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyMetadataWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyMetadataCreateWithoutCompanyInput}),
});
export const CompanyMetadataCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateOrConnectWithoutCompanyInput>>('CompanyMetadataCreateOrConnectWithoutCompanyInput').implement({
  fields: CompanyMetadataCreateOrConnectWithoutCompanyInputFields,
});

export const CompanyMetadataCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CompanyMetadataCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CompanyMetadataCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateManyCompanyInputEnvelope>>('CompanyMetadataCreateManyCompanyInputEnvelope').implement({
  fields: CompanyMetadataCreateManyCompanyInputEnvelopeFields,
});

export const EventScheduleCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput}),
});
export const EventScheduleCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateWithoutCompanyInput>>('EventScheduleCreateWithoutCompanyInput').implement({
  fields: EventScheduleCreateWithoutCompanyInputFields,
});

export const EventScheduleCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutCompanyInput}),
});
export const EventScheduleCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateOrConnectWithoutCompanyInput>>('EventScheduleCreateOrConnectWithoutCompanyInput').implement({
  fields: EventScheduleCreateOrConnectWithoutCompanyInputFields,
});

export const EventScheduleCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventScheduleCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventScheduleCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateManyCompanyInputEnvelope>>('EventScheduleCreateManyCompanyInputEnvelope').implement({
  fields: EventScheduleCreateManyCompanyInputEnvelopeFields,
});

export const EventCreateWithoutCompanyInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutCompanyInput>>('EventCreateWithoutCompanyInput').implement({
  fields: EventCreateWithoutCompanyInputFields,
});

export const EventCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCompanyInput}),
});
export const EventCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutCompanyInput>>('EventCreateOrConnectWithoutCompanyInput').implement({
  fields: EventCreateOrConnectWithoutCompanyInputFields,
});

export const EventCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateManyCompanyInputEnvelope>>('EventCreateManyCompanyInputEnvelope').implement({
  fields: EventCreateManyCompanyInputEnvelopeFields,
});

export const DepartmentCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutDepartmentInput}),
});
export const DepartmentCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateWithoutCompanyInput>>('DepartmentCreateWithoutCompanyInput').implement({
  fields: DepartmentCreateWithoutCompanyInputFields,
});

export const DepartmentCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DepartmentWhereUniqueInput}),
  create: t.field({"required":true,"type":DepartmentCreateWithoutCompanyInput}),
});
export const DepartmentCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateOrConnectWithoutCompanyInput>>('DepartmentCreateOrConnectWithoutCompanyInput').implement({
  fields: DepartmentCreateOrConnectWithoutCompanyInputFields,
});

export const DepartmentCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[DepartmentCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const DepartmentCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateManyCompanyInputEnvelope>>('DepartmentCreateManyCompanyInputEnvelope').implement({
  fields: DepartmentCreateManyCompanyInputEnvelopeFields,
});

export const DisqualifyReasonCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  action: t.field({"required":true,"type":Json}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutDisqualifyReasonInput}),
});
export const DisqualifyReasonCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateWithoutCompanyInput>>('DisqualifyReasonCreateWithoutCompanyInput').implement({
  fields: DisqualifyReasonCreateWithoutCompanyInputFields,
});

export const DisqualifyReasonCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DisqualifyReasonWhereUniqueInput}),
  create: t.field({"required":true,"type":DisqualifyReasonCreateWithoutCompanyInput}),
});
export const DisqualifyReasonCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateOrConnectWithoutCompanyInput>>('DisqualifyReasonCreateOrConnectWithoutCompanyInput').implement({
  fields: DisqualifyReasonCreateOrConnectWithoutCompanyInputFields,
});

export const DisqualifyReasonCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[DisqualifyReasonCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const DisqualifyReasonCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateManyCompanyInputEnvelope>>('DisqualifyReasonCreateManyCompanyInputEnvelope').implement({
  fields: DisqualifyReasonCreateManyCompanyInputEnvelopeFields,
});

export const TagSourceCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutTagInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateCreateNestedManyWithoutReferrerInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutTagInput}),
});
export const TagSourceCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateWithoutCompanyInput>>('TagSourceCreateWithoutCompanyInput').implement({
  fields: TagSourceCreateWithoutCompanyInputFields,
});

export const TagSourceCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCompanyInput}),
});
export const TagSourceCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateOrConnectWithoutCompanyInput>>('TagSourceCreateOrConnectWithoutCompanyInput').implement({
  fields: TagSourceCreateOrConnectWithoutCompanyInputFields,
});

export const TagSourceCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TagSourceCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TagSourceCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateManyCompanyInputEnvelope>>('TagSourceCreateManyCompanyInputEnvelope').implement({
  fields: TagSourceCreateManyCompanyInputEnvelopeFields,
});

export const AuditLogCreateWithoutCompanyInputFields = (t: any) => ({
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAuditLogsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutAuditLogsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAuditLogsInput}),
});
export const AuditLogCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateWithoutCompanyInput>>('AuditLogCreateWithoutCompanyInput').implement({
  fields: AuditLogCreateWithoutCompanyInputFields,
});

export const AuditLogCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutCompanyInput}),
});
export const AuditLogCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateOrConnectWithoutCompanyInput>>('AuditLogCreateOrConnectWithoutCompanyInput').implement({
  fields: AuditLogCreateOrConnectWithoutCompanyInputFields,
});

export const AuditLogCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AuditLogCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AuditLogCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyCompanyInputEnvelope>>('AuditLogCreateManyCompanyInputEnvelope').implement({
  fields: AuditLogCreateManyCompanyInputEnvelopeFields,
});

export const OfferCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutCompanyInput>>('OfferCreateWithoutCompanyInput').implement({
  fields: OfferCreateWithoutCompanyInputFields,
});

export const OfferCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutCompanyInput}),
});
export const OfferCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutCompanyInput>>('OfferCreateOrConnectWithoutCompanyInput').implement({
  fields: OfferCreateOrConnectWithoutCompanyInputFields,
});

export const OfferCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyCompanyInputEnvelope>>('OfferCreateManyCompanyInputEnvelope').implement({
  fields: OfferCreateManyCompanyInputEnvelopeFields,
});

export const TemplateCreateWithoutCompanyInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutCompanyInput>>('TemplateCreateWithoutCompanyInput').implement({
  fields: TemplateCreateWithoutCompanyInputFields,
});

export const TemplateCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutCompanyInput}),
});
export const TemplateCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutCompanyInput>>('TemplateCreateOrConnectWithoutCompanyInput').implement({
  fields: TemplateCreateOrConnectWithoutCompanyInputFields,
});

export const TemplateCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TemplateCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TemplateCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateManyCompanyInputEnvelope>>('TemplateCreateManyCompanyInputEnvelope').implement({
  fields: TemplateCreateManyCompanyInputEnvelopeFields,
});

export const TaskCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  taskMembers: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTaskInput}),
  Candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutTasksInput}),
});
export const TaskCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateWithoutCompanyInput>>('TaskCreateWithoutCompanyInput').implement({
  fields: TaskCreateWithoutCompanyInputFields,
});

export const TaskCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutCompanyInput}),
});
export const TaskCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateOrConnectWithoutCompanyInput>>('TaskCreateOrConnectWithoutCompanyInput').implement({
  fields: TaskCreateOrConnectWithoutCompanyInputFields,
});

export const TaskCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TaskCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TaskCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateManyCompanyInputEnvelope>>('TaskCreateManyCompanyInputEnvelope').implement({
  fields: TaskCreateManyCompanyInputEnvelopeFields,
});

export const UserCreateWithoutCompaniesOwnedInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":false}),
  email: t.string({"required":true}),
  emailVerified: t.field({"required":false,"type":DateTime}),
  image: t.string({"required":false}),
  password: t.string({"required":false}),
  phone: t.string({"required":false}),
  firstName: t.string({"required":false}),
  lastName: t.string({"required":false}),
  preferredLanguage: t.string({"required":false}),
  timeformat24: t.boolean({"required":false}),
  timezone: t.string({"required":false}),
  weekStartDate: t.string({"required":false}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.string({"required":false}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userRole: t.field({"required":false,"type":UserRoles}),
  photo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutUserProfilePhotoInput}),
  accounts: t.field({"required":false,"type":AccountCreateNestedManyWithoutUserInput}),
  sessions: t.field({"required":false,"type":SessionCreateNestedManyWithoutUserInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutUserInput}),
});
export const UserCreateWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateWithoutCompaniesOwnedInput>>('UserCreateWithoutCompaniesOwnedInput').implement({
  fields: UserCreateWithoutCompaniesOwnedInputFields,
});

export const UserCreateOrConnectWithoutCompaniesOwnedInputFields = (t: any) => ({
  where: t.field({"required":true,"type":UserWhereUniqueInput}),
  create: t.field({"required":true,"type":UserCreateWithoutCompaniesOwnedInput}),
});
export const UserCreateOrConnectWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserCreateOrConnectWithoutCompaniesOwnedInput>>('UserCreateOrConnectWithoutCompaniesOwnedInput').implement({
  fields: UserCreateOrConnectWithoutCompaniesOwnedInputFields,
});

export const HiringRoleCreateWithoutCompanyInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutCompanyInput>>('HiringRoleCreateWithoutCompanyInput').implement({
  fields: HiringRoleCreateWithoutCompanyInputFields,
});

export const HiringRoleCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutCompanyInput}),
});
export const HiringRoleCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutCompanyInput>>('HiringRoleCreateOrConnectWithoutCompanyInput').implement({
  fields: HiringRoleCreateOrConnectWithoutCompanyInputFields,
});

export const HiringRoleCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[HiringRoleCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const HiringRoleCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyCompanyInputEnvelope>>('HiringRoleCreateManyCompanyInputEnvelope').implement({
  fields: HiringRoleCreateManyCompanyInputEnvelopeFields,
});

export const CandidateCreateWithoutCompanyInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutCompanyInput>>('CandidateCreateWithoutCompanyInput').implement({
  fields: CandidateCreateWithoutCompanyInputFields,
});

export const CandidateCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCompanyInput}),
});
export const CandidateCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutCompanyInput>>('CandidateCreateOrConnectWithoutCompanyInput').implement({
  fields: CandidateCreateOrConnectWithoutCompanyInputFields,
});

export const CandidateCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyCompanyInputEnvelope>>('CandidateCreateManyCompanyInputEnvelope').implement({
  fields: CandidateCreateManyCompanyInputEnvelopeFields,
});

export const TalentPoolCreateWithoutCompanyInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  files: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutTalentPoolInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutTalentPoolInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTalentPoolInput}),
});
export const TalentPoolCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateWithoutCompanyInput>>('TalentPoolCreateWithoutCompanyInput').implement({
  fields: TalentPoolCreateWithoutCompanyInputFields,
});

export const TalentPoolCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutCompanyInput}),
});
export const TalentPoolCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateOrConnectWithoutCompanyInput>>('TalentPoolCreateOrConnectWithoutCompanyInput').implement({
  fields: TalentPoolCreateOrConnectWithoutCompanyInputFields,
});

export const TalentPoolCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TalentPoolCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TalentPoolCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateManyCompanyInputEnvelope>>('TalentPoolCreateManyCompanyInputEnvelope').implement({
  fields: TalentPoolCreateManyCompanyInputEnvelopeFields,
});

export const CustomFieldCreateWithoutCompanyInputFields = (t: any) => ({
  type: t.string({"required":false}),
  key: t.string({"required":true}),
  defaultValue: t.string({"required":false}),
  settings: t.field({"required":false,"type":Json}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCustomFieldInput}),
});
export const CustomFieldCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateWithoutCompanyInput>>('CustomFieldCreateWithoutCompanyInput').implement({
  fields: CustomFieldCreateWithoutCompanyInputFields,
});

export const CustomFieldCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CustomFieldWhereUniqueInput}),
  create: t.field({"required":true,"type":CustomFieldCreateWithoutCompanyInput}),
});
export const CustomFieldCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateOrConnectWithoutCompanyInput>>('CustomFieldCreateOrConnectWithoutCompanyInput').implement({
  fields: CustomFieldCreateOrConnectWithoutCompanyInputFields,
});

export const CustomFieldCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CustomFieldCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CustomFieldCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateManyCompanyInputEnvelope>>('CustomFieldCreateManyCompanyInputEnvelope').implement({
  fields: CustomFieldCreateManyCompanyInputEnvelopeFields,
});

export const AttachmentCreateWithoutCompanyLogoInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutCompanyLogoInput>>('AttachmentCreateWithoutCompanyLogoInput').implement({
  fields: AttachmentCreateWithoutCompanyLogoInputFields,
});

export const AttachmentCreateOrConnectWithoutCompanyLogoInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCompanyLogoInput}),
});
export const AttachmentCreateOrConnectWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutCompanyLogoInput>>('AttachmentCreateOrConnectWithoutCompanyLogoInput').implement({
  fields: AttachmentCreateOrConnectWithoutCompanyLogoInputFields,
});

export const AttachmentCreateWithoutCompanyInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
});
export const AttachmentCreateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutCompanyInput>>('AttachmentCreateWithoutCompanyInput').implement({
  fields: AttachmentCreateWithoutCompanyInputFields,
});

export const AttachmentCreateOrConnectWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCompanyInput}),
});
export const AttachmentCreateOrConnectWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutCompanyInput>>('AttachmentCreateOrConnectWithoutCompanyInput').implement({
  fields: AttachmentCreateOrConnectWithoutCompanyInputFields,
});

export const AttachmentCreateManyCompanyInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AttachmentCreateManyCompanyInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AttachmentCreateManyCompanyInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateManyCompanyInputEnvelope>>('AttachmentCreateManyCompanyInputEnvelope').implement({
  fields: AttachmentCreateManyCompanyInputEnvelopeFields,
});

export const RoleUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  update: t.field({"required":true,"type":RoleUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutCompanyInput}),
});
export const RoleUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpsertWithWhereUniqueWithoutCompanyInput>>('RoleUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: RoleUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const RoleUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  data: t.field({"required":true,"type":RoleUpdateWithoutCompanyInput}),
});
export const RoleUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateWithWhereUniqueWithoutCompanyInput>>('RoleUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: RoleUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const RoleUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleScalarWhereInput}),
  data: t.field({"required":true,"type":RoleUpdateManyMutationInput}),
});
export const RoleUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateManyWithWhereWithoutCompanyInput>>('RoleUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: RoleUpdateManyWithWhereWithoutCompanyInputFields,
});

export const RoleScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[RoleScalarWhereInput]}),
  OR: t.field({"required":false,"type":[RoleScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[RoleScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  abilities: t.field({"required":false,"type":StringNullableListFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const RoleScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleScalarWhereInput>>('RoleScalarWhereInput').implement({
  fields: RoleScalarWhereInputFields,
});

export const SubscriptionDataUpsertWithoutCompanyInputFields = (t: any) => ({
  update: t.field({"required":true,"type":SubscriptionDataUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":SubscriptionDataCreateWithoutCompanyInput}),
  where: t.field({"required":false,"type":SubscriptionDataWhereInput}),
});
export const SubscriptionDataUpsertWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpsertWithoutCompanyInput>>('SubscriptionDataUpsertWithoutCompanyInput').implement({
  fields: SubscriptionDataUpsertWithoutCompanyInputFields,
});

export const SubscriptionDataUpdateToOneWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":false,"type":SubscriptionDataWhereInput}),
  data: t.field({"required":true,"type":SubscriptionDataUpdateWithoutCompanyInput}),
});
export const SubscriptionDataUpdateToOneWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpdateToOneWithWhereWithoutCompanyInput>>('SubscriptionDataUpdateToOneWithWhereWithoutCompanyInput').implement({
  fields: SubscriptionDataUpdateToOneWithWhereWithoutCompanyInputFields,
});

export const SubscriptionDataUpdateWithoutCompanyInputFields = (t: any) => ({
  active: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  currentPeriodStart: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  currentPeriodEnd: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const SubscriptionDataUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SubscriptionDataUpdateWithoutCompanyInput>>('SubscriptionDataUpdateWithoutCompanyInput').implement({
  fields: SubscriptionDataUpdateWithoutCompanyInputFields,
});

export const MeetingRoomUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MeetingRoomWhereUniqueInput}),
  update: t.field({"required":true,"type":MeetingRoomUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":MeetingRoomCreateWithoutCompanyInput}),
});
export const MeetingRoomUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpsertWithWhereUniqueWithoutCompanyInput>>('MeetingRoomUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: MeetingRoomUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const MeetingRoomUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MeetingRoomWhereUniqueInput}),
  data: t.field({"required":true,"type":MeetingRoomUpdateWithoutCompanyInput}),
});
export const MeetingRoomUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateWithWhereUniqueWithoutCompanyInput>>('MeetingRoomUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: MeetingRoomUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const MeetingRoomUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MeetingRoomScalarWhereInput}),
  data: t.field({"required":true,"type":MeetingRoomUpdateManyMutationInput}),
});
export const MeetingRoomUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateManyWithWhereWithoutCompanyInput>>('MeetingRoomUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: MeetingRoomUpdateManyWithWhereWithoutCompanyInputFields,
});

export const MeetingRoomScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MeetingRoomScalarWhereInput]}),
  OR: t.field({"required":false,"type":[MeetingRoomScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[MeetingRoomScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const MeetingRoomScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomScalarWhereInput>>('MeetingRoomScalarWhereInput').implement({
  fields: MeetingRoomScalarWhereInputFields,
});

export const CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyMetadataWhereUniqueInput}),
  update: t.field({"required":true,"type":CompanyMetadataUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":CompanyMetadataCreateWithoutCompanyInput}),
});
export const CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInput>>('CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: CompanyMetadataUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyMetadataWhereUniqueInput}),
  data: t.field({"required":true,"type":CompanyMetadataUpdateWithoutCompanyInput}),
});
export const CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInput>>('CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: CompanyMetadataUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const CompanyMetadataUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyMetadataScalarWhereInput}),
  data: t.field({"required":true,"type":CompanyMetadataUpdateManyMutationInput}),
});
export const CompanyMetadataUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateManyWithWhereWithoutCompanyInput>>('CompanyMetadataUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: CompanyMetadataUpdateManyWithWhereWithoutCompanyInputFields,
});

export const CompanyMetadataScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CompanyMetadataScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CompanyMetadataScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CompanyMetadataScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  value: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  type: t.field({"required":false,"type":StringFilter}),
});
export const CompanyMetadataScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataScalarWhereInput>>('CompanyMetadataScalarWhereInput').implement({
  fields: CompanyMetadataScalarWhereInputFields,
});

export const EventScheduleUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleWhereUniqueInput}),
  update: t.field({"required":true,"type":EventScheduleUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutCompanyInput}),
});
export const EventScheduleUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpsertWithWhereUniqueWithoutCompanyInput>>('EventScheduleUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: EventScheduleUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const EventScheduleUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleWhereUniqueInput}),
  data: t.field({"required":true,"type":EventScheduleUpdateWithoutCompanyInput}),
});
export const EventScheduleUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateWithWhereUniqueWithoutCompanyInput>>('EventScheduleUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: EventScheduleUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const EventScheduleUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleScalarWhereInput}),
  data: t.field({"required":true,"type":EventScheduleUpdateManyMutationInput}),
});
export const EventScheduleUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateManyWithWhereWithoutCompanyInput>>('EventScheduleUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: EventScheduleUpdateManyWithWhereWithoutCompanyInputFields,
});

export const EventScheduleScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  dateRange: t.field({"required":false,"type":IntFilter}),
  expiresAfter: t.field({"required":false,"type":IntFilter}),
  inviteAll: t.field({"required":false,"type":BoolFilter}),
  bufferTime: t.field({"required":false,"type":IntFilter}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFilter}),
  meetingLimit: t.field({"required":false,"type":IntFilter}),
  duration: t.field({"required":false,"type":IntFilter}),
  Interval: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  timezone: t.field({"required":false,"type":StringFilter}),
  location: t.field({"required":false,"type":StringFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  privateNote: t.field({"required":false,"type":StringFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const EventScheduleScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleScalarWhereInput>>('EventScheduleScalarWhereInput').implement({
  fields: EventScheduleScalarWhereInputFields,
});

export const EventUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  update: t.field({"required":true,"type":EventUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCompanyInput}),
});
export const EventUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithWhereUniqueWithoutCompanyInput>>('EventUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: EventUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const EventUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutCompanyInput}),
});
export const EventUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithWhereUniqueWithoutCompanyInput>>('EventUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: EventUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const EventUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScalarWhereInput}),
  data: t.field({"required":true,"type":EventUpdateManyMutationInput}),
});
export const EventUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithWhereWithoutCompanyInput>>('EventUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: EventUpdateManyWithWhereWithoutCompanyInputFields,
});

export const DepartmentUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DepartmentWhereUniqueInput}),
  update: t.field({"required":true,"type":DepartmentUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":DepartmentCreateWithoutCompanyInput}),
});
export const DepartmentUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpsertWithWhereUniqueWithoutCompanyInput>>('DepartmentUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: DepartmentUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const DepartmentUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DepartmentWhereUniqueInput}),
  data: t.field({"required":true,"type":DepartmentUpdateWithoutCompanyInput}),
});
export const DepartmentUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateWithWhereUniqueWithoutCompanyInput>>('DepartmentUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: DepartmentUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const DepartmentUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DepartmentScalarWhereInput}),
  data: t.field({"required":true,"type":DepartmentUpdateManyMutationInput}),
});
export const DepartmentUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateManyWithWhereWithoutCompanyInput>>('DepartmentUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: DepartmentUpdateManyWithWhereWithoutCompanyInputFields,
});

export const DepartmentScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DepartmentScalarWhereInput]}),
  OR: t.field({"required":false,"type":[DepartmentScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[DepartmentScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const DepartmentScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentScalarWhereInput>>('DepartmentScalarWhereInput').implement({
  fields: DepartmentScalarWhereInputFields,
});

export const DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DisqualifyReasonWhereUniqueInput}),
  update: t.field({"required":true,"type":DisqualifyReasonUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":DisqualifyReasonCreateWithoutCompanyInput}),
});
export const DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInput>>('DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: DisqualifyReasonUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DisqualifyReasonWhereUniqueInput}),
  data: t.field({"required":true,"type":DisqualifyReasonUpdateWithoutCompanyInput}),
});
export const DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInput>>('DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: DisqualifyReasonUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const DisqualifyReasonUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DisqualifyReasonScalarWhereInput}),
  data: t.field({"required":true,"type":DisqualifyReasonUpdateManyMutationInput}),
});
export const DisqualifyReasonUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateManyWithWhereWithoutCompanyInput>>('DisqualifyReasonUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: DisqualifyReasonUpdateManyWithWhereWithoutCompanyInputFields,
});

export const DisqualifyReasonScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[DisqualifyReasonScalarWhereInput]}),
  OR: t.field({"required":false,"type":[DisqualifyReasonScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[DisqualifyReasonScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  action: t.field({"required":false,"type":JsonFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const DisqualifyReasonScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonScalarWhereInput>>('DisqualifyReasonScalarWhereInput').implement({
  fields: DisqualifyReasonScalarWhereInputFields,
});

export const TagSourceUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  update: t.field({"required":true,"type":TagSourceUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCompanyInput}),
});
export const TagSourceUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpsertWithWhereUniqueWithoutCompanyInput>>('TagSourceUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: TagSourceUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const TagSourceUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  data: t.field({"required":true,"type":TagSourceUpdateWithoutCompanyInput}),
});
export const TagSourceUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateWithWhereUniqueWithoutCompanyInput>>('TagSourceUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: TagSourceUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const TagSourceUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceScalarWhereInput}),
  data: t.field({"required":true,"type":TagSourceUpdateManyMutationInput}),
});
export const TagSourceUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateManyWithWhereWithoutCompanyInput>>('TagSourceUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: TagSourceUpdateManyWithWhereWithoutCompanyInputFields,
});

export const TagSourceScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TagSourceScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TagSourceScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TagSourceScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const TagSourceScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceScalarWhereInput>>('TagSourceScalarWhereInput').implement({
  fields: TagSourceScalarWhereInputFields,
});

export const AuditLogUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  update: t.field({"required":true,"type":AuditLogUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutCompanyInput}),
});
export const AuditLogUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpsertWithWhereUniqueWithoutCompanyInput>>('AuditLogUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: AuditLogUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const AuditLogUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  data: t.field({"required":true,"type":AuditLogUpdateWithoutCompanyInput}),
});
export const AuditLogUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithWhereUniqueWithoutCompanyInput>>('AuditLogUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: AuditLogUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const AuditLogUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogScalarWhereInput}),
  data: t.field({"required":true,"type":AuditLogUpdateManyMutationInput}),
});
export const AuditLogUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithWhereWithoutCompanyInput>>('AuditLogUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: AuditLogUpdateManyWithWhereWithoutCompanyInputFields,
});

export const OfferUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutCompanyInput}),
});
export const OfferUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithWhereUniqueWithoutCompanyInput>>('OfferUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: OfferUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const OfferUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutCompanyInput}),
});
export const OfferUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithWhereUniqueWithoutCompanyInput>>('OfferUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: OfferUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const OfferUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferScalarWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateManyMutationInput}),
});
export const OfferUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithWhereWithoutCompanyInput>>('OfferUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: OfferUpdateManyWithWhereWithoutCompanyInputFields,
});

export const OfferScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferScalarWhereInput]}),
  OR: t.field({"required":false,"type":[OfferScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  departmentId: t.field({"required":false,"type":IntNullableFilter}),
  recruiterId: t.field({"required":false,"type":IntNullableFilter}),
  hiringManagerId: t.field({"required":false,"type":IntNullableFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  requirements: t.field({"required":false,"type":StringNullableFilter}),
  locationCountry: t.field({"required":false,"type":StringNullableFilter}),
  locationState: t.field({"required":false,"type":StringNullableFilter}),
  locationCity: t.field({"required":false,"type":StringNullableFilter}),
  locationStreet: t.field({"required":false,"type":StringNullableFilter}),
  zipcode: t.field({"required":false,"type":StringNullableFilter}),
  remote: t.field({"required":false,"type":BoolFilter}),
  jobType: t.field({"required":false,"type":StringNullableFilter}),
  jobCategory: t.field({"required":false,"type":StringNullableFilter}),
  jobReqEducation: t.field({"required":false,"type":StringNullableFilter}),
  jobReqExperience: t.field({"required":false,"type":StringNullableFilter}),
  jobHoursMin: t.field({"required":false,"type":IntNullableFilter}),
  jobHoursMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMin: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryMax: t.field({"required":false,"type":IntNullableFilter}),
  jobSalaryPeriod: t.field({"required":false,"type":StringNullableFilter}),
  jobSalaryCurrency: t.field({"required":false,"type":StringNullableFilter}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFilter}),
  screeningQuestionsTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  pipelineTemplateId: t.field({"required":false,"type":IntNullableFilter}),
  autoConfirmationEmailId: t.field({"required":false,"type":IntNullableFilter}),
  isPublished: t.field({"required":false,"type":BoolFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const OfferScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferScalarWhereInput>>('OfferScalarWhereInput').implement({
  fields: OfferScalarWhereInputFields,
});

export const TemplateUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  update: t.field({"required":true,"type":TemplateUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutCompanyInput}),
});
export const TemplateUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithWhereUniqueWithoutCompanyInput>>('TemplateUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: TemplateUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const TemplateUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutCompanyInput}),
});
export const TemplateUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithWhereUniqueWithoutCompanyInput>>('TemplateUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: TemplateUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const TemplateUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateScalarWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateManyMutationInput}),
});
export const TemplateUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateManyWithWhereWithoutCompanyInput>>('TemplateUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: TemplateUpdateManyWithWhereWithoutCompanyInputFields,
});

export const TemplateScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TemplateScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TemplateScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TemplateScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  isCompanyWide: t.field({"required":false,"type":BoolNullableFilter}),
  type: t.field({"required":false,"type":EnumTemplateTypesFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  category: t.field({"required":false,"type":StringNullableFilter}),
});
export const TemplateScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateScalarWhereInput>>('TemplateScalarWhereInput').implement({
  fields: TemplateScalarWhereInputFields,
});

export const TaskUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  update: t.field({"required":true,"type":TaskUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutCompanyInput}),
});
export const TaskUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpsertWithWhereUniqueWithoutCompanyInput>>('TaskUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: TaskUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const TaskUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  data: t.field({"required":true,"type":TaskUpdateWithoutCompanyInput}),
});
export const TaskUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateWithWhereUniqueWithoutCompanyInput>>('TaskUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: TaskUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const TaskUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskScalarWhereInput}),
  data: t.field({"required":true,"type":TaskUpdateManyMutationInput}),
});
export const TaskUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateManyWithWhereWithoutCompanyInput>>('TaskUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: TaskUpdateManyWithWhereWithoutCompanyInputFields,
});

export const TaskScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TaskScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TaskScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TaskScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  status: t.field({"required":false,"type":StringFilter}),
  dueDate: t.field({"required":false,"type":DateTimeFilter}),
  note: t.field({"required":false,"type":StringFilter}),
  candidateId: t.field({"required":false,"type":IntNullableFilter}),
});
export const TaskScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskScalarWhereInput>>('TaskScalarWhereInput').implement({
  fields: TaskScalarWhereInputFields,
});

export const UserUpsertWithoutCompaniesOwnedInputFields = (t: any) => ({
  update: t.field({"required":true,"type":UserUpdateWithoutCompaniesOwnedInput}),
  create: t.field({"required":true,"type":UserCreateWithoutCompaniesOwnedInput}),
  where: t.field({"required":false,"type":UserWhereInput}),
});
export const UserUpsertWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpsertWithoutCompaniesOwnedInput>>('UserUpsertWithoutCompaniesOwnedInput').implement({
  fields: UserUpsertWithoutCompaniesOwnedInputFields,
});

export const UserUpdateToOneWithWhereWithoutCompaniesOwnedInputFields = (t: any) => ({
  where: t.field({"required":false,"type":UserWhereInput}),
  data: t.field({"required":true,"type":UserUpdateWithoutCompaniesOwnedInput}),
});
export const UserUpdateToOneWithWhereWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateToOneWithWhereWithoutCompaniesOwnedInput>>('UserUpdateToOneWithWhereWithoutCompaniesOwnedInput').implement({
  fields: UserUpdateToOneWithWhereWithoutCompaniesOwnedInputFields,
});

export const UserUpdateWithoutCompaniesOwnedInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  emailVerified: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  image: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  password: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  firstName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  preferredLanguage: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  timeformat24: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  weekStartDate: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  featureDiscovery: t.stringList({"required":false}),
  emailProviders: t.stringList({"required":false}),
  theme: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  notifications: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userRole: t.field({"required":false,"type":EnumUserRolesFieldUpdateOperationsInput}),
  photo: t.field({"required":false,"type":AttachmentUpdateOneWithoutUserProfilePhotoNestedInput}),
  accounts: t.field({"required":false,"type":AccountUpdateManyWithoutUserNestedInput}),
  sessions: t.field({"required":false,"type":SessionUpdateManyWithoutUserNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutUserNestedInput}),
});
export const UserUpdateWithoutCompaniesOwnedInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.UserUpdateWithoutCompaniesOwnedInput>>('UserUpdateWithoutCompaniesOwnedInput').implement({
  fields: UserUpdateWithoutCompaniesOwnedInputFields,
});

export const HiringRoleUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutCompanyInput}),
});
export const HiringRoleUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithWhereUniqueWithoutCompanyInput>>('HiringRoleUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: HiringRoleUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const HiringRoleUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutCompanyInput}),
});
export const HiringRoleUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithWhereUniqueWithoutCompanyInput>>('HiringRoleUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: HiringRoleUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const HiringRoleUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleScalarWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateManyMutationInput}),
});
export const HiringRoleUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithWhereWithoutCompanyInput>>('HiringRoleUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: HiringRoleUpdateManyWithWhereWithoutCompanyInputFields,
});

export const CandidateUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCompanyInput}),
});
export const CandidateUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithWhereUniqueWithoutCompanyInput>>('CandidateUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: CandidateUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const CandidateUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutCompanyInput}),
});
export const CandidateUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithWhereUniqueWithoutCompanyInput>>('CandidateUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: CandidateUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const CandidateUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateManyMutationInput}),
});
export const CandidateUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithWhereWithoutCompanyInput>>('CandidateUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: CandidateUpdateManyWithWhereWithoutCompanyInputFields,
});

export const TalentPoolUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  update: t.field({"required":true,"type":TalentPoolUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutCompanyInput}),
});
export const TalentPoolUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpsertWithWhereUniqueWithoutCompanyInput>>('TalentPoolUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: TalentPoolUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const TalentPoolUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  data: t.field({"required":true,"type":TalentPoolUpdateWithoutCompanyInput}),
});
export const TalentPoolUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateWithWhereUniqueWithoutCompanyInput>>('TalentPoolUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: TalentPoolUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const TalentPoolUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolScalarWhereInput}),
  data: t.field({"required":true,"type":TalentPoolUpdateManyMutationInput}),
});
export const TalentPoolUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateManyWithWhereWithoutCompanyInput>>('TalentPoolUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: TalentPoolUpdateManyWithWhereWithoutCompanyInputFields,
});

export const TalentPoolScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  description: t.field({"required":false,"type":StringNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
  createdAt: t.field({"required":false,"type":DateTimeFilter}),
  updatedAt: t.field({"required":false,"type":DateTimeFilter}),
});
export const TalentPoolScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolScalarWhereInput>>('TalentPoolScalarWhereInput').implement({
  fields: TalentPoolScalarWhereInputFields,
});

export const CustomFieldUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CustomFieldWhereUniqueInput}),
  update: t.field({"required":true,"type":CustomFieldUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":CustomFieldCreateWithoutCompanyInput}),
});
export const CustomFieldUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpsertWithWhereUniqueWithoutCompanyInput>>('CustomFieldUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: CustomFieldUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const CustomFieldUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CustomFieldWhereUniqueInput}),
  data: t.field({"required":true,"type":CustomFieldUpdateWithoutCompanyInput}),
});
export const CustomFieldUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateWithWhereUniqueWithoutCompanyInput>>('CustomFieldUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: CustomFieldUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const CustomFieldUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CustomFieldScalarWhereInput}),
  data: t.field({"required":true,"type":CustomFieldUpdateManyMutationInput}),
});
export const CustomFieldUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateManyWithWhereWithoutCompanyInput>>('CustomFieldUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: CustomFieldUpdateManyWithWhereWithoutCompanyInputFields,
});

export const CustomFieldScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CustomFieldScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CustomFieldScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CustomFieldScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  type: t.field({"required":false,"type":StringFilter}),
  key: t.field({"required":false,"type":StringFilter}),
  defaultValue: t.field({"required":false,"type":StringNullableFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  companyId: t.field({"required":false,"type":StringFilter}),
});
export const CustomFieldScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldScalarWhereInput>>('CustomFieldScalarWhereInput').implement({
  fields: CustomFieldScalarWhereInputFields,
});

export const AttachmentUpsertWithoutCompanyLogoInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutCompanyLogoInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCompanyLogoInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutCompanyLogoInput>>('AttachmentUpsertWithoutCompanyLogoInput').implement({
  fields: AttachmentUpsertWithoutCompanyLogoInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutCompanyLogoInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutCompanyLogoInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutCompanyLogoInput>>('AttachmentUpdateToOneWithWhereWithoutCompanyLogoInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutCompanyLogoInputFields,
});

export const AttachmentUpdateWithoutCompanyLogoInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutCompanyLogoInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutCompanyLogoInput>>('AttachmentUpdateWithoutCompanyLogoInput').implement({
  fields: AttachmentUpdateWithoutCompanyLogoInputFields,
});

export const AttachmentUpsertWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  update: t.field({"required":true,"type":AttachmentUpdateWithoutCompanyInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCompanyInput}),
});
export const AttachmentUpsertWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithWhereUniqueWithoutCompanyInput>>('AttachmentUpsertWithWhereUniqueWithoutCompanyInput').implement({
  fields: AttachmentUpsertWithWhereUniqueWithoutCompanyInputFields,
});

export const AttachmentUpdateWithWhereUniqueWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutCompanyInput}),
});
export const AttachmentUpdateWithWhereUniqueWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithWhereUniqueWithoutCompanyInput>>('AttachmentUpdateWithWhereUniqueWithoutCompanyInput').implement({
  fields: AttachmentUpdateWithWhereUniqueWithoutCompanyInputFields,
});

export const AttachmentUpdateManyWithWhereWithoutCompanyInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentScalarWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateManyMutationInput}),
});
export const AttachmentUpdateManyWithWhereWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateManyWithWhereWithoutCompanyInput>>('AttachmentUpdateManyWithWhereWithoutCompanyInput').implement({
  fields: AttachmentUpdateManyWithWhereWithoutCompanyInputFields,
});

export const CompanyCreateWithoutSubscriptionInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutSubscriptionInput>>('CompanyCreateWithoutSubscriptionInput').implement({
  fields: CompanyCreateWithoutSubscriptionInputFields,
});

export const CompanyCreateOrConnectWithoutSubscriptionInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutSubscriptionInput}),
});
export const CompanyCreateOrConnectWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutSubscriptionInput>>('CompanyCreateOrConnectWithoutSubscriptionInput').implement({
  fields: CompanyCreateOrConnectWithoutSubscriptionInputFields,
});

export const CompanyUpsertWithoutSubscriptionInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutSubscriptionInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutSubscriptionInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutSubscriptionInput>>('CompanyUpsertWithoutSubscriptionInput').implement({
  fields: CompanyUpsertWithoutSubscriptionInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutSubscriptionInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutSubscriptionInput}),
});
export const CompanyUpdateToOneWithWhereWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutSubscriptionInput>>('CompanyUpdateToOneWithWhereWithoutSubscriptionInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutSubscriptionInputFields,
});

export const CompanyUpdateWithoutSubscriptionInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutSubscriptionInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutSubscriptionInput>>('CompanyUpdateWithoutSubscriptionInput').implement({
  fields: CompanyUpdateWithoutSubscriptionInputFields,
});

export const CompanyCreateWithoutMetadataInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutMetadataInput>>('CompanyCreateWithoutMetadataInput').implement({
  fields: CompanyCreateWithoutMetadataInputFields,
});

export const CompanyCreateOrConnectWithoutMetadataInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutMetadataInput}),
});
export const CompanyCreateOrConnectWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutMetadataInput>>('CompanyCreateOrConnectWithoutMetadataInput').implement({
  fields: CompanyCreateOrConnectWithoutMetadataInputFields,
});

export const CompanyUpsertWithoutMetadataInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutMetadataInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutMetadataInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutMetadataInput>>('CompanyUpsertWithoutMetadataInput').implement({
  fields: CompanyUpsertWithoutMetadataInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutMetadataInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutMetadataInput}),
});
export const CompanyUpdateToOneWithWhereWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutMetadataInput>>('CompanyUpdateToOneWithWhereWithoutMetadataInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutMetadataInputFields,
});

export const CompanyUpdateWithoutMetadataInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutMetadataInput>>('CompanyUpdateWithoutMetadataInput').implement({
  fields: CompanyUpdateWithoutMetadataInputFields,
});

export const CompanyCreateWithoutDepartmentsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutDepartmentsInput>>('CompanyCreateWithoutDepartmentsInput').implement({
  fields: CompanyCreateWithoutDepartmentsInputFields,
});

export const CompanyCreateOrConnectWithoutDepartmentsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutDepartmentsInput}),
});
export const CompanyCreateOrConnectWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutDepartmentsInput>>('CompanyCreateOrConnectWithoutDepartmentsInput').implement({
  fields: CompanyCreateOrConnectWithoutDepartmentsInputFields,
});

export const OfferCreateWithoutDepartmentInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutDepartmentInput>>('OfferCreateWithoutDepartmentInput').implement({
  fields: OfferCreateWithoutDepartmentInputFields,
});

export const OfferCreateOrConnectWithoutDepartmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutDepartmentInput}),
});
export const OfferCreateOrConnectWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutDepartmentInput>>('OfferCreateOrConnectWithoutDepartmentInput').implement({
  fields: OfferCreateOrConnectWithoutDepartmentInputFields,
});

export const OfferCreateManyDepartmentInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferCreateManyDepartmentInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferCreateManyDepartmentInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyDepartmentInputEnvelope>>('OfferCreateManyDepartmentInputEnvelope').implement({
  fields: OfferCreateManyDepartmentInputEnvelopeFields,
});

export const CompanyUpsertWithoutDepartmentsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutDepartmentsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutDepartmentsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutDepartmentsInput>>('CompanyUpsertWithoutDepartmentsInput').implement({
  fields: CompanyUpsertWithoutDepartmentsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutDepartmentsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutDepartmentsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutDepartmentsInput>>('CompanyUpdateToOneWithWhereWithoutDepartmentsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutDepartmentsInputFields,
});

export const CompanyUpdateWithoutDepartmentsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutDepartmentsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutDepartmentsInput>>('CompanyUpdateWithoutDepartmentsInput').implement({
  fields: CompanyUpdateWithoutDepartmentsInputFields,
});

export const OfferUpsertWithWhereUniqueWithoutDepartmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferUpdateWithoutDepartmentInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutDepartmentInput}),
});
export const OfferUpsertWithWhereUniqueWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithWhereUniqueWithoutDepartmentInput>>('OfferUpsertWithWhereUniqueWithoutDepartmentInput').implement({
  fields: OfferUpsertWithWhereUniqueWithoutDepartmentInputFields,
});

export const OfferUpdateWithWhereUniqueWithoutDepartmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutDepartmentInput}),
});
export const OfferUpdateWithWhereUniqueWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithWhereUniqueWithoutDepartmentInput>>('OfferUpdateWithWhereUniqueWithoutDepartmentInput').implement({
  fields: OfferUpdateWithWhereUniqueWithoutDepartmentInputFields,
});

export const OfferUpdateManyWithWhereWithoutDepartmentInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferScalarWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateManyMutationInput}),
});
export const OfferUpdateManyWithWhereWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithWhereWithoutDepartmentInput>>('OfferUpdateManyWithWhereWithoutDepartmentInput').implement({
  fields: OfferUpdateManyWithWhereWithoutDepartmentInputFields,
});

export const CompanyCreateWithoutDisqualifyReasonsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutDisqualifyReasonsInput>>('CompanyCreateWithoutDisqualifyReasonsInput').implement({
  fields: CompanyCreateWithoutDisqualifyReasonsInputFields,
});

export const CompanyCreateOrConnectWithoutDisqualifyReasonsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutDisqualifyReasonsInput}),
});
export const CompanyCreateOrConnectWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutDisqualifyReasonsInput>>('CompanyCreateOrConnectWithoutDisqualifyReasonsInput').implement({
  fields: CompanyCreateOrConnectWithoutDisqualifyReasonsInputFields,
});

export const MatchCreateWithoutDisqualifyReasonInputFields = (t: any) => ({
  isHired: t.boolean({"required":false}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMatchesInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutOffersInput}),
  stage: t.field({"required":false,"type":StageCreateNestedOneWithoutMatchesInput}),
});
export const MatchCreateWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateWithoutDisqualifyReasonInput>>('MatchCreateWithoutDisqualifyReasonInput').implement({
  fields: MatchCreateWithoutDisqualifyReasonInputFields,
});

export const MatchCreateOrConnectWithoutDisqualifyReasonInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutDisqualifyReasonInput}),
});
export const MatchCreateOrConnectWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateOrConnectWithoutDisqualifyReasonInput>>('MatchCreateOrConnectWithoutDisqualifyReasonInput').implement({
  fields: MatchCreateOrConnectWithoutDisqualifyReasonInputFields,
});

export const MatchCreateManyDisqualifyReasonInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MatchCreateManyDisqualifyReasonInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MatchCreateManyDisqualifyReasonInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyDisqualifyReasonInputEnvelope>>('MatchCreateManyDisqualifyReasonInputEnvelope').implement({
  fields: MatchCreateManyDisqualifyReasonInputEnvelopeFields,
});

export const CompanyUpsertWithoutDisqualifyReasonsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutDisqualifyReasonsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutDisqualifyReasonsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutDisqualifyReasonsInput>>('CompanyUpsertWithoutDisqualifyReasonsInput').implement({
  fields: CompanyUpsertWithoutDisqualifyReasonsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutDisqualifyReasonsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInput>>('CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutDisqualifyReasonsInputFields,
});

export const CompanyUpdateWithoutDisqualifyReasonsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutDisqualifyReasonsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutDisqualifyReasonsInput>>('CompanyUpdateWithoutDisqualifyReasonsInput').implement({
  fields: CompanyUpdateWithoutDisqualifyReasonsInputFields,
});

export const MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  update: t.field({"required":true,"type":MatchUpdateWithoutDisqualifyReasonInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutDisqualifyReasonInput}),
});
export const MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInput>>('MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInput').implement({
  fields: MatchUpsertWithWhereUniqueWithoutDisqualifyReasonInputFields,
});

export const MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  data: t.field({"required":true,"type":MatchUpdateWithoutDisqualifyReasonInput}),
});
export const MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInput>>('MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInput').implement({
  fields: MatchUpdateWithWhereUniqueWithoutDisqualifyReasonInputFields,
});

export const MatchUpdateManyWithWhereWithoutDisqualifyReasonInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchScalarWhereInput}),
  data: t.field({"required":true,"type":MatchUpdateManyMutationInput}),
});
export const MatchUpdateManyWithWhereWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithWhereWithoutDisqualifyReasonInput>>('MatchUpdateManyWithWhereWithoutDisqualifyReasonInput').implement({
  fields: MatchUpdateManyWithWhereWithoutDisqualifyReasonInputFields,
});

export const MatchScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[MatchScalarWhereInput]}),
  OR: t.field({"required":false,"type":[MatchScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[MatchScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  offerId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  stageId: t.field({"required":false,"type":IntNullableFilter}),
  isHired: t.field({"required":false,"type":BoolFilter}),
  disqualifyReasonId: t.field({"required":false,"type":IntNullableFilter}),
});
export const MatchScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchScalarWhereInput>>('MatchScalarWhereInput').implement({
  fields: MatchScalarWhereInputFields,
});

export const CompanyCreateWithoutTagSourcesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutTagSourcesInput>>('CompanyCreateWithoutTagSourcesInput').implement({
  fields: CompanyCreateWithoutTagSourcesInputFields,
});

export const CompanyCreateOrConnectWithoutTagSourcesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTagSourcesInput}),
});
export const CompanyCreateOrConnectWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutTagSourcesInput>>('CompanyCreateOrConnectWithoutTagSourcesInput').implement({
  fields: CompanyCreateOrConnectWithoutTagSourcesInputFields,
});

export const OfferTagCreateWithoutTagInputFields = (t: any) => ({
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutOfferTagsInput}),
});
export const OfferTagCreateWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateWithoutTagInput>>('OfferTagCreateWithoutTagInput').implement({
  fields: OfferTagCreateWithoutTagInputFields,
});

export const OfferTagCreateOrConnectWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferTagCreateWithoutTagInput}),
});
export const OfferTagCreateOrConnectWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateOrConnectWithoutTagInput>>('OfferTagCreateOrConnectWithoutTagInput').implement({
  fields: OfferTagCreateOrConnectWithoutTagInputFields,
});

export const OfferTagCreateManyTagInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferTagCreateManyTagInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferTagCreateManyTagInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateManyTagInputEnvelope>>('OfferTagCreateManyTagInputEnvelope').implement({
  fields: OfferTagCreateManyTagInputEnvelopeFields,
});

export const CandidateCreateWithoutReferrerInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutReferrerInput>>('CandidateCreateWithoutReferrerInput').implement({
  fields: CandidateCreateWithoutReferrerInputFields,
});

export const CandidateCreateOrConnectWithoutReferrerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutReferrerInput}),
});
export const CandidateCreateOrConnectWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutReferrerInput>>('CandidateCreateOrConnectWithoutReferrerInput').implement({
  fields: CandidateCreateOrConnectWithoutReferrerInputFields,
});

export const CandidateCreateManyReferrerInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCreateManyReferrerInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCreateManyReferrerInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyReferrerInputEnvelope>>('CandidateCreateManyReferrerInputEnvelope').implement({
  fields: CandidateCreateManyReferrerInputEnvelopeFields,
});

export const CandidateTagCreateWithoutTagInputFields = (t: any) => ({
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutCandidateTagsInput}),
});
export const CandidateTagCreateWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateWithoutTagInput>>('CandidateTagCreateWithoutTagInput').implement({
  fields: CandidateTagCreateWithoutTagInputFields,
});

export const CandidateTagCreateOrConnectWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateTagCreateWithoutTagInput}),
});
export const CandidateTagCreateOrConnectWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateOrConnectWithoutTagInput>>('CandidateTagCreateOrConnectWithoutTagInput').implement({
  fields: CandidateTagCreateOrConnectWithoutTagInputFields,
});

export const CandidateTagCreateManyTagInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateTagCreateManyTagInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateTagCreateManyTagInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateManyTagInputEnvelope>>('CandidateTagCreateManyTagInputEnvelope').implement({
  fields: CandidateTagCreateManyTagInputEnvelopeFields,
});

export const CompanyUpsertWithoutTagSourcesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutTagSourcesInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTagSourcesInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutTagSourcesInput>>('CompanyUpsertWithoutTagSourcesInput').implement({
  fields: CompanyUpsertWithoutTagSourcesInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutTagSourcesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutTagSourcesInput}),
});
export const CompanyUpdateToOneWithWhereWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutTagSourcesInput>>('CompanyUpdateToOneWithWhereWithoutTagSourcesInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutTagSourcesInputFields,
});

export const CompanyUpdateWithoutTagSourcesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutTagSourcesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutTagSourcesInput>>('CompanyUpdateWithoutTagSourcesInput').implement({
  fields: CompanyUpdateWithoutTagSourcesInputFields,
});

export const OfferTagUpsertWithWhereUniqueWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferTagUpdateWithoutTagInput}),
  create: t.field({"required":true,"type":OfferTagCreateWithoutTagInput}),
});
export const OfferTagUpsertWithWhereUniqueWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpsertWithWhereUniqueWithoutTagInput>>('OfferTagUpsertWithWhereUniqueWithoutTagInput').implement({
  fields: OfferTagUpsertWithWhereUniqueWithoutTagInputFields,
});

export const OfferTagUpdateWithWhereUniqueWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferTagUpdateWithoutTagInput}),
});
export const OfferTagUpdateWithWhereUniqueWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateWithWhereUniqueWithoutTagInput>>('OfferTagUpdateWithWhereUniqueWithoutTagInput').implement({
  fields: OfferTagUpdateWithWhereUniqueWithoutTagInputFields,
});

export const OfferTagUpdateManyWithWhereWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagScalarWhereInput}),
  data: t.field({"required":true,"type":OfferTagUpdateManyMutationInput}),
});
export const OfferTagUpdateManyWithWhereWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateManyWithWhereWithoutTagInput>>('OfferTagUpdateManyWithWhereWithoutTagInput').implement({
  fields: OfferTagUpdateManyWithWhereWithoutTagInputFields,
});

export const OfferTagScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[OfferTagScalarWhereInput]}),
  OR: t.field({"required":false,"type":[OfferTagScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[OfferTagScalarWhereInput]}),
  offerId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
});
export const OfferTagScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagScalarWhereInput>>('OfferTagScalarWhereInput').implement({
  fields: OfferTagScalarWhereInputFields,
});

export const CandidateUpsertWithWhereUniqueWithoutReferrerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateUpdateWithoutReferrerInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutReferrerInput}),
});
export const CandidateUpsertWithWhereUniqueWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithWhereUniqueWithoutReferrerInput>>('CandidateUpsertWithWhereUniqueWithoutReferrerInput').implement({
  fields: CandidateUpsertWithWhereUniqueWithoutReferrerInputFields,
});

export const CandidateUpdateWithWhereUniqueWithoutReferrerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutReferrerInput}),
});
export const CandidateUpdateWithWhereUniqueWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithWhereUniqueWithoutReferrerInput>>('CandidateUpdateWithWhereUniqueWithoutReferrerInput').implement({
  fields: CandidateUpdateWithWhereUniqueWithoutReferrerInputFields,
});

export const CandidateUpdateManyWithWhereWithoutReferrerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateManyMutationInput}),
});
export const CandidateUpdateManyWithWhereWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithWhereWithoutReferrerInput>>('CandidateUpdateManyWithWhereWithoutReferrerInput').implement({
  fields: CandidateUpdateManyWithWhereWithoutReferrerInputFields,
});

export const CandidateTagUpsertWithWhereUniqueWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateTagUpdateWithoutTagInput}),
  create: t.field({"required":true,"type":CandidateTagCreateWithoutTagInput}),
});
export const CandidateTagUpsertWithWhereUniqueWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpsertWithWhereUniqueWithoutTagInput>>('CandidateTagUpsertWithWhereUniqueWithoutTagInput').implement({
  fields: CandidateTagUpsertWithWhereUniqueWithoutTagInputFields,
});

export const CandidateTagUpdateWithWhereUniqueWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateTagUpdateWithoutTagInput}),
});
export const CandidateTagUpdateWithWhereUniqueWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateWithWhereUniqueWithoutTagInput>>('CandidateTagUpdateWithWhereUniqueWithoutTagInput').implement({
  fields: CandidateTagUpdateWithWhereUniqueWithoutTagInputFields,
});

export const CandidateTagUpdateManyWithWhereWithoutTagInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateTagUpdateManyMutationInput}),
});
export const CandidateTagUpdateManyWithWhereWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateManyWithWhereWithoutTagInput>>('CandidateTagUpdateManyWithWhereWithoutTagInput').implement({
  fields: CandidateTagUpdateManyWithWhereWithoutTagInputFields,
});

export const CandidateTagScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateTagScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateTagScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateTagScalarWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  tagId: t.field({"required":false,"type":IntFilter}),
});
export const CandidateTagScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagScalarWhereInput>>('CandidateTagScalarWhereInput').implement({
  fields: CandidateTagScalarWhereInputFields,
});

export const CompanyCreateWithoutAuditLogsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutAuditLogsInput>>('CompanyCreateWithoutAuditLogsInput').implement({
  fields: CompanyCreateWithoutAuditLogsInputFields,
});

export const CompanyCreateOrConnectWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutAuditLogsInput}),
});
export const CompanyCreateOrConnectWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutAuditLogsInput>>('CompanyCreateOrConnectWithoutAuditLogsInput').implement({
  fields: CompanyCreateOrConnectWithoutAuditLogsInputFields,
});

export const HiringRoleCreateWithoutAuditLogsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutAuditLogsInput>>('HiringRoleCreateWithoutAuditLogsInput').implement({
  fields: HiringRoleCreateWithoutAuditLogsInputFields,
});

export const HiringRoleCreateOrConnectWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutAuditLogsInput}),
});
export const HiringRoleCreateOrConnectWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutAuditLogsInput>>('HiringRoleCreateOrConnectWithoutAuditLogsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutAuditLogsInputFields,
});

export const OfferCreateWithoutAuditLogsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutAuditLogsInput>>('OfferCreateWithoutAuditLogsInput').implement({
  fields: OfferCreateWithoutAuditLogsInputFields,
});

export const OfferCreateOrConnectWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutAuditLogsInput}),
});
export const OfferCreateOrConnectWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutAuditLogsInput>>('OfferCreateOrConnectWithoutAuditLogsInput').implement({
  fields: OfferCreateOrConnectWithoutAuditLogsInputFields,
});

export const CandidateCreateWithoutAuditLogsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutAuditLogsInput>>('CandidateCreateWithoutAuditLogsInput').implement({
  fields: CandidateCreateWithoutAuditLogsInputFields,
});

export const CandidateCreateOrConnectWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutAuditLogsInput}),
});
export const CandidateCreateOrConnectWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutAuditLogsInput>>('CandidateCreateOrConnectWithoutAuditLogsInput').implement({
  fields: CandidateCreateOrConnectWithoutAuditLogsInputFields,
});

export const CompanyUpsertWithoutAuditLogsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutAuditLogsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutAuditLogsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutAuditLogsInput>>('CompanyUpsertWithoutAuditLogsInput').implement({
  fields: CompanyUpsertWithoutAuditLogsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutAuditLogsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutAuditLogsInput>>('CompanyUpdateToOneWithWhereWithoutAuditLogsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutAuditLogsInputFields,
});

export const CompanyUpdateWithoutAuditLogsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutAuditLogsInput>>('CompanyUpdateWithoutAuditLogsInput').implement({
  fields: CompanyUpdateWithoutAuditLogsInputFields,
});

export const HiringRoleUpsertWithoutAuditLogsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutAuditLogsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutAuditLogsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutAuditLogsInput>>('HiringRoleUpsertWithoutAuditLogsInput').implement({
  fields: HiringRoleUpsertWithoutAuditLogsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutAuditLogsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutAuditLogsInput>>('HiringRoleUpdateToOneWithWhereWithoutAuditLogsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutAuditLogsInputFields,
});

export const HiringRoleUpdateWithoutAuditLogsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutAuditLogsInput>>('HiringRoleUpdateWithoutAuditLogsInput').implement({
  fields: HiringRoleUpdateWithoutAuditLogsInputFields,
});

export const OfferUpsertWithoutAuditLogsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutAuditLogsInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutAuditLogsInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutAuditLogsInput>>('OfferUpsertWithoutAuditLogsInput').implement({
  fields: OfferUpsertWithoutAuditLogsInputFields,
});

export const OfferUpdateToOneWithWhereWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutAuditLogsInput}),
});
export const OfferUpdateToOneWithWhereWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutAuditLogsInput>>('OfferUpdateToOneWithWhereWithoutAuditLogsInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutAuditLogsInputFields,
});

export const OfferUpdateWithoutAuditLogsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutAuditLogsInput>>('OfferUpdateWithoutAuditLogsInput').implement({
  fields: OfferUpdateWithoutAuditLogsInputFields,
});

export const CandidateUpsertWithoutAuditLogsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutAuditLogsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutAuditLogsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutAuditLogsInput>>('CandidateUpsertWithoutAuditLogsInput').implement({
  fields: CandidateUpsertWithoutAuditLogsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutAuditLogsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutAuditLogsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutAuditLogsInput>>('CandidateUpdateToOneWithWhereWithoutAuditLogsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutAuditLogsInputFields,
});

export const CandidateUpdateWithoutAuditLogsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutAuditLogsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutAuditLogsInput>>('CandidateUpdateWithoutAuditLogsInput').implement({
  fields: CandidateUpdateWithoutAuditLogsInputFields,
});

export const CompanyCreateWithoutMeetingRoomsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutMeetingRoomsInput>>('CompanyCreateWithoutMeetingRoomsInput').implement({
  fields: CompanyCreateWithoutMeetingRoomsInputFields,
});

export const CompanyCreateOrConnectWithoutMeetingRoomsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutMeetingRoomsInput}),
});
export const CompanyCreateOrConnectWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutMeetingRoomsInput>>('CompanyCreateOrConnectWithoutMeetingRoomsInput').implement({
  fields: CompanyCreateOrConnectWithoutMeetingRoomsInputFields,
});

export const CompanyUpsertWithoutMeetingRoomsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutMeetingRoomsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutMeetingRoomsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutMeetingRoomsInput>>('CompanyUpsertWithoutMeetingRoomsInput').implement({
  fields: CompanyUpsertWithoutMeetingRoomsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutMeetingRoomsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutMeetingRoomsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutMeetingRoomsInput>>('CompanyUpdateToOneWithWhereWithoutMeetingRoomsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutMeetingRoomsInputFields,
});

export const CompanyUpdateWithoutMeetingRoomsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutMeetingRoomsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutMeetingRoomsInput>>('CompanyUpdateWithoutMeetingRoomsInput').implement({
  fields: CompanyUpdateWithoutMeetingRoomsInputFields,
});

export const CompanyCreateWithoutEventScheduleInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutEventScheduleInput>>('CompanyCreateWithoutEventScheduleInput').implement({
  fields: CompanyCreateWithoutEventScheduleInputFields,
});

export const CompanyCreateOrConnectWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutEventScheduleInput}),
});
export const CompanyCreateOrConnectWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutEventScheduleInput>>('CompanyCreateOrConnectWithoutEventScheduleInput').implement({
  fields: CompanyCreateOrConnectWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerCreateWithoutEventScheduleInputFields = (t: any) => ({
  availability: t.field({"required":true,"type":Json}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleInterviewerCreateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateWithoutEventScheduleInput>>('EventScheduleInterviewerCreateWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerCreateWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleInterviewerCreateWithoutEventScheduleInput}),
});
export const EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInput>>('EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerCreateOrConnectWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerCreateManyEventScheduleInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventScheduleInterviewerCreateManyEventScheduleInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventScheduleInterviewerCreateManyEventScheduleInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateManyEventScheduleInputEnvelope>>('EventScheduleInterviewerCreateManyEventScheduleInputEnvelope').implement({
  fields: EventScheduleInterviewerCreateManyEventScheduleInputEnvelopeFields,
});

export const EventScheduleEvaluationCreateWithoutEventScheduleInputFields = (t: any) => ({
  evaluation: t.field({"required":true,"type":EvaluationCreateNestedOneWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleEvaluationCreateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateWithoutEventScheduleInput>>('EventScheduleEvaluationCreateWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationCreateWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleEvaluationCreateWithoutEventScheduleInput}),
});
export const EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInput>>('EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationCreateOrConnectWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationCreateManyEventScheduleInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventScheduleEvaluationCreateManyEventScheduleInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventScheduleEvaluationCreateManyEventScheduleInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateManyEventScheduleInputEnvelope>>('EventScheduleEvaluationCreateManyEventScheduleInputEnvelope').implement({
  fields: EventScheduleEvaluationCreateManyEventScheduleInputEnvelopeFields,
});

export const CompanyUpsertWithoutEventScheduleInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutEventScheduleInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutEventScheduleInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutEventScheduleInput>>('CompanyUpsertWithoutEventScheduleInput').implement({
  fields: CompanyUpsertWithoutEventScheduleInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutEventScheduleInput}),
});
export const CompanyUpdateToOneWithWhereWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutEventScheduleInput>>('CompanyUpdateToOneWithWhereWithoutEventScheduleInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutEventScheduleInputFields,
});

export const CompanyUpdateWithoutEventScheduleInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutEventScheduleInput>>('CompanyUpdateWithoutEventScheduleInput').implement({
  fields: CompanyUpdateWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  update: t.field({"required":true,"type":EventScheduleInterviewerUpdateWithoutEventScheduleInput}),
  create: t.field({"required":true,"type":EventScheduleInterviewerCreateWithoutEventScheduleInput}),
});
export const EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInput>>('EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerUpsertWithWhereUniqueWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerWhereUniqueInput}),
  data: t.field({"required":true,"type":EventScheduleInterviewerUpdateWithoutEventScheduleInput}),
});
export const EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInput>>('EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerUpdateWithWhereUniqueWithoutEventScheduleInputFields,
});

export const EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleInterviewerScalarWhereInput}),
  data: t.field({"required":true,"type":EventScheduleInterviewerUpdateManyMutationInput}),
});
export const EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInput>>('EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerUpdateManyWithWhereWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EventScheduleEvaluationUpdateWithoutEventScheduleInput}),
  create: t.field({"required":true,"type":EventScheduleEvaluationCreateWithoutEventScheduleInput}),
});
export const EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInput>>('EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationUpsertWithWhereUniqueWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EventScheduleEvaluationUpdateWithoutEventScheduleInput}),
});
export const EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInput>>('EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationUpdateWithWhereUniqueWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EventScheduleEvaluationUpdateManyMutationInput}),
});
export const EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInput>>('EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationUpdateManyWithWhereWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EventScheduleEvaluationScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  eventScheduleId: t.field({"required":false,"type":IntFilter}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
});
export const EventScheduleEvaluationScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationScalarWhereInput>>('EventScheduleEvaluationScalarWhereInput').implement({
  fields: EventScheduleEvaluationScalarWhereInputFields,
});

export const EventScheduleCreateWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventScheduleInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEventScheduleInput}),
});
export const EventScheduleCreateWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateWithoutEventScheduleInterviewersInput>>('EventScheduleCreateWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleCreateWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInput>>('EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleCreateOrConnectWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleCreateWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutEventScheduleInterviewersInput>>('HiringRoleCreateWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleCreateWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEventScheduleInterviewersInput}),
});
export const HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInput>>('HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleCreateOrConnectWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleUpsertWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EventScheduleUpdateWithoutEventScheduleInterviewersInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutEventScheduleInterviewersInput}),
  where: t.field({"required":false,"type":EventScheduleWhereInput}),
});
export const EventScheduleUpsertWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpsertWithoutEventScheduleInterviewersInput>>('EventScheduleUpsertWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleUpsertWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EventScheduleWhereInput}),
  data: t.field({"required":true,"type":EventScheduleUpdateWithoutEventScheduleInterviewersInput}),
});
export const EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput>>('EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleUpdateToOneWithWhereWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleUpdateWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dateRange: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  expiresAfter: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  inviteAll: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  bufferTime: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  meetingLimit: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  Interval: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventScheduleNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput}),
});
export const EventScheduleUpdateWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateWithoutEventScheduleInterviewersInput>>('EventScheduleUpdateWithoutEventScheduleInterviewersInput').implement({
  fields: EventScheduleUpdateWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleUpsertWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutEventScheduleInterviewersInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEventScheduleInterviewersInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutEventScheduleInterviewersInput>>('HiringRoleUpsertWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleUpsertWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutEventScheduleInterviewersInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput>>('HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutEventScheduleInterviewersInputFields,
});

export const HiringRoleUpdateWithoutEventScheduleInterviewersInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutEventScheduleInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutEventScheduleInterviewersInput>>('HiringRoleUpdateWithoutEventScheduleInterviewersInput').implement({
  fields: HiringRoleUpdateWithoutEventScheduleInterviewersInputFields,
});

export const EventScheduleCreateWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventScheduleInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutEventScheduleInput}),
});
export const EventScheduleCreateWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateWithoutEventScheduleEvaluationsInput>>('EventScheduleCreateWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleCreateWithoutEventScheduleEvaluationsInputFields,
});

export const EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInput>>('EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleCreateOrConnectWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationCreateWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutEventScheduleEvaluationsInput>>('EvaluationCreateWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationCreateWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutEventScheduleEvaluationsInput}),
});
export const EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInput>>('EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationCreateOrConnectWithoutEventScheduleEvaluationsInputFields,
});

export const EventScheduleUpsertWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EventScheduleUpdateWithoutEventScheduleEvaluationsInput}),
  create: t.field({"required":true,"type":EventScheduleCreateWithoutEventScheduleEvaluationsInput}),
  where: t.field({"required":false,"type":EventScheduleWhereInput}),
});
export const EventScheduleUpsertWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpsertWithoutEventScheduleEvaluationsInput>>('EventScheduleUpsertWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleUpsertWithoutEventScheduleEvaluationsInputFields,
});

export const EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EventScheduleWhereInput}),
  data: t.field({"required":true,"type":EventScheduleUpdateWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput>>('EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleUpdateToOneWithWhereWithoutEventScheduleEvaluationsInputFields,
});

export const EventScheduleUpdateWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dateRange: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  expiresAfter: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  inviteAll: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  bufferTime: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  meetingLimit: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  Interval: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventScheduleNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput}),
});
export const EventScheduleUpdateWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateWithoutEventScheduleEvaluationsInput>>('EventScheduleUpdateWithoutEventScheduleEvaluationsInput').implement({
  fields: EventScheduleUpdateWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationUpsertWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EvaluationUpdateWithoutEventScheduleEvaluationsInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutEventScheduleEvaluationsInput}),
  where: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationUpsertWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithoutEventScheduleEvaluationsInput>>('EvaluationUpsertWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationUpsertWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EvaluationWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutEventScheduleEvaluationsInput}),
});
export const EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput>>('EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationUpdateToOneWithWhereWithoutEventScheduleEvaluationsInputFields,
});

export const EvaluationUpdateWithoutEventScheduleEvaluationsInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutEventScheduleEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutEventScheduleEvaluationsInput>>('EvaluationUpdateWithoutEventScheduleEvaluationsInput').implement({
  fields: EvaluationUpdateWithoutEventScheduleEvaluationsInputFields,
});

export const CompanyCreateWithoutEventsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutEventsInput>>('CompanyCreateWithoutEventsInput').implement({
  fields: CompanyCreateWithoutEventsInputFields,
});

export const CompanyCreateOrConnectWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutEventsInput}),
});
export const CompanyCreateOrConnectWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutEventsInput>>('CompanyCreateOrConnectWithoutEventsInput').implement({
  fields: CompanyCreateOrConnectWithoutEventsInputFields,
});

export const HiringRoleCreateWithoutInterviewerEventsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutInterviewerEventsInput>>('HiringRoleCreateWithoutInterviewerEventsInput').implement({
  fields: HiringRoleCreateWithoutInterviewerEventsInputFields,
});

export const HiringRoleCreateOrConnectWithoutInterviewerEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutInterviewerEventsInput}),
});
export const HiringRoleCreateOrConnectWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutInterviewerEventsInput>>('HiringRoleCreateOrConnectWithoutInterviewerEventsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutInterviewerEventsInputFields,
});

export const EvaluationCreateWithoutEventInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutEventInput>>('EvaluationCreateWithoutEventInput').implement({
  fields: EvaluationCreateWithoutEventInputFields,
});

export const EvaluationCreateOrConnectWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutEventInput}),
});
export const EvaluationCreateOrConnectWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutEventInput>>('EvaluationCreateOrConnectWithoutEventInput').implement({
  fields: EvaluationCreateOrConnectWithoutEventInputFields,
});

export const EvaluationCreateManyEventInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationCreateManyEventInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationCreateManyEventInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyEventInputEnvelope>>('EvaluationCreateManyEventInputEnvelope').implement({
  fields: EvaluationCreateManyEventInputEnvelopeFields,
});

export const CandidateCreateWithoutEventsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
});
export const CandidateCreateWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutEventsInput>>('CandidateCreateWithoutEventsInput').implement({
  fields: CandidateCreateWithoutEventsInputFields,
});

export const CandidateCreateOrConnectWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutEventsInput}),
});
export const CandidateCreateOrConnectWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutEventsInput>>('CandidateCreateOrConnectWithoutEventsInput').implement({
  fields: CandidateCreateOrConnectWithoutEventsInputFields,
});

export const HiringRoleCreateWithoutCreatedEventsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutCreatedEventsInput>>('HiringRoleCreateWithoutCreatedEventsInput').implement({
  fields: HiringRoleCreateWithoutCreatedEventsInputFields,
});

export const HiringRoleCreateOrConnectWithoutCreatedEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutCreatedEventsInput}),
});
export const HiringRoleCreateOrConnectWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutCreatedEventsInput>>('HiringRoleCreateOrConnectWithoutCreatedEventsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutCreatedEventsInputFields,
});

export const EventInterviewerCreateWithoutEventInputFields = (t: any) => ({
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEventInterviewerInput}),
});
export const EventInterviewerCreateWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateWithoutEventInput>>('EventInterviewerCreateWithoutEventInput').implement({
  fields: EventInterviewerCreateWithoutEventInputFields,
});

export const EventInterviewerCreateOrConnectWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  create: t.field({"required":true,"type":EventInterviewerCreateWithoutEventInput}),
});
export const EventInterviewerCreateOrConnectWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateOrConnectWithoutEventInput>>('EventInterviewerCreateOrConnectWithoutEventInput').implement({
  fields: EventInterviewerCreateOrConnectWithoutEventInputFields,
});

export const EventInterviewerCreateManyEventInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventInterviewerCreateManyEventInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventInterviewerCreateManyEventInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateManyEventInputEnvelope>>('EventInterviewerCreateManyEventInputEnvelope').implement({
  fields: EventInterviewerCreateManyEventInputEnvelopeFields,
});

export const CompanyUpsertWithoutEventsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutEventsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutEventsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutEventsInput>>('CompanyUpsertWithoutEventsInput').implement({
  fields: CompanyUpsertWithoutEventsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutEventsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutEventsInput>>('CompanyUpdateToOneWithWhereWithoutEventsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutEventsInputFields,
});

export const CompanyUpdateWithoutEventsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutEventsInput>>('CompanyUpdateWithoutEventsInput').implement({
  fields: CompanyUpdateWithoutEventsInputFields,
});

export const HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutInterviewerEventsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutInterviewerEventsInput}),
});
export const HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInput>>('HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInput').implement({
  fields: HiringRoleUpsertWithWhereUniqueWithoutInterviewerEventsInputFields,
});

export const HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutInterviewerEventsInput}),
});
export const HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInput>>('HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInput').implement({
  fields: HiringRoleUpdateWithWhereUniqueWithoutInterviewerEventsInputFields,
});

export const HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleScalarWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateManyMutationInput}),
});
export const HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInput>>('HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInput').implement({
  fields: HiringRoleUpdateManyWithWhereWithoutInterviewerEventsInputFields,
});

export const EvaluationUpsertWithWhereUniqueWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationUpdateWithoutEventInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutEventInput}),
});
export const EvaluationUpsertWithWhereUniqueWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithWhereUniqueWithoutEventInput>>('EvaluationUpsertWithWhereUniqueWithoutEventInput').implement({
  fields: EvaluationUpsertWithWhereUniqueWithoutEventInputFields,
});

export const EvaluationUpdateWithWhereUniqueWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutEventInput}),
});
export const EvaluationUpdateWithWhereUniqueWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithWhereUniqueWithoutEventInput>>('EvaluationUpdateWithWhereUniqueWithoutEventInput').implement({
  fields: EvaluationUpdateWithWhereUniqueWithoutEventInputFields,
});

export const EvaluationUpdateManyWithWhereWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateManyMutationInput}),
});
export const EvaluationUpdateManyWithWhereWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithWhereWithoutEventInput>>('EvaluationUpdateManyWithWhereWithoutEventInput').implement({
  fields: EvaluationUpdateManyWithWhereWithoutEventInputFields,
});

export const CandidateUpsertWithWhereUniqueWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateUpdateWithoutEventsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutEventsInput}),
});
export const CandidateUpsertWithWhereUniqueWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithWhereUniqueWithoutEventsInput>>('CandidateUpsertWithWhereUniqueWithoutEventsInput').implement({
  fields: CandidateUpsertWithWhereUniqueWithoutEventsInputFields,
});

export const CandidateUpdateWithWhereUniqueWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutEventsInput}),
});
export const CandidateUpdateWithWhereUniqueWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithWhereUniqueWithoutEventsInput>>('CandidateUpdateWithWhereUniqueWithoutEventsInput').implement({
  fields: CandidateUpdateWithWhereUniqueWithoutEventsInputFields,
});

export const CandidateUpdateManyWithWhereWithoutEventsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateManyMutationInput}),
});
export const CandidateUpdateManyWithWhereWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithWhereWithoutEventsInput>>('CandidateUpdateManyWithWhereWithoutEventsInput').implement({
  fields: CandidateUpdateManyWithWhereWithoutEventsInputFields,
});

export const HiringRoleUpsertWithoutCreatedEventsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutCreatedEventsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutCreatedEventsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutCreatedEventsInput>>('HiringRoleUpsertWithoutCreatedEventsInput').implement({
  fields: HiringRoleUpsertWithoutCreatedEventsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutCreatedEventsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInput>>('HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutCreatedEventsInputFields,
});

export const HiringRoleUpdateWithoutCreatedEventsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutCreatedEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutCreatedEventsInput>>('HiringRoleUpdateWithoutCreatedEventsInput').implement({
  fields: HiringRoleUpdateWithoutCreatedEventsInputFields,
});

export const EventInterviewerUpsertWithWhereUniqueWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  update: t.field({"required":true,"type":EventInterviewerUpdateWithoutEventInput}),
  create: t.field({"required":true,"type":EventInterviewerCreateWithoutEventInput}),
});
export const EventInterviewerUpsertWithWhereUniqueWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpsertWithWhereUniqueWithoutEventInput>>('EventInterviewerUpsertWithWhereUniqueWithoutEventInput').implement({
  fields: EventInterviewerUpsertWithWhereUniqueWithoutEventInputFields,
});

export const EventInterviewerUpdateWithWhereUniqueWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerWhereUniqueInput}),
  data: t.field({"required":true,"type":EventInterviewerUpdateWithoutEventInput}),
});
export const EventInterviewerUpdateWithWhereUniqueWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateWithWhereUniqueWithoutEventInput>>('EventInterviewerUpdateWithWhereUniqueWithoutEventInput').implement({
  fields: EventInterviewerUpdateWithWhereUniqueWithoutEventInputFields,
});

export const EventInterviewerUpdateManyWithWhereWithoutEventInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventInterviewerScalarWhereInput}),
  data: t.field({"required":true,"type":EventInterviewerUpdateManyMutationInput}),
});
export const EventInterviewerUpdateManyWithWhereWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateManyWithWhereWithoutEventInput>>('EventInterviewerUpdateManyWithWhereWithoutEventInput').implement({
  fields: EventInterviewerUpdateManyWithWhereWithoutEventInputFields,
});

export const EventCreateWithoutEventInterviewerInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
});
export const EventCreateWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutEventInterviewerInput>>('EventCreateWithoutEventInterviewerInput').implement({
  fields: EventCreateWithoutEventInterviewerInputFields,
});

export const EventCreateOrConnectWithoutEventInterviewerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutEventInterviewerInput}),
});
export const EventCreateOrConnectWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutEventInterviewerInput>>('EventCreateOrConnectWithoutEventInterviewerInput').implement({
  fields: EventCreateOrConnectWithoutEventInterviewerInputFields,
});

export const HiringRoleCreateWithoutEventInterviewerInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
});
export const HiringRoleCreateWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutEventInterviewerInput>>('HiringRoleCreateWithoutEventInterviewerInput').implement({
  fields: HiringRoleCreateWithoutEventInterviewerInputFields,
});

export const HiringRoleCreateOrConnectWithoutEventInterviewerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEventInterviewerInput}),
});
export const HiringRoleCreateOrConnectWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutEventInterviewerInput>>('HiringRoleCreateOrConnectWithoutEventInterviewerInput').implement({
  fields: HiringRoleCreateOrConnectWithoutEventInterviewerInputFields,
});

export const EventUpsertWithoutEventInterviewerInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EventUpdateWithoutEventInterviewerInput}),
  create: t.field({"required":true,"type":EventCreateWithoutEventInterviewerInput}),
  where: t.field({"required":false,"type":EventWhereInput}),
});
export const EventUpsertWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithoutEventInterviewerInput>>('EventUpsertWithoutEventInterviewerInput').implement({
  fields: EventUpsertWithoutEventInterviewerInputFields,
});

export const EventUpdateToOneWithWhereWithoutEventInterviewerInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EventWhereInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutEventInterviewerInput}),
});
export const EventUpdateToOneWithWhereWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateToOneWithWhereWithoutEventInterviewerInput>>('EventUpdateToOneWithWhereWithoutEventInterviewerInput').implement({
  fields: EventUpdateToOneWithWhereWithoutEventInterviewerInputFields,
});

export const EventUpdateWithoutEventInterviewerInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
});
export const EventUpdateWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutEventInterviewerInput>>('EventUpdateWithoutEventInterviewerInput').implement({
  fields: EventUpdateWithoutEventInterviewerInputFields,
});

export const HiringRoleUpsertWithoutEventInterviewerInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutEventInterviewerInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEventInterviewerInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutEventInterviewerInput>>('HiringRoleUpsertWithoutEventInterviewerInput').implement({
  fields: HiringRoleUpsertWithoutEventInterviewerInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutEventInterviewerInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInput>>('HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutEventInterviewerInputFields,
});

export const HiringRoleUpdateWithoutEventInterviewerInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
});
export const HiringRoleUpdateWithoutEventInterviewerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutEventInterviewerInput>>('HiringRoleUpdateWithoutEventInterviewerInput').implement({
  fields: HiringRoleUpdateWithoutEventInterviewerInputFields,
});

export const CompanyCreateWithoutOffersInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutOffersInput>>('CompanyCreateWithoutOffersInput').implement({
  fields: CompanyCreateWithoutOffersInputFields,
});

export const CompanyCreateOrConnectWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutOffersInput}),
});
export const CompanyCreateOrConnectWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutOffersInput>>('CompanyCreateOrConnectWithoutOffersInput').implement({
  fields: CompanyCreateOrConnectWithoutOffersInputFields,
});

export const DepartmentCreateWithoutOffersInputFields = (t: any) => ({
  name: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutDepartmentsInput}),
});
export const DepartmentCreateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateWithoutOffersInput>>('DepartmentCreateWithoutOffersInput').implement({
  fields: DepartmentCreateWithoutOffersInputFields,
});

export const DepartmentCreateOrConnectWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DepartmentWhereUniqueInput}),
  create: t.field({"required":true,"type":DepartmentCreateWithoutOffersInput}),
});
export const DepartmentCreateOrConnectWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateOrConnectWithoutOffersInput>>('DepartmentCreateOrConnectWithoutOffersInput').implement({
  fields: DepartmentCreateOrConnectWithoutOffersInputFields,
});

export const HiringRoleCreateWithoutOfferRecruiterInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutOfferRecruiterInput>>('HiringRoleCreateWithoutOfferRecruiterInput').implement({
  fields: HiringRoleCreateWithoutOfferRecruiterInputFields,
});

export const HiringRoleCreateOrConnectWithoutOfferRecruiterInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutOfferRecruiterInput}),
});
export const HiringRoleCreateOrConnectWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutOfferRecruiterInput>>('HiringRoleCreateOrConnectWithoutOfferRecruiterInput').implement({
  fields: HiringRoleCreateOrConnectWithoutOfferRecruiterInputFields,
});

export const HiringRoleCreateWithoutOfferHiringManagerInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutOfferHiringManagerInput>>('HiringRoleCreateWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleCreateWithoutOfferHiringManagerInputFields,
});

export const HiringRoleCreateOrConnectWithoutOfferHiringManagerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutOfferHiringManagerInput}),
});
export const HiringRoleCreateOrConnectWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutOfferHiringManagerInput>>('HiringRoleCreateOrConnectWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleCreateOrConnectWithoutOfferHiringManagerInputFields,
});

export const TemplateCreateWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutScreeningQuestionsTemplateInput>>('TemplateCreateWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateCreateWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutScreeningQuestionsTemplateInput}),
});
export const TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInput>>('TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateCreateOrConnectWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateCreateWithoutPipelineTemplateInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutPipelineTemplateInput>>('TemplateCreateWithoutPipelineTemplateInput').implement({
  fields: TemplateCreateWithoutPipelineTemplateInputFields,
});

export const TemplateCreateOrConnectWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutPipelineTemplateInput}),
});
export const TemplateCreateOrConnectWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutPipelineTemplateInput>>('TemplateCreateOrConnectWithoutPipelineTemplateInput').implement({
  fields: TemplateCreateOrConnectWithoutPipelineTemplateInputFields,
});

export const TemplateCreateWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutAutoConfirmationEmailInput>>('TemplateCreateWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateCreateWithoutAutoConfirmationEmailInputFields,
});

export const TemplateCreateOrConnectWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutAutoConfirmationEmailInput}),
});
export const TemplateCreateOrConnectWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutAutoConfirmationEmailInput>>('TemplateCreateOrConnectWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateCreateOrConnectWithoutAutoConfirmationEmailInputFields,
});

export const AuditLogCreateWithoutOfferInputFields = (t: any) => ({
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAuditLogsInput}),
  user: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAuditLogsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAuditLogsInput}),
});
export const AuditLogCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateWithoutOfferInput>>('AuditLogCreateWithoutOfferInput').implement({
  fields: AuditLogCreateWithoutOfferInputFields,
});

export const AuditLogCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutOfferInput}),
});
export const AuditLogCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateOrConnectWithoutOfferInput>>('AuditLogCreateOrConnectWithoutOfferInput').implement({
  fields: AuditLogCreateOrConnectWithoutOfferInputFields,
});

export const AuditLogCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AuditLogCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AuditLogCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyOfferInputEnvelope>>('AuditLogCreateManyOfferInputEnvelope').implement({
  fields: AuditLogCreateManyOfferInputEnvelopeFields,
});

export const OfferFileCreateWithoutOfferInputFields = (t: any) => ({
  attachment: t.field({"required":true,"type":AttachmentCreateNestedOneWithoutOfferFilesInput}),
});
export const OfferFileCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateWithoutOfferInput>>('OfferFileCreateWithoutOfferInput').implement({
  fields: OfferFileCreateWithoutOfferInputFields,
});

export const OfferFileCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferFileCreateWithoutOfferInput}),
});
export const OfferFileCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateOrConnectWithoutOfferInput>>('OfferFileCreateOrConnectWithoutOfferInput').implement({
  fields: OfferFileCreateOrConnectWithoutOfferInputFields,
});

export const OfferFileCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferFileCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferFileCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateManyOfferInputEnvelope>>('OfferFileCreateManyOfferInputEnvelope').implement({
  fields: OfferFileCreateManyOfferInputEnvelopeFields,
});

export const OfferTagCreateWithoutOfferInputFields = (t: any) => ({
  tag: t.field({"required":true,"type":TagSourceCreateNestedOneWithoutOfferTagsInput}),
});
export const OfferTagCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateWithoutOfferInput>>('OfferTagCreateWithoutOfferInput').implement({
  fields: OfferTagCreateWithoutOfferInputFields,
});

export const OfferTagCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferTagCreateWithoutOfferInput}),
});
export const OfferTagCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateOrConnectWithoutOfferInput>>('OfferTagCreateOrConnectWithoutOfferInput').implement({
  fields: OfferTagCreateOrConnectWithoutOfferInputFields,
});

export const OfferTagCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferTagCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferTagCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateManyOfferInputEnvelope>>('OfferTagCreateManyOfferInputEnvelope').implement({
  fields: OfferTagCreateManyOfferInputEnvelopeFields,
});

export const MembershipCreateWithoutOfferInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutMembershipsInput}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutMembershipsInput}),
});
export const MembershipCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateWithoutOfferInput>>('MembershipCreateWithoutOfferInput').implement({
  fields: MembershipCreateWithoutOfferInputFields,
});

export const MembershipCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutOfferInput}),
});
export const MembershipCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateOrConnectWithoutOfferInput>>('MembershipCreateOrConnectWithoutOfferInput').implement({
  fields: MembershipCreateOrConnectWithoutOfferInputFields,
});

export const MembershipCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MembershipCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MembershipCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyOfferInputEnvelope>>('MembershipCreateManyOfferInputEnvelope').implement({
  fields: MembershipCreateManyOfferInputEnvelopeFields,
});

export const MatchCreateWithoutOfferInputFields = (t: any) => ({
  isHired: t.boolean({"required":false}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutOffersInput}),
  stage: t.field({"required":false,"type":StageCreateNestedOneWithoutMatchesInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonCreateNestedOneWithoutMatchesInput}),
});
export const MatchCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateWithoutOfferInput>>('MatchCreateWithoutOfferInput').implement({
  fields: MatchCreateWithoutOfferInputFields,
});

export const MatchCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutOfferInput}),
});
export const MatchCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateOrConnectWithoutOfferInput>>('MatchCreateOrConnectWithoutOfferInput').implement({
  fields: MatchCreateOrConnectWithoutOfferInputFields,
});

export const MatchCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MatchCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MatchCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyOfferInputEnvelope>>('MatchCreateManyOfferInputEnvelope').implement({
  fields: MatchCreateManyOfferInputEnvelopeFields,
});

export const CandidateCreateWithoutHiredAtInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutHiredAtInput>>('CandidateCreateWithoutHiredAtInput').implement({
  fields: CandidateCreateWithoutHiredAtInputFields,
});

export const CandidateCreateOrConnectWithoutHiredAtInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutHiredAtInput}),
});
export const CandidateCreateOrConnectWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutHiredAtInput>>('CandidateCreateOrConnectWithoutHiredAtInput').implement({
  fields: CandidateCreateOrConnectWithoutHiredAtInputFields,
});

export const CandidateCreateManyHiredAtInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCreateManyHiredAtInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCreateManyHiredAtInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyHiredAtInputEnvelope>>('CandidateCreateManyHiredAtInputEnvelope').implement({
  fields: CandidateCreateManyHiredAtInputEnvelopeFields,
});

export const EvaluationCreateWithoutOfferInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutOfferInput>>('EvaluationCreateWithoutOfferInput').implement({
  fields: EvaluationCreateWithoutOfferInputFields,
});

export const EvaluationCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutOfferInput}),
});
export const EvaluationCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutOfferInput>>('EvaluationCreateOrConnectWithoutOfferInput').implement({
  fields: EvaluationCreateOrConnectWithoutOfferInputFields,
});

export const EvaluationCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyOfferInputEnvelope>>('EvaluationCreateManyOfferInputEnvelope').implement({
  fields: EvaluationCreateManyOfferInputEnvelopeFields,
});

export const FollowCreateWithoutOfferInputFields = (t: any) => ({
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutFollowsInput}),
  talentPool: t.field({"required":false,"type":TalentPoolCreateNestedOneWithoutFollowsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutFollowsInput}),
});
export const FollowCreateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateWithoutOfferInput>>('FollowCreateWithoutOfferInput').implement({
  fields: FollowCreateWithoutOfferInputFields,
});

export const FollowCreateOrConnectWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutOfferInput}),
});
export const FollowCreateOrConnectWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateOrConnectWithoutOfferInput>>('FollowCreateOrConnectWithoutOfferInput').implement({
  fields: FollowCreateOrConnectWithoutOfferInputFields,
});

export const FollowCreateManyOfferInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[FollowCreateManyOfferInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const FollowCreateManyOfferInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyOfferInputEnvelope>>('FollowCreateManyOfferInputEnvelope').implement({
  fields: FollowCreateManyOfferInputEnvelopeFields,
});

export const CompanyUpsertWithoutOffersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutOffersInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutOffersInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutOffersInput>>('CompanyUpsertWithoutOffersInput').implement({
  fields: CompanyUpsertWithoutOffersInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutOffersInput}),
});
export const CompanyUpdateToOneWithWhereWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutOffersInput>>('CompanyUpdateToOneWithWhereWithoutOffersInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutOffersInputFields,
});

export const CompanyUpdateWithoutOffersInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutOffersInput>>('CompanyUpdateWithoutOffersInput').implement({
  fields: CompanyUpdateWithoutOffersInputFields,
});

export const DepartmentUpsertWithoutOffersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":DepartmentUpdateWithoutOffersInput}),
  create: t.field({"required":true,"type":DepartmentCreateWithoutOffersInput}),
  where: t.field({"required":false,"type":DepartmentWhereInput}),
});
export const DepartmentUpsertWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpsertWithoutOffersInput>>('DepartmentUpsertWithoutOffersInput').implement({
  fields: DepartmentUpsertWithoutOffersInputFields,
});

export const DepartmentUpdateToOneWithWhereWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":DepartmentWhereInput}),
  data: t.field({"required":true,"type":DepartmentUpdateWithoutOffersInput}),
});
export const DepartmentUpdateToOneWithWhereWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateToOneWithWhereWithoutOffersInput>>('DepartmentUpdateToOneWithWhereWithoutOffersInput').implement({
  fields: DepartmentUpdateToOneWithWhereWithoutOffersInputFields,
});

export const DepartmentUpdateWithoutOffersInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutDepartmentsNestedInput}),
});
export const DepartmentUpdateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateWithoutOffersInput>>('DepartmentUpdateWithoutOffersInput').implement({
  fields: DepartmentUpdateWithoutOffersInputFields,
});

export const HiringRoleUpsertWithoutOfferRecruiterInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutOfferRecruiterInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutOfferRecruiterInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutOfferRecruiterInput>>('HiringRoleUpsertWithoutOfferRecruiterInput').implement({
  fields: HiringRoleUpsertWithoutOfferRecruiterInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutOfferRecruiterInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInput>>('HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutOfferRecruiterInputFields,
});

export const HiringRoleUpdateWithoutOfferRecruiterInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutOfferRecruiterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutOfferRecruiterInput>>('HiringRoleUpdateWithoutOfferRecruiterInput').implement({
  fields: HiringRoleUpdateWithoutOfferRecruiterInputFields,
});

export const HiringRoleUpsertWithoutOfferHiringManagerInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutOfferHiringManagerInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutOfferHiringManagerInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutOfferHiringManagerInput>>('HiringRoleUpsertWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleUpsertWithoutOfferHiringManagerInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutOfferHiringManagerInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInput>>('HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutOfferHiringManagerInputFields,
});

export const HiringRoleUpdateWithoutOfferHiringManagerInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutOfferHiringManagerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutOfferHiringManagerInput>>('HiringRoleUpdateWithoutOfferHiringManagerInput').implement({
  fields: HiringRoleUpdateWithoutOfferHiringManagerInputFields,
});

export const TemplateUpsertWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TemplateUpdateWithoutScreeningQuestionsTemplateInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutScreeningQuestionsTemplateInput}),
  where: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateUpsertWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithoutScreeningQuestionsTemplateInput>>('TemplateUpsertWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateUpsertWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TemplateWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutScreeningQuestionsTemplateInput}),
});
export const TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInput>>('TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateUpdateToOneWithWhereWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateUpdateWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutScreeningQuestionsTemplateInput>>('TemplateUpdateWithoutScreeningQuestionsTemplateInput').implement({
  fields: TemplateUpdateWithoutScreeningQuestionsTemplateInputFields,
});

export const TemplateUpsertWithoutPipelineTemplateInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TemplateUpdateWithoutPipelineTemplateInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutPipelineTemplateInput}),
  where: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateUpsertWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithoutPipelineTemplateInput>>('TemplateUpsertWithoutPipelineTemplateInput').implement({
  fields: TemplateUpsertWithoutPipelineTemplateInputFields,
});

export const TemplateUpdateToOneWithWhereWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TemplateWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutPipelineTemplateInput}),
});
export const TemplateUpdateToOneWithWhereWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateToOneWithWhereWithoutPipelineTemplateInput>>('TemplateUpdateToOneWithWhereWithoutPipelineTemplateInput').implement({
  fields: TemplateUpdateToOneWithWhereWithoutPipelineTemplateInputFields,
});

export const TemplateUpdateWithoutPipelineTemplateInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutPipelineTemplateInput>>('TemplateUpdateWithoutPipelineTemplateInput').implement({
  fields: TemplateUpdateWithoutPipelineTemplateInputFields,
});

export const TemplateUpsertWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TemplateUpdateWithoutAutoConfirmationEmailInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutAutoConfirmationEmailInput}),
  where: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateUpsertWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithoutAutoConfirmationEmailInput>>('TemplateUpsertWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateUpsertWithoutAutoConfirmationEmailInputFields,
});

export const TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TemplateWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutAutoConfirmationEmailInput}),
});
export const TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInput>>('TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateUpdateToOneWithWhereWithoutAutoConfirmationEmailInputFields,
});

export const TemplateUpdateWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutAutoConfirmationEmailInput>>('TemplateUpdateWithoutAutoConfirmationEmailInput').implement({
  fields: TemplateUpdateWithoutAutoConfirmationEmailInputFields,
});

export const AuditLogUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  update: t.field({"required":true,"type":AuditLogUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutOfferInput}),
});
export const AuditLogUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpsertWithWhereUniqueWithoutOfferInput>>('AuditLogUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: AuditLogUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const AuditLogUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  data: t.field({"required":true,"type":AuditLogUpdateWithoutOfferInput}),
});
export const AuditLogUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithWhereUniqueWithoutOfferInput>>('AuditLogUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: AuditLogUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const AuditLogUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogScalarWhereInput}),
  data: t.field({"required":true,"type":AuditLogUpdateManyMutationInput}),
});
export const AuditLogUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithWhereWithoutOfferInput>>('AuditLogUpdateManyWithWhereWithoutOfferInput').implement({
  fields: AuditLogUpdateManyWithWhereWithoutOfferInputFields,
});

export const OfferFileUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferFileUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":OfferFileCreateWithoutOfferInput}),
});
export const OfferFileUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpsertWithWhereUniqueWithoutOfferInput>>('OfferFileUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: OfferFileUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const OfferFileUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferFileUpdateWithoutOfferInput}),
});
export const OfferFileUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateWithWhereUniqueWithoutOfferInput>>('OfferFileUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: OfferFileUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const OfferFileUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferFileScalarWhereInput}),
  data: t.field({"required":true,"type":OfferFileUpdateManyMutationInput}),
});
export const OfferFileUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateManyWithWhereWithoutOfferInput>>('OfferFileUpdateManyWithWhereWithoutOfferInput').implement({
  fields: OfferFileUpdateManyWithWhereWithoutOfferInputFields,
});

export const OfferTagUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferTagUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":OfferTagCreateWithoutOfferInput}),
});
export const OfferTagUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpsertWithWhereUniqueWithoutOfferInput>>('OfferTagUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: OfferTagUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const OfferTagUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferTagUpdateWithoutOfferInput}),
});
export const OfferTagUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateWithWhereUniqueWithoutOfferInput>>('OfferTagUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: OfferTagUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const OfferTagUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferTagScalarWhereInput}),
  data: t.field({"required":true,"type":OfferTagUpdateManyMutationInput}),
});
export const OfferTagUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateManyWithWhereWithoutOfferInput>>('OfferTagUpdateManyWithWhereWithoutOfferInput').implement({
  fields: OfferTagUpdateManyWithWhereWithoutOfferInputFields,
});

export const MembershipUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  update: t.field({"required":true,"type":MembershipUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":MembershipCreateWithoutOfferInput}),
});
export const MembershipUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpsertWithWhereUniqueWithoutOfferInput>>('MembershipUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: MembershipUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const MembershipUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipWhereUniqueInput}),
  data: t.field({"required":true,"type":MembershipUpdateWithoutOfferInput}),
});
export const MembershipUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithWhereUniqueWithoutOfferInput>>('MembershipUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: MembershipUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const MembershipUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MembershipScalarWhereInput}),
  data: t.field({"required":true,"type":MembershipUpdateManyMutationInput}),
});
export const MembershipUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateManyWithWhereWithoutOfferInput>>('MembershipUpdateManyWithWhereWithoutOfferInput').implement({
  fields: MembershipUpdateManyWithWhereWithoutOfferInputFields,
});

export const MatchUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  update: t.field({"required":true,"type":MatchUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutOfferInput}),
});
export const MatchUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpsertWithWhereUniqueWithoutOfferInput>>('MatchUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: MatchUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const MatchUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  data: t.field({"required":true,"type":MatchUpdateWithoutOfferInput}),
});
export const MatchUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithWhereUniqueWithoutOfferInput>>('MatchUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: MatchUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const MatchUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchScalarWhereInput}),
  data: t.field({"required":true,"type":MatchUpdateManyMutationInput}),
});
export const MatchUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithWhereWithoutOfferInput>>('MatchUpdateManyWithWhereWithoutOfferInput').implement({
  fields: MatchUpdateManyWithWhereWithoutOfferInputFields,
});

export const CandidateUpsertWithWhereUniqueWithoutHiredAtInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateUpdateWithoutHiredAtInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutHiredAtInput}),
});
export const CandidateUpsertWithWhereUniqueWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithWhereUniqueWithoutHiredAtInput>>('CandidateUpsertWithWhereUniqueWithoutHiredAtInput').implement({
  fields: CandidateUpsertWithWhereUniqueWithoutHiredAtInputFields,
});

export const CandidateUpdateWithWhereUniqueWithoutHiredAtInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutHiredAtInput}),
});
export const CandidateUpdateWithWhereUniqueWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithWhereUniqueWithoutHiredAtInput>>('CandidateUpdateWithWhereUniqueWithoutHiredAtInput').implement({
  fields: CandidateUpdateWithWhereUniqueWithoutHiredAtInputFields,
});

export const CandidateUpdateManyWithWhereWithoutHiredAtInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateManyMutationInput}),
});
export const CandidateUpdateManyWithWhereWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateManyWithWhereWithoutHiredAtInput>>('CandidateUpdateManyWithWhereWithoutHiredAtInput').implement({
  fields: CandidateUpdateManyWithWhereWithoutHiredAtInputFields,
});

export const EvaluationUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutOfferInput}),
});
export const EvaluationUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithWhereUniqueWithoutOfferInput>>('EvaluationUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: EvaluationUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const EvaluationUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutOfferInput}),
});
export const EvaluationUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithWhereUniqueWithoutOfferInput>>('EvaluationUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: EvaluationUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const EvaluationUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateManyMutationInput}),
});
export const EvaluationUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithWhereWithoutOfferInput>>('EvaluationUpdateManyWithWhereWithoutOfferInput').implement({
  fields: EvaluationUpdateManyWithWhereWithoutOfferInputFields,
});

export const FollowUpsertWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  update: t.field({"required":true,"type":FollowUpdateWithoutOfferInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutOfferInput}),
});
export const FollowUpsertWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpsertWithWhereUniqueWithoutOfferInput>>('FollowUpsertWithWhereUniqueWithoutOfferInput').implement({
  fields: FollowUpsertWithWhereUniqueWithoutOfferInputFields,
});

export const FollowUpdateWithWhereUniqueWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  data: t.field({"required":true,"type":FollowUpdateWithoutOfferInput}),
});
export const FollowUpdateWithWhereUniqueWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithWhereUniqueWithoutOfferInput>>('FollowUpdateWithWhereUniqueWithoutOfferInput').implement({
  fields: FollowUpdateWithWhereUniqueWithoutOfferInputFields,
});

export const FollowUpdateManyWithWhereWithoutOfferInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowScalarWhereInput}),
  data: t.field({"required":true,"type":FollowUpdateManyMutationInput}),
});
export const FollowUpdateManyWithWhereWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithWhereWithoutOfferInput>>('FollowUpdateManyWithWhereWithoutOfferInput').implement({
  fields: FollowUpdateManyWithWhereWithoutOfferInputFields,
});

export const OfferCreateWithoutFilesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutFilesInput>>('OfferCreateWithoutFilesInput').implement({
  fields: OfferCreateWithoutFilesInputFields,
});

export const OfferCreateOrConnectWithoutFilesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutFilesInput}),
});
export const OfferCreateOrConnectWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutFilesInput>>('OfferCreateOrConnectWithoutFilesInput').implement({
  fields: OfferCreateOrConnectWithoutFilesInputFields,
});

export const AttachmentCreateWithoutOfferFilesInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutOfferFilesInput>>('AttachmentCreateWithoutOfferFilesInput').implement({
  fields: AttachmentCreateWithoutOfferFilesInputFields,
});

export const AttachmentCreateOrConnectWithoutOfferFilesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutOfferFilesInput}),
});
export const AttachmentCreateOrConnectWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutOfferFilesInput>>('AttachmentCreateOrConnectWithoutOfferFilesInput').implement({
  fields: AttachmentCreateOrConnectWithoutOfferFilesInputFields,
});

export const OfferUpsertWithoutFilesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutFilesInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutFilesInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutFilesInput>>('OfferUpsertWithoutFilesInput').implement({
  fields: OfferUpsertWithoutFilesInputFields,
});

export const OfferUpdateToOneWithWhereWithoutFilesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutFilesInput}),
});
export const OfferUpdateToOneWithWhereWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutFilesInput>>('OfferUpdateToOneWithWhereWithoutFilesInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutFilesInputFields,
});

export const OfferUpdateWithoutFilesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutFilesInput>>('OfferUpdateWithoutFilesInput').implement({
  fields: OfferUpdateWithoutFilesInputFields,
});

export const AttachmentUpsertWithoutOfferFilesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutOfferFilesInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutOfferFilesInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutOfferFilesInput>>('AttachmentUpsertWithoutOfferFilesInput').implement({
  fields: AttachmentUpsertWithoutOfferFilesInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutOfferFilesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutOfferFilesInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutOfferFilesInput>>('AttachmentUpdateToOneWithWhereWithoutOfferFilesInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutOfferFilesInputFields,
});

export const AttachmentUpdateWithoutOfferFilesInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutOfferFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutOfferFilesInput>>('AttachmentUpdateWithoutOfferFilesInput').implement({
  fields: AttachmentUpdateWithoutOfferFilesInputFields,
});

export const OfferCreateWithoutMatchesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutMatchesInput>>('OfferCreateWithoutMatchesInput').implement({
  fields: OfferCreateWithoutMatchesInputFields,
});

export const OfferCreateOrConnectWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutMatchesInput}),
});
export const OfferCreateOrConnectWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutMatchesInput>>('OfferCreateOrConnectWithoutMatchesInput').implement({
  fields: OfferCreateOrConnectWithoutMatchesInputFields,
});

export const CandidateCreateWithoutOffersInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutOffersInput>>('CandidateCreateWithoutOffersInput').implement({
  fields: CandidateCreateWithoutOffersInputFields,
});

export const CandidateCreateOrConnectWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutOffersInput}),
});
export const CandidateCreateOrConnectWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutOffersInput>>('CandidateCreateOrConnectWithoutOffersInput').implement({
  fields: CandidateCreateOrConnectWithoutOffersInputFields,
});

export const StageCreateWithoutMatchesInputFields = (t: any) => ({
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
  template: t.field({"required":true,"type":TemplateCreateNestedOneWithoutStagesInput}),
  visibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutStageInput}),
  metadata: t.field({"required":false,"type":StageMetadataCreateNestedManyWithoutStageInput}),
});
export const StageCreateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateWithoutMatchesInput>>('StageCreateWithoutMatchesInput').implement({
  fields: StageCreateWithoutMatchesInputFields,
});

export const StageCreateOrConnectWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  create: t.field({"required":true,"type":StageCreateWithoutMatchesInput}),
});
export const StageCreateOrConnectWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateOrConnectWithoutMatchesInput>>('StageCreateOrConnectWithoutMatchesInput').implement({
  fields: StageCreateOrConnectWithoutMatchesInputFields,
});

export const DisqualifyReasonCreateWithoutMatchesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  action: t.field({"required":true,"type":Json}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutDisqualifyReasonsInput}),
});
export const DisqualifyReasonCreateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateWithoutMatchesInput>>('DisqualifyReasonCreateWithoutMatchesInput').implement({
  fields: DisqualifyReasonCreateWithoutMatchesInputFields,
});

export const DisqualifyReasonCreateOrConnectWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":DisqualifyReasonWhereUniqueInput}),
  create: t.field({"required":true,"type":DisqualifyReasonCreateWithoutMatchesInput}),
});
export const DisqualifyReasonCreateOrConnectWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateOrConnectWithoutMatchesInput>>('DisqualifyReasonCreateOrConnectWithoutMatchesInput').implement({
  fields: DisqualifyReasonCreateOrConnectWithoutMatchesInputFields,
});

export const OfferUpsertWithoutMatchesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutMatchesInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutMatchesInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutMatchesInput>>('OfferUpsertWithoutMatchesInput').implement({
  fields: OfferUpsertWithoutMatchesInputFields,
});

export const OfferUpdateToOneWithWhereWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutMatchesInput}),
});
export const OfferUpdateToOneWithWhereWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutMatchesInput>>('OfferUpdateToOneWithWhereWithoutMatchesInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutMatchesInputFields,
});

export const OfferUpdateWithoutMatchesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutMatchesInput>>('OfferUpdateWithoutMatchesInput').implement({
  fields: OfferUpdateWithoutMatchesInputFields,
});

export const CandidateUpsertWithoutOffersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutOffersInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutOffersInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutOffersInput>>('CandidateUpsertWithoutOffersInput').implement({
  fields: CandidateUpsertWithoutOffersInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutOffersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutOffersInput}),
});
export const CandidateUpdateToOneWithWhereWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutOffersInput>>('CandidateUpdateToOneWithWhereWithoutOffersInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutOffersInputFields,
});

export const CandidateUpdateWithoutOffersInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutOffersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutOffersInput>>('CandidateUpdateWithoutOffersInput').implement({
  fields: CandidateUpdateWithoutOffersInputFields,
});

export const StageUpsertWithoutMatchesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":StageUpdateWithoutMatchesInput}),
  create: t.field({"required":true,"type":StageCreateWithoutMatchesInput}),
  where: t.field({"required":false,"type":StageWhereInput}),
});
export const StageUpsertWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpsertWithoutMatchesInput>>('StageUpsertWithoutMatchesInput').implement({
  fields: StageUpsertWithoutMatchesInputFields,
});

export const StageUpdateToOneWithWhereWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":StageWhereInput}),
  data: t.field({"required":true,"type":StageUpdateWithoutMatchesInput}),
});
export const StageUpdateToOneWithWhereWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateToOneWithWhereWithoutMatchesInput>>('StageUpdateToOneWithWhereWithoutMatchesInput').implement({
  fields: StageUpdateToOneWithWhereWithoutMatchesInputFields,
});

export const StageUpdateWithoutMatchesInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneRequiredWithoutStagesNestedInput}),
  visibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutStageNestedInput}),
  metadata: t.field({"required":false,"type":StageMetadataUpdateManyWithoutStageNestedInput}),
});
export const StageUpdateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateWithoutMatchesInput>>('StageUpdateWithoutMatchesInput').implement({
  fields: StageUpdateWithoutMatchesInputFields,
});

export const DisqualifyReasonUpsertWithoutMatchesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":DisqualifyReasonUpdateWithoutMatchesInput}),
  create: t.field({"required":true,"type":DisqualifyReasonCreateWithoutMatchesInput}),
  where: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
});
export const DisqualifyReasonUpsertWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpsertWithoutMatchesInput>>('DisqualifyReasonUpsertWithoutMatchesInput').implement({
  fields: DisqualifyReasonUpsertWithoutMatchesInputFields,
});

export const DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":DisqualifyReasonWhereInput}),
  data: t.field({"required":true,"type":DisqualifyReasonUpdateWithoutMatchesInput}),
});
export const DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInput>>('DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInput').implement({
  fields: DisqualifyReasonUpdateToOneWithWhereWithoutMatchesInputFields,
});

export const DisqualifyReasonUpdateWithoutMatchesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":Json}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutDisqualifyReasonsNestedInput}),
});
export const DisqualifyReasonUpdateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateWithoutMatchesInput>>('DisqualifyReasonUpdateWithoutMatchesInput').implement({
  fields: DisqualifyReasonUpdateWithoutMatchesInputFields,
});

export const OfferCreateWithoutOfferTagsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutOfferTagsInput>>('OfferCreateWithoutOfferTagsInput').implement({
  fields: OfferCreateWithoutOfferTagsInputFields,
});

export const OfferCreateOrConnectWithoutOfferTagsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutOfferTagsInput}),
});
export const OfferCreateOrConnectWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutOfferTagsInput>>('OfferCreateOrConnectWithoutOfferTagsInput').implement({
  fields: OfferCreateOrConnectWithoutOfferTagsInputFields,
});

export const TagSourceCreateWithoutOfferTagsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTagSourcesInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateCreateNestedManyWithoutReferrerInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutTagInput}),
});
export const TagSourceCreateWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateWithoutOfferTagsInput>>('TagSourceCreateWithoutOfferTagsInput').implement({
  fields: TagSourceCreateWithoutOfferTagsInputFields,
});

export const TagSourceCreateOrConnectWithoutOfferTagsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutOfferTagsInput}),
});
export const TagSourceCreateOrConnectWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateOrConnectWithoutOfferTagsInput>>('TagSourceCreateOrConnectWithoutOfferTagsInput').implement({
  fields: TagSourceCreateOrConnectWithoutOfferTagsInputFields,
});

export const OfferUpsertWithoutOfferTagsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutOfferTagsInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutOfferTagsInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutOfferTagsInput>>('OfferUpsertWithoutOfferTagsInput').implement({
  fields: OfferUpsertWithoutOfferTagsInputFields,
});

export const OfferUpdateToOneWithWhereWithoutOfferTagsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutOfferTagsInput}),
});
export const OfferUpdateToOneWithWhereWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutOfferTagsInput>>('OfferUpdateToOneWithWhereWithoutOfferTagsInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutOfferTagsInputFields,
});

export const OfferUpdateWithoutOfferTagsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutOfferTagsInput>>('OfferUpdateWithoutOfferTagsInput').implement({
  fields: OfferUpdateWithoutOfferTagsInputFields,
});

export const TagSourceUpsertWithoutOfferTagsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TagSourceUpdateWithoutOfferTagsInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutOfferTagsInput}),
  where: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceUpsertWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpsertWithoutOfferTagsInput>>('TagSourceUpsertWithoutOfferTagsInput').implement({
  fields: TagSourceUpsertWithoutOfferTagsInputFields,
});

export const TagSourceUpdateToOneWithWhereWithoutOfferTagsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TagSourceWhereInput}),
  data: t.field({"required":true,"type":TagSourceUpdateWithoutOfferTagsInput}),
});
export const TagSourceUpdateToOneWithWhereWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateToOneWithWhereWithoutOfferTagsInput>>('TagSourceUpdateToOneWithWhereWithoutOfferTagsInput').implement({
  fields: TagSourceUpdateToOneWithWhereWithoutOfferTagsInputFields,
});

export const TagSourceUpdateWithoutOfferTagsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTagSourcesNestedInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateUpdateManyWithoutReferrerNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutTagNestedInput}),
});
export const TagSourceUpdateWithoutOfferTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateWithoutOfferTagsInput>>('TagSourceUpdateWithoutOfferTagsInput').implement({
  fields: TagSourceUpdateWithoutOfferTagsInputFields,
});

export const HiringRoleCreateWithoutMembershipsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutMembershipsInput>>('HiringRoleCreateWithoutMembershipsInput').implement({
  fields: HiringRoleCreateWithoutMembershipsInputFields,
});

export const HiringRoleCreateOrConnectWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutMembershipsInput}),
});
export const HiringRoleCreateOrConnectWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutMembershipsInput>>('HiringRoleCreateOrConnectWithoutMembershipsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutMembershipsInputFields,
});

export const RoleCreateWithoutMembershipsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutRolesInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutRoleInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutRoleInput}),
});
export const RoleCreateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateWithoutMembershipsInput>>('RoleCreateWithoutMembershipsInput').implement({
  fields: RoleCreateWithoutMembershipsInputFields,
});

export const RoleCreateOrConnectWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutMembershipsInput}),
});
export const RoleCreateOrConnectWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateOrConnectWithoutMembershipsInput>>('RoleCreateOrConnectWithoutMembershipsInput').implement({
  fields: RoleCreateOrConnectWithoutMembershipsInputFields,
});

export const OfferCreateWithoutMembershipsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutMembershipsInput>>('OfferCreateWithoutMembershipsInput').implement({
  fields: OfferCreateWithoutMembershipsInputFields,
});

export const OfferCreateOrConnectWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutMembershipsInput}),
});
export const OfferCreateOrConnectWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutMembershipsInput>>('OfferCreateOrConnectWithoutMembershipsInput').implement({
  fields: OfferCreateOrConnectWithoutMembershipsInputFields,
});

export const HiringRoleUpsertWithoutMembershipsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutMembershipsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutMembershipsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutMembershipsInput>>('HiringRoleUpsertWithoutMembershipsInput').implement({
  fields: HiringRoleUpsertWithoutMembershipsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutMembershipsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutMembershipsInput>>('HiringRoleUpdateToOneWithWhereWithoutMembershipsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutMembershipsInputFields,
});

export const HiringRoleUpdateWithoutMembershipsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutMembershipsInput>>('HiringRoleUpdateWithoutMembershipsInput').implement({
  fields: HiringRoleUpdateWithoutMembershipsInputFields,
});

export const RoleUpsertWithoutMembershipsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":RoleUpdateWithoutMembershipsInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutMembershipsInput}),
  where: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleUpsertWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpsertWithoutMembershipsInput>>('RoleUpsertWithoutMembershipsInput').implement({
  fields: RoleUpsertWithoutMembershipsInputFields,
});

export const RoleUpdateToOneWithWhereWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":RoleWhereInput}),
  data: t.field({"required":true,"type":RoleUpdateWithoutMembershipsInput}),
});
export const RoleUpdateToOneWithWhereWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateToOneWithWhereWithoutMembershipsInput>>('RoleUpdateToOneWithWhereWithoutMembershipsInput').implement({
  fields: RoleUpdateToOneWithWhereWithoutMembershipsInputFields,
});

export const RoleUpdateWithoutMembershipsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutRolesNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutRoleNestedInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutRoleNestedInput}),
});
export const RoleUpdateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateWithoutMembershipsInput>>('RoleUpdateWithoutMembershipsInput').implement({
  fields: RoleUpdateWithoutMembershipsInputFields,
});

export const OfferUpsertWithoutMembershipsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutMembershipsInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutMembershipsInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutMembershipsInput>>('OfferUpsertWithoutMembershipsInput').implement({
  fields: OfferUpsertWithoutMembershipsInputFields,
});

export const OfferUpdateToOneWithWhereWithoutMembershipsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutMembershipsInput}),
});
export const OfferUpdateToOneWithWhereWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutMembershipsInput>>('OfferUpdateToOneWithWhereWithoutMembershipsInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutMembershipsInputFields,
});

export const OfferUpdateWithoutMembershipsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutMembershipsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutMembershipsInput>>('OfferUpdateWithoutMembershipsInput').implement({
  fields: OfferUpdateWithoutMembershipsInputFields,
});

export const TalentPoolFileCreateWithoutTalentPoolInputFields = (t: any) => ({
  attachment: t.field({"required":true,"type":AttachmentCreateNestedOneWithoutTalentPoolFilesInput}),
});
export const TalentPoolFileCreateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateWithoutTalentPoolInput>>('TalentPoolFileCreateWithoutTalentPoolInput').implement({
  fields: TalentPoolFileCreateWithoutTalentPoolInputFields,
});

export const TalentPoolFileCreateOrConnectWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolFileCreateWithoutTalentPoolInput}),
});
export const TalentPoolFileCreateOrConnectWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateOrConnectWithoutTalentPoolInput>>('TalentPoolFileCreateOrConnectWithoutTalentPoolInput').implement({
  fields: TalentPoolFileCreateOrConnectWithoutTalentPoolInputFields,
});

export const TalentPoolFileCreateManyTalentPoolInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TalentPoolFileCreateManyTalentPoolInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TalentPoolFileCreateManyTalentPoolInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateManyTalentPoolInputEnvelope>>('TalentPoolFileCreateManyTalentPoolInputEnvelope').implement({
  fields: TalentPoolFileCreateManyTalentPoolInputEnvelopeFields,
});

export const TalentPoolMatchCreateWithoutTalentPoolInputFields = (t: any) => ({
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutTalentPoolsInput}),
});
export const TalentPoolMatchCreateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateWithoutTalentPoolInput>>('TalentPoolMatchCreateWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchCreateWithoutTalentPoolInputFields,
});

export const TalentPoolMatchCreateOrConnectWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolMatchCreateWithoutTalentPoolInput}),
});
export const TalentPoolMatchCreateOrConnectWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateOrConnectWithoutTalentPoolInput>>('TalentPoolMatchCreateOrConnectWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchCreateOrConnectWithoutTalentPoolInputFields,
});

export const TalentPoolMatchCreateManyTalentPoolInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TalentPoolMatchCreateManyTalentPoolInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TalentPoolMatchCreateManyTalentPoolInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateManyTalentPoolInputEnvelope>>('TalentPoolMatchCreateManyTalentPoolInputEnvelope').implement({
  fields: TalentPoolMatchCreateManyTalentPoolInputEnvelopeFields,
});

export const FollowCreateWithoutTalentPoolInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutFollowsInput}),
  candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutFollowsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutFollowsInput}),
});
export const FollowCreateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateWithoutTalentPoolInput>>('FollowCreateWithoutTalentPoolInput').implement({
  fields: FollowCreateWithoutTalentPoolInputFields,
});

export const FollowCreateOrConnectWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutTalentPoolInput}),
});
export const FollowCreateOrConnectWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateOrConnectWithoutTalentPoolInput>>('FollowCreateOrConnectWithoutTalentPoolInput').implement({
  fields: FollowCreateOrConnectWithoutTalentPoolInputFields,
});

export const FollowCreateManyTalentPoolInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[FollowCreateManyTalentPoolInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const FollowCreateManyTalentPoolInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyTalentPoolInputEnvelope>>('FollowCreateManyTalentPoolInputEnvelope').implement({
  fields: FollowCreateManyTalentPoolInputEnvelopeFields,
});

export const CompanyCreateWithoutTalentPoolInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutTalentPoolInput>>('CompanyCreateWithoutTalentPoolInput').implement({
  fields: CompanyCreateWithoutTalentPoolInputFields,
});

export const CompanyCreateOrConnectWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTalentPoolInput}),
});
export const CompanyCreateOrConnectWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutTalentPoolInput>>('CompanyCreateOrConnectWithoutTalentPoolInput').implement({
  fields: CompanyCreateOrConnectWithoutTalentPoolInputFields,
});

export const TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  update: t.field({"required":true,"type":TalentPoolFileUpdateWithoutTalentPoolInput}),
  create: t.field({"required":true,"type":TalentPoolFileCreateWithoutTalentPoolInput}),
});
export const TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInput>>('TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: TalentPoolFileUpsertWithWhereUniqueWithoutTalentPoolInputFields,
});

export const TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileWhereUniqueInput}),
  data: t.field({"required":true,"type":TalentPoolFileUpdateWithoutTalentPoolInput}),
});
export const TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInput>>('TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: TalentPoolFileUpdateWithWhereUniqueWithoutTalentPoolInputFields,
});

export const TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolFileScalarWhereInput}),
  data: t.field({"required":true,"type":TalentPoolFileUpdateManyMutationInput}),
});
export const TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInput>>('TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInput').implement({
  fields: TalentPoolFileUpdateManyWithWhereWithoutTalentPoolInputFields,
});

export const TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  update: t.field({"required":true,"type":TalentPoolMatchUpdateWithoutTalentPoolInput}),
  create: t.field({"required":true,"type":TalentPoolMatchCreateWithoutTalentPoolInput}),
});
export const TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInput>>('TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchUpsertWithWhereUniqueWithoutTalentPoolInputFields,
});

export const TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  data: t.field({"required":true,"type":TalentPoolMatchUpdateWithoutTalentPoolInput}),
});
export const TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInput>>('TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchUpdateWithWhereUniqueWithoutTalentPoolInputFields,
});

export const TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchScalarWhereInput}),
  data: t.field({"required":true,"type":TalentPoolMatchUpdateManyMutationInput}),
});
export const TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInput>>('TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchUpdateManyWithWhereWithoutTalentPoolInputFields,
});

export const TalentPoolMatchScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[TalentPoolMatchScalarWhereInput]}),
  OR: t.field({"required":false,"type":[TalentPoolMatchScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[TalentPoolMatchScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  talentPoolId: t.field({"required":false,"type":IntFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
});
export const TalentPoolMatchScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchScalarWhereInput>>('TalentPoolMatchScalarWhereInput').implement({
  fields: TalentPoolMatchScalarWhereInputFields,
});

export const FollowUpsertWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  update: t.field({"required":true,"type":FollowUpdateWithoutTalentPoolInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutTalentPoolInput}),
});
export const FollowUpsertWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpsertWithWhereUniqueWithoutTalentPoolInput>>('FollowUpsertWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: FollowUpsertWithWhereUniqueWithoutTalentPoolInputFields,
});

export const FollowUpdateWithWhereUniqueWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  data: t.field({"required":true,"type":FollowUpdateWithoutTalentPoolInput}),
});
export const FollowUpdateWithWhereUniqueWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithWhereUniqueWithoutTalentPoolInput>>('FollowUpdateWithWhereUniqueWithoutTalentPoolInput').implement({
  fields: FollowUpdateWithWhereUniqueWithoutTalentPoolInputFields,
});

export const FollowUpdateManyWithWhereWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowScalarWhereInput}),
  data: t.field({"required":true,"type":FollowUpdateManyMutationInput}),
});
export const FollowUpdateManyWithWhereWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithWhereWithoutTalentPoolInput>>('FollowUpdateManyWithWhereWithoutTalentPoolInput').implement({
  fields: FollowUpdateManyWithWhereWithoutTalentPoolInputFields,
});

export const CompanyUpsertWithoutTalentPoolInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutTalentPoolInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTalentPoolInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutTalentPoolInput>>('CompanyUpsertWithoutTalentPoolInput').implement({
  fields: CompanyUpsertWithoutTalentPoolInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutTalentPoolInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutTalentPoolInput}),
});
export const CompanyUpdateToOneWithWhereWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutTalentPoolInput>>('CompanyUpdateToOneWithWhereWithoutTalentPoolInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutTalentPoolInputFields,
});

export const CompanyUpdateWithoutTalentPoolInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutTalentPoolInput>>('CompanyUpdateWithoutTalentPoolInput').implement({
  fields: CompanyUpdateWithoutTalentPoolInputFields,
});

export const TalentPoolCreateWithoutFilesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  matches: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutTalentPoolInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTalentPoolInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTalentPoolInput}),
});
export const TalentPoolCreateWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateWithoutFilesInput>>('TalentPoolCreateWithoutFilesInput').implement({
  fields: TalentPoolCreateWithoutFilesInputFields,
});

export const TalentPoolCreateOrConnectWithoutFilesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutFilesInput}),
});
export const TalentPoolCreateOrConnectWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateOrConnectWithoutFilesInput>>('TalentPoolCreateOrConnectWithoutFilesInput').implement({
  fields: TalentPoolCreateOrConnectWithoutFilesInputFields,
});

export const AttachmentCreateWithoutTalentPoolFilesInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutTalentPoolFilesInput>>('AttachmentCreateWithoutTalentPoolFilesInput').implement({
  fields: AttachmentCreateWithoutTalentPoolFilesInputFields,
});

export const AttachmentCreateOrConnectWithoutTalentPoolFilesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutTalentPoolFilesInput}),
});
export const AttachmentCreateOrConnectWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutTalentPoolFilesInput>>('AttachmentCreateOrConnectWithoutTalentPoolFilesInput').implement({
  fields: AttachmentCreateOrConnectWithoutTalentPoolFilesInputFields,
});

export const TalentPoolUpsertWithoutFilesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TalentPoolUpdateWithoutFilesInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutFilesInput}),
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolUpsertWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpsertWithoutFilesInput>>('TalentPoolUpsertWithoutFilesInput').implement({
  fields: TalentPoolUpsertWithoutFilesInputFields,
});

export const TalentPoolUpdateToOneWithWhereWithoutFilesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
  data: t.field({"required":true,"type":TalentPoolUpdateWithoutFilesInput}),
});
export const TalentPoolUpdateToOneWithWhereWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateToOneWithWhereWithoutFilesInput>>('TalentPoolUpdateToOneWithWhereWithoutFilesInput').implement({
  fields: TalentPoolUpdateToOneWithWhereWithoutFilesInputFields,
});

export const TalentPoolUpdateWithoutFilesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTalentPoolNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTalentPoolNestedInput}),
});
export const TalentPoolUpdateWithoutFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateWithoutFilesInput>>('TalentPoolUpdateWithoutFilesInput').implement({
  fields: TalentPoolUpdateWithoutFilesInputFields,
});

export const AttachmentUpsertWithoutTalentPoolFilesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutTalentPoolFilesInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutTalentPoolFilesInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutTalentPoolFilesInput>>('AttachmentUpsertWithoutTalentPoolFilesInput').implement({
  fields: AttachmentUpsertWithoutTalentPoolFilesInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutTalentPoolFilesInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInput>>('AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutTalentPoolFilesInputFields,
});

export const AttachmentUpdateWithoutTalentPoolFilesInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutTalentPoolFilesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutTalentPoolFilesInput>>('AttachmentUpdateWithoutTalentPoolFilesInput').implement({
  fields: AttachmentUpdateWithoutTalentPoolFilesInputFields,
});

export const TalentPoolCreateWithoutMatchesInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  files: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutTalentPoolInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTalentPoolInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTalentPoolInput}),
});
export const TalentPoolCreateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateWithoutMatchesInput>>('TalentPoolCreateWithoutMatchesInput').implement({
  fields: TalentPoolCreateWithoutMatchesInputFields,
});

export const TalentPoolCreateOrConnectWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutMatchesInput}),
});
export const TalentPoolCreateOrConnectWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateOrConnectWithoutMatchesInput>>('TalentPoolCreateOrConnectWithoutMatchesInput').implement({
  fields: TalentPoolCreateOrConnectWithoutMatchesInputFields,
});

export const CandidateCreateWithoutTalentPoolsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutTalentPoolsInput>>('CandidateCreateWithoutTalentPoolsInput').implement({
  fields: CandidateCreateWithoutTalentPoolsInputFields,
});

export const CandidateCreateOrConnectWithoutTalentPoolsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutTalentPoolsInput}),
});
export const CandidateCreateOrConnectWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutTalentPoolsInput>>('CandidateCreateOrConnectWithoutTalentPoolsInput').implement({
  fields: CandidateCreateOrConnectWithoutTalentPoolsInputFields,
});

export const TalentPoolUpsertWithoutMatchesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TalentPoolUpdateWithoutMatchesInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutMatchesInput}),
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolUpsertWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpsertWithoutMatchesInput>>('TalentPoolUpsertWithoutMatchesInput').implement({
  fields: TalentPoolUpsertWithoutMatchesInputFields,
});

export const TalentPoolUpdateToOneWithWhereWithoutMatchesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
  data: t.field({"required":true,"type":TalentPoolUpdateWithoutMatchesInput}),
});
export const TalentPoolUpdateToOneWithWhereWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateToOneWithWhereWithoutMatchesInput>>('TalentPoolUpdateToOneWithWhereWithoutMatchesInput').implement({
  fields: TalentPoolUpdateToOneWithWhereWithoutMatchesInputFields,
});

export const TalentPoolUpdateWithoutMatchesInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  files: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutTalentPoolNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTalentPoolNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTalentPoolNestedInput}),
});
export const TalentPoolUpdateWithoutMatchesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateWithoutMatchesInput>>('TalentPoolUpdateWithoutMatchesInput').implement({
  fields: TalentPoolUpdateWithoutMatchesInputFields,
});

export const CandidateUpsertWithoutTalentPoolsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutTalentPoolsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutTalentPoolsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutTalentPoolsInput>>('CandidateUpsertWithoutTalentPoolsInput').implement({
  fields: CandidateUpsertWithoutTalentPoolsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutTalentPoolsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutTalentPoolsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutTalentPoolsInput>>('CandidateUpdateToOneWithWhereWithoutTalentPoolsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutTalentPoolsInputFields,
});

export const CandidateUpdateWithoutTalentPoolsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutTalentPoolsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutTalentPoolsInput>>('CandidateUpdateWithoutTalentPoolsInput').implement({
  fields: CandidateUpdateWithoutTalentPoolsInputFields,
});

export const CompanyCreateWithoutTemplatesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutTemplatesInput>>('CompanyCreateWithoutTemplatesInput').implement({
  fields: CompanyCreateWithoutTemplatesInputFields,
});

export const CompanyCreateOrConnectWithoutTemplatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTemplatesInput}),
});
export const CompanyCreateOrConnectWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutTemplatesInput>>('CompanyCreateOrConnectWithoutTemplatesInput').implement({
  fields: CompanyCreateOrConnectWithoutTemplatesInputFields,
});

export const OfferCreateWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutScreeningQuestionsTemplateInput>>('OfferCreateWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferCreateWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferCreateOrConnectWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutScreeningQuestionsTemplateInput}),
});
export const OfferCreateOrConnectWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutScreeningQuestionsTemplateInput>>('OfferCreateOrConnectWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferCreateOrConnectWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferCreateManyScreeningQuestionsTemplateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferCreateManyScreeningQuestionsTemplateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferCreateManyScreeningQuestionsTemplateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyScreeningQuestionsTemplateInputEnvelope>>('OfferCreateManyScreeningQuestionsTemplateInputEnvelope').implement({
  fields: OfferCreateManyScreeningQuestionsTemplateInputEnvelopeFields,
});

export const OfferCreateWithoutPipelineTemplateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutPipelineTemplateInput>>('OfferCreateWithoutPipelineTemplateInput').implement({
  fields: OfferCreateWithoutPipelineTemplateInputFields,
});

export const OfferCreateOrConnectWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutPipelineTemplateInput}),
});
export const OfferCreateOrConnectWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutPipelineTemplateInput>>('OfferCreateOrConnectWithoutPipelineTemplateInput').implement({
  fields: OfferCreateOrConnectWithoutPipelineTemplateInputFields,
});

export const OfferCreateManyPipelineTemplateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferCreateManyPipelineTemplateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferCreateManyPipelineTemplateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyPipelineTemplateInputEnvelope>>('OfferCreateManyPipelineTemplateInputEnvelope').implement({
  fields: OfferCreateManyPipelineTemplateInputEnvelopeFields,
});

export const OfferCreateWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutAutoConfirmationEmailInput>>('OfferCreateWithoutAutoConfirmationEmailInput').implement({
  fields: OfferCreateWithoutAutoConfirmationEmailInputFields,
});

export const OfferCreateOrConnectWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutAutoConfirmationEmailInput}),
});
export const OfferCreateOrConnectWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutAutoConfirmationEmailInput>>('OfferCreateOrConnectWithoutAutoConfirmationEmailInput').implement({
  fields: OfferCreateOrConnectWithoutAutoConfirmationEmailInputFields,
});

export const OfferCreateManyAutoConfirmationEmailInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[OfferCreateManyAutoConfirmationEmailInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const OfferCreateManyAutoConfirmationEmailInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyAutoConfirmationEmailInputEnvelope>>('OfferCreateManyAutoConfirmationEmailInputEnvelope').implement({
  fields: OfferCreateManyAutoConfirmationEmailInputEnvelopeFields,
});

export const StageCreateWithoutTemplateInputFields = (t: any) => ({
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutStageInput}),
  visibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutStageInput}),
  metadata: t.field({"required":false,"type":StageMetadataCreateNestedManyWithoutStageInput}),
});
export const StageCreateWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateWithoutTemplateInput>>('StageCreateWithoutTemplateInput').implement({
  fields: StageCreateWithoutTemplateInputFields,
});

export const StageCreateOrConnectWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  create: t.field({"required":true,"type":StageCreateWithoutTemplateInput}),
});
export const StageCreateOrConnectWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateOrConnectWithoutTemplateInput>>('StageCreateOrConnectWithoutTemplateInput').implement({
  fields: StageCreateOrConnectWithoutTemplateInputFields,
});

export const StageCreateManyTemplateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[StageCreateManyTemplateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const StageCreateManyTemplateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateManyTemplateInputEnvelope>>('StageCreateManyTemplateInputEnvelope').implement({
  fields: StageCreateManyTemplateInputEnvelopeFields,
});

export const EvaluationCreateWithoutTemplateInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutTemplateInput>>('EvaluationCreateWithoutTemplateInput').implement({
  fields: EvaluationCreateWithoutTemplateInputFields,
});

export const EvaluationCreateOrConnectWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutTemplateInput}),
});
export const EvaluationCreateOrConnectWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutTemplateInput>>('EvaluationCreateOrConnectWithoutTemplateInput').implement({
  fields: EvaluationCreateOrConnectWithoutTemplateInputFields,
});

export const EvaluationCreateManyTemplateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationCreateManyTemplateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationCreateManyTemplateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyTemplateInputEnvelope>>('EvaluationCreateManyTemplateInputEnvelope').implement({
  fields: EvaluationCreateManyTemplateInputEnvelopeFields,
});

export const CompanyUpsertWithoutTemplatesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutTemplatesInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTemplatesInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutTemplatesInput>>('CompanyUpsertWithoutTemplatesInput').implement({
  fields: CompanyUpsertWithoutTemplatesInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutTemplatesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutTemplatesInput}),
});
export const CompanyUpdateToOneWithWhereWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutTemplatesInput>>('CompanyUpdateToOneWithWhereWithoutTemplatesInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutTemplatesInputFields,
});

export const CompanyUpdateWithoutTemplatesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutTemplatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutTemplatesInput>>('CompanyUpdateWithoutTemplatesInput').implement({
  fields: CompanyUpdateWithoutTemplatesInputFields,
});

export const OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferUpdateWithoutScreeningQuestionsTemplateInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutScreeningQuestionsTemplateInput}),
});
export const OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInput>>('OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferUpsertWithWhereUniqueWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutScreeningQuestionsTemplateInput}),
});
export const OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInput>>('OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferUpdateWithWhereUniqueWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferScalarWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateManyMutationInput}),
});
export const OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInput>>('OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferUpdateManyWithWhereWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferUpsertWithWhereUniqueWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferUpdateWithoutPipelineTemplateInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutPipelineTemplateInput}),
});
export const OfferUpsertWithWhereUniqueWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithWhereUniqueWithoutPipelineTemplateInput>>('OfferUpsertWithWhereUniqueWithoutPipelineTemplateInput').implement({
  fields: OfferUpsertWithWhereUniqueWithoutPipelineTemplateInputFields,
});

export const OfferUpdateWithWhereUniqueWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutPipelineTemplateInput}),
});
export const OfferUpdateWithWhereUniqueWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithWhereUniqueWithoutPipelineTemplateInput>>('OfferUpdateWithWhereUniqueWithoutPipelineTemplateInput').implement({
  fields: OfferUpdateWithWhereUniqueWithoutPipelineTemplateInputFields,
});

export const OfferUpdateManyWithWhereWithoutPipelineTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferScalarWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateManyMutationInput}),
});
export const OfferUpdateManyWithWhereWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithWhereWithoutPipelineTemplateInput>>('OfferUpdateManyWithWhereWithoutPipelineTemplateInput').implement({
  fields: OfferUpdateManyWithWhereWithoutPipelineTemplateInputFields,
});

export const OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  update: t.field({"required":true,"type":OfferUpdateWithoutAutoConfirmationEmailInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutAutoConfirmationEmailInput}),
});
export const OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInput>>('OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInput').implement({
  fields: OfferUpsertWithWhereUniqueWithoutAutoConfirmationEmailInputFields,
});

export const OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutAutoConfirmationEmailInput}),
});
export const OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInput>>('OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInput').implement({
  fields: OfferUpdateWithWhereUniqueWithoutAutoConfirmationEmailInputFields,
});

export const OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferScalarWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateManyMutationInput}),
});
export const OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInput>>('OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInput').implement({
  fields: OfferUpdateManyWithWhereWithoutAutoConfirmationEmailInputFields,
});

export const StageUpsertWithWhereUniqueWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  update: t.field({"required":true,"type":StageUpdateWithoutTemplateInput}),
  create: t.field({"required":true,"type":StageCreateWithoutTemplateInput}),
});
export const StageUpsertWithWhereUniqueWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpsertWithWhereUniqueWithoutTemplateInput>>('StageUpsertWithWhereUniqueWithoutTemplateInput').implement({
  fields: StageUpsertWithWhereUniqueWithoutTemplateInputFields,
});

export const StageUpdateWithWhereUniqueWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  data: t.field({"required":true,"type":StageUpdateWithoutTemplateInput}),
});
export const StageUpdateWithWhereUniqueWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateWithWhereUniqueWithoutTemplateInput>>('StageUpdateWithWhereUniqueWithoutTemplateInput').implement({
  fields: StageUpdateWithWhereUniqueWithoutTemplateInputFields,
});

export const StageUpdateManyWithWhereWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageScalarWhereInput}),
  data: t.field({"required":true,"type":StageUpdateManyMutationInput}),
});
export const StageUpdateManyWithWhereWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateManyWithWhereWithoutTemplateInput>>('StageUpdateManyWithWhereWithoutTemplateInput').implement({
  fields: StageUpdateManyWithWhereWithoutTemplateInputFields,
});

export const StageScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageScalarWhereInput]}),
  OR: t.field({"required":false,"type":[StageScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[StageScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  position: t.field({"required":false,"type":IntNullableFilter}),
  category: t.field({"required":false,"type":StringFilter}),
  inputType: t.field({"required":false,"type":StringNullableFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
  templateId: t.field({"required":false,"type":IntFilter}),
  isProtected: t.field({"required":false,"type":BoolNullableFilter}),
});
export const StageScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageScalarWhereInput>>('StageScalarWhereInput').implement({
  fields: StageScalarWhereInputFields,
});

export const EvaluationUpsertWithWhereUniqueWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationUpdateWithoutTemplateInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutTemplateInput}),
});
export const EvaluationUpsertWithWhereUniqueWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithWhereUniqueWithoutTemplateInput>>('EvaluationUpsertWithWhereUniqueWithoutTemplateInput').implement({
  fields: EvaluationUpsertWithWhereUniqueWithoutTemplateInputFields,
});

export const EvaluationUpdateWithWhereUniqueWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutTemplateInput}),
});
export const EvaluationUpdateWithWhereUniqueWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithWhereUniqueWithoutTemplateInput>>('EvaluationUpdateWithWhereUniqueWithoutTemplateInput').implement({
  fields: EvaluationUpdateWithWhereUniqueWithoutTemplateInputFields,
});

export const EvaluationUpdateManyWithWhereWithoutTemplateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateManyMutationInput}),
});
export const EvaluationUpdateManyWithWhereWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithWhereWithoutTemplateInput>>('EvaluationUpdateManyWithWhereWithoutTemplateInput').implement({
  fields: EvaluationUpdateManyWithWhereWithoutTemplateInputFields,
});

export const TemplateCreateWithoutStagesInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutStagesInput>>('TemplateCreateWithoutStagesInput').implement({
  fields: TemplateCreateWithoutStagesInputFields,
});

export const TemplateCreateOrConnectWithoutStagesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutStagesInput}),
});
export const TemplateCreateOrConnectWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutStagesInput>>('TemplateCreateOrConnectWithoutStagesInput').implement({
  fields: TemplateCreateOrConnectWithoutStagesInputFields,
});

export const MatchCreateWithoutStageInputFields = (t: any) => ({
  isHired: t.boolean({"required":false}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMatchesInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutOffersInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonCreateNestedOneWithoutMatchesInput}),
});
export const MatchCreateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateWithoutStageInput>>('MatchCreateWithoutStageInput').implement({
  fields: MatchCreateWithoutStageInputFields,
});

export const MatchCreateOrConnectWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutStageInput}),
});
export const MatchCreateOrConnectWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateOrConnectWithoutStageInput>>('MatchCreateOrConnectWithoutStageInput').implement({
  fields: MatchCreateOrConnectWithoutStageInputFields,
});

export const MatchCreateManyStageInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MatchCreateManyStageInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MatchCreateManyStageInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyStageInputEnvelope>>('MatchCreateManyStageInputEnvelope').implement({
  fields: MatchCreateManyStageInputEnvelopeFields,
});

export const StageVisibilityCreateWithoutStageInputFields = (t: any) => ({
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMember: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutStageVisibilitiesInput}),
  role: t.field({"required":false,"type":RoleCreateNestedOneWithoutStageVisibilityInput}),
});
export const StageVisibilityCreateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateWithoutStageInput>>('StageVisibilityCreateWithoutStageInput').implement({
  fields: StageVisibilityCreateWithoutStageInputFields,
});

export const StageVisibilityCreateOrConnectWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutStageInput}),
});
export const StageVisibilityCreateOrConnectWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateOrConnectWithoutStageInput>>('StageVisibilityCreateOrConnectWithoutStageInput').implement({
  fields: StageVisibilityCreateOrConnectWithoutStageInputFields,
});

export const StageVisibilityCreateManyStageInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[StageVisibilityCreateManyStageInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const StageVisibilityCreateManyStageInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyStageInputEnvelope>>('StageVisibilityCreateManyStageInputEnvelope').implement({
  fields: StageVisibilityCreateManyStageInputEnvelopeFields,
});

export const StageMetadataCreateWithoutStageInputFields = (t: any) => ({
  metaKey: t.string({"required":true}),
  metaValue: t.string({"required":true}),
});
export const StageMetadataCreateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateWithoutStageInput>>('StageMetadataCreateWithoutStageInput').implement({
  fields: StageMetadataCreateWithoutStageInputFields,
});

export const StageMetadataCreateOrConnectWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageMetadataWhereUniqueInput}),
  create: t.field({"required":true,"type":StageMetadataCreateWithoutStageInput}),
});
export const StageMetadataCreateOrConnectWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateOrConnectWithoutStageInput>>('StageMetadataCreateOrConnectWithoutStageInput').implement({
  fields: StageMetadataCreateOrConnectWithoutStageInputFields,
});

export const StageMetadataCreateManyStageInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[StageMetadataCreateManyStageInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const StageMetadataCreateManyStageInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateManyStageInputEnvelope>>('StageMetadataCreateManyStageInputEnvelope').implement({
  fields: StageMetadataCreateManyStageInputEnvelopeFields,
});

export const TemplateUpsertWithoutStagesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TemplateUpdateWithoutStagesInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutStagesInput}),
  where: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateUpsertWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithoutStagesInput>>('TemplateUpsertWithoutStagesInput').implement({
  fields: TemplateUpsertWithoutStagesInputFields,
});

export const TemplateUpdateToOneWithWhereWithoutStagesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TemplateWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutStagesInput}),
});
export const TemplateUpdateToOneWithWhereWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateToOneWithWhereWithoutStagesInput>>('TemplateUpdateToOneWithWhereWithoutStagesInput').implement({
  fields: TemplateUpdateToOneWithWhereWithoutStagesInputFields,
});

export const TemplateUpdateWithoutStagesInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutStagesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutStagesInput>>('TemplateUpdateWithoutStagesInput').implement({
  fields: TemplateUpdateWithoutStagesInputFields,
});

export const MatchUpsertWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  update: t.field({"required":true,"type":MatchUpdateWithoutStageInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutStageInput}),
});
export const MatchUpsertWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpsertWithWhereUniqueWithoutStageInput>>('MatchUpsertWithWhereUniqueWithoutStageInput').implement({
  fields: MatchUpsertWithWhereUniqueWithoutStageInputFields,
});

export const MatchUpdateWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  data: t.field({"required":true,"type":MatchUpdateWithoutStageInput}),
});
export const MatchUpdateWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithWhereUniqueWithoutStageInput>>('MatchUpdateWithWhereUniqueWithoutStageInput').implement({
  fields: MatchUpdateWithWhereUniqueWithoutStageInputFields,
});

export const MatchUpdateManyWithWhereWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchScalarWhereInput}),
  data: t.field({"required":true,"type":MatchUpdateManyMutationInput}),
});
export const MatchUpdateManyWithWhereWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithWhereWithoutStageInput>>('MatchUpdateManyWithWhereWithoutStageInput').implement({
  fields: MatchUpdateManyWithWhereWithoutStageInputFields,
});

export const StageVisibilityUpsertWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  update: t.field({"required":true,"type":StageVisibilityUpdateWithoutStageInput}),
  create: t.field({"required":true,"type":StageVisibilityCreateWithoutStageInput}),
});
export const StageVisibilityUpsertWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpsertWithWhereUniqueWithoutStageInput>>('StageVisibilityUpsertWithWhereUniqueWithoutStageInput').implement({
  fields: StageVisibilityUpsertWithWhereUniqueWithoutStageInputFields,
});

export const StageVisibilityUpdateWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityWhereUniqueInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateWithoutStageInput}),
});
export const StageVisibilityUpdateWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithWhereUniqueWithoutStageInput>>('StageVisibilityUpdateWithWhereUniqueWithoutStageInput').implement({
  fields: StageVisibilityUpdateWithWhereUniqueWithoutStageInputFields,
});

export const StageVisibilityUpdateManyWithWhereWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageVisibilityScalarWhereInput}),
  data: t.field({"required":true,"type":StageVisibilityUpdateManyMutationInput}),
});
export const StageVisibilityUpdateManyWithWhereWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateManyWithWhereWithoutStageInput>>('StageVisibilityUpdateManyWithWhereWithoutStageInput').implement({
  fields: StageVisibilityUpdateManyWithWhereWithoutStageInputFields,
});

export const StageMetadataUpsertWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageMetadataWhereUniqueInput}),
  update: t.field({"required":true,"type":StageMetadataUpdateWithoutStageInput}),
  create: t.field({"required":true,"type":StageMetadataCreateWithoutStageInput}),
});
export const StageMetadataUpsertWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpsertWithWhereUniqueWithoutStageInput>>('StageMetadataUpsertWithWhereUniqueWithoutStageInput').implement({
  fields: StageMetadataUpsertWithWhereUniqueWithoutStageInputFields,
});

export const StageMetadataUpdateWithWhereUniqueWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageMetadataWhereUniqueInput}),
  data: t.field({"required":true,"type":StageMetadataUpdateWithoutStageInput}),
});
export const StageMetadataUpdateWithWhereUniqueWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateWithWhereUniqueWithoutStageInput>>('StageMetadataUpdateWithWhereUniqueWithoutStageInput').implement({
  fields: StageMetadataUpdateWithWhereUniqueWithoutStageInputFields,
});

export const StageMetadataUpdateManyWithWhereWithoutStageInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageMetadataScalarWhereInput}),
  data: t.field({"required":true,"type":StageMetadataUpdateManyMutationInput}),
});
export const StageMetadataUpdateManyWithWhereWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateManyWithWhereWithoutStageInput>>('StageMetadataUpdateManyWithWhereWithoutStageInput').implement({
  fields: StageMetadataUpdateManyWithWhereWithoutStageInputFields,
});

export const StageMetadataScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[StageMetadataScalarWhereInput]}),
  OR: t.field({"required":false,"type":[StageMetadataScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[StageMetadataScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  metaKey: t.field({"required":false,"type":StringFilter}),
  metaValue: t.field({"required":false,"type":StringFilter}),
  stageId: t.field({"required":false,"type":IntFilter}),
});
export const StageMetadataScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataScalarWhereInput>>('StageMetadataScalarWhereInput').implement({
  fields: StageMetadataScalarWhereInputFields,
});

export const HiringRoleCreateWithoutStageVisibilitiesInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutStageVisibilitiesInput>>('HiringRoleCreateWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleCreateWithoutStageVisibilitiesInputFields,
});

export const HiringRoleCreateOrConnectWithoutStageVisibilitiesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutStageVisibilitiesInput}),
});
export const HiringRoleCreateOrConnectWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutStageVisibilitiesInput>>('HiringRoleCreateOrConnectWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleCreateOrConnectWithoutStageVisibilitiesInputFields,
});

export const RoleCreateWithoutStageVisibilityInputFields = (t: any) => ({
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutRolesInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutRoleInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutRoleInput}),
});
export const RoleCreateWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateWithoutStageVisibilityInput>>('RoleCreateWithoutStageVisibilityInput').implement({
  fields: RoleCreateWithoutStageVisibilityInputFields,
});

export const RoleCreateOrConnectWithoutStageVisibilityInputFields = (t: any) => ({
  where: t.field({"required":true,"type":RoleWhereUniqueInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutStageVisibilityInput}),
});
export const RoleCreateOrConnectWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateOrConnectWithoutStageVisibilityInput>>('RoleCreateOrConnectWithoutStageVisibilityInput').implement({
  fields: RoleCreateOrConnectWithoutStageVisibilityInputFields,
});

export const StageCreateWithoutVisibilityInputFields = (t: any) => ({
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
  template: t.field({"required":true,"type":TemplateCreateNestedOneWithoutStagesInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutStageInput}),
  metadata: t.field({"required":false,"type":StageMetadataCreateNestedManyWithoutStageInput}),
});
export const StageCreateWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateWithoutVisibilityInput>>('StageCreateWithoutVisibilityInput').implement({
  fields: StageCreateWithoutVisibilityInputFields,
});

export const StageCreateOrConnectWithoutVisibilityInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  create: t.field({"required":true,"type":StageCreateWithoutVisibilityInput}),
});
export const StageCreateOrConnectWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateOrConnectWithoutVisibilityInput>>('StageCreateOrConnectWithoutVisibilityInput').implement({
  fields: StageCreateOrConnectWithoutVisibilityInputFields,
});

export const HiringRoleUpsertWithoutStageVisibilitiesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutStageVisibilitiesInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutStageVisibilitiesInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutStageVisibilitiesInput>>('HiringRoleUpsertWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleUpsertWithoutStageVisibilitiesInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutStageVisibilitiesInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInput>>('HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutStageVisibilitiesInputFields,
});

export const HiringRoleUpdateWithoutStageVisibilitiesInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutStageVisibilitiesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutStageVisibilitiesInput>>('HiringRoleUpdateWithoutStageVisibilitiesInput').implement({
  fields: HiringRoleUpdateWithoutStageVisibilitiesInputFields,
});

export const RoleUpsertWithoutStageVisibilityInputFields = (t: any) => ({
  update: t.field({"required":true,"type":RoleUpdateWithoutStageVisibilityInput}),
  create: t.field({"required":true,"type":RoleCreateWithoutStageVisibilityInput}),
  where: t.field({"required":false,"type":RoleWhereInput}),
});
export const RoleUpsertWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpsertWithoutStageVisibilityInput>>('RoleUpsertWithoutStageVisibilityInput').implement({
  fields: RoleUpsertWithoutStageVisibilityInputFields,
});

export const RoleUpdateToOneWithWhereWithoutStageVisibilityInputFields = (t: any) => ({
  where: t.field({"required":false,"type":RoleWhereInput}),
  data: t.field({"required":true,"type":RoleUpdateWithoutStageVisibilityInput}),
});
export const RoleUpdateToOneWithWhereWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateToOneWithWhereWithoutStageVisibilityInput>>('RoleUpdateToOneWithWhereWithoutStageVisibilityInput').implement({
  fields: RoleUpdateToOneWithWhereWithoutStageVisibilityInputFields,
});

export const RoleUpdateWithoutStageVisibilityInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutRolesNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutRoleNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutRoleNestedInput}),
});
export const RoleUpdateWithoutStageVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateWithoutStageVisibilityInput>>('RoleUpdateWithoutStageVisibilityInput').implement({
  fields: RoleUpdateWithoutStageVisibilityInputFields,
});

export const StageUpsertWithoutVisibilityInputFields = (t: any) => ({
  update: t.field({"required":true,"type":StageUpdateWithoutVisibilityInput}),
  create: t.field({"required":true,"type":StageCreateWithoutVisibilityInput}),
  where: t.field({"required":false,"type":StageWhereInput}),
});
export const StageUpsertWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpsertWithoutVisibilityInput>>('StageUpsertWithoutVisibilityInput').implement({
  fields: StageUpsertWithoutVisibilityInputFields,
});

export const StageUpdateToOneWithWhereWithoutVisibilityInputFields = (t: any) => ({
  where: t.field({"required":false,"type":StageWhereInput}),
  data: t.field({"required":true,"type":StageUpdateWithoutVisibilityInput}),
});
export const StageUpdateToOneWithWhereWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateToOneWithWhereWithoutVisibilityInput>>('StageUpdateToOneWithWhereWithoutVisibilityInput').implement({
  fields: StageUpdateToOneWithWhereWithoutVisibilityInputFields,
});

export const StageUpdateWithoutVisibilityInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneRequiredWithoutStagesNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutStageNestedInput}),
  metadata: t.field({"required":false,"type":StageMetadataUpdateManyWithoutStageNestedInput}),
});
export const StageUpdateWithoutVisibilityInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateWithoutVisibilityInput>>('StageUpdateWithoutVisibilityInput').implement({
  fields: StageUpdateWithoutVisibilityInputFields,
});

export const StageCreateWithoutMetadataInputFields = (t: any) => ({
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
  template: t.field({"required":true,"type":TemplateCreateNestedOneWithoutStagesInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutStageInput}),
  visibility: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutStageInput}),
});
export const StageCreateWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateWithoutMetadataInput>>('StageCreateWithoutMetadataInput').implement({
  fields: StageCreateWithoutMetadataInputFields,
});

export const StageCreateOrConnectWithoutMetadataInputFields = (t: any) => ({
  where: t.field({"required":true,"type":StageWhereUniqueInput}),
  create: t.field({"required":true,"type":StageCreateWithoutMetadataInput}),
});
export const StageCreateOrConnectWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateOrConnectWithoutMetadataInput>>('StageCreateOrConnectWithoutMetadataInput').implement({
  fields: StageCreateOrConnectWithoutMetadataInputFields,
});

export const StageUpsertWithoutMetadataInputFields = (t: any) => ({
  update: t.field({"required":true,"type":StageUpdateWithoutMetadataInput}),
  create: t.field({"required":true,"type":StageCreateWithoutMetadataInput}),
  where: t.field({"required":false,"type":StageWhereInput}),
});
export const StageUpsertWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpsertWithoutMetadataInput>>('StageUpsertWithoutMetadataInput').implement({
  fields: StageUpsertWithoutMetadataInputFields,
});

export const StageUpdateToOneWithWhereWithoutMetadataInputFields = (t: any) => ({
  where: t.field({"required":false,"type":StageWhereInput}),
  data: t.field({"required":true,"type":StageUpdateWithoutMetadataInput}),
});
export const StageUpdateToOneWithWhereWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateToOneWithWhereWithoutMetadataInput>>('StageUpdateToOneWithWhereWithoutMetadataInput').implement({
  fields: StageUpdateToOneWithWhereWithoutMetadataInputFields,
});

export const StageUpdateWithoutMetadataInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneRequiredWithoutStagesNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutStageNestedInput}),
  visibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutStageNestedInput}),
});
export const StageUpdateWithoutMetadataInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateWithoutMetadataInput>>('StageUpdateWithoutMetadataInput').implement({
  fields: StageUpdateWithoutMetadataInputFields,
});

export const TagSourceCreateWithoutCandidateReferrerInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTagSourcesInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutTagInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutTagInput}),
});
export const TagSourceCreateWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateWithoutCandidateReferrerInput>>('TagSourceCreateWithoutCandidateReferrerInput').implement({
  fields: TagSourceCreateWithoutCandidateReferrerInputFields,
});

export const TagSourceCreateOrConnectWithoutCandidateReferrerInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCandidateReferrerInput}),
});
export const TagSourceCreateOrConnectWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateOrConnectWithoutCandidateReferrerInput>>('TagSourceCreateOrConnectWithoutCandidateReferrerInput').implement({
  fields: TagSourceCreateOrConnectWithoutCandidateReferrerInputFields,
});

export const AttachmentCreateWithoutCandidateCvInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutCandidateCvInput>>('AttachmentCreateWithoutCandidateCvInput').implement({
  fields: AttachmentCreateWithoutCandidateCvInputFields,
});

export const AttachmentCreateOrConnectWithoutCandidateCvInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateCvInput}),
});
export const AttachmentCreateOrConnectWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutCandidateCvInput>>('AttachmentCreateOrConnectWithoutCandidateCvInput').implement({
  fields: AttachmentCreateOrConnectWithoutCandidateCvInputFields,
});

export const AttachmentCreateWithoutCandidateAvatarInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCoverLetterInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutCandidateAvatarInput>>('AttachmentCreateWithoutCandidateAvatarInput').implement({
  fields: AttachmentCreateWithoutCandidateAvatarInputFields,
});

export const AttachmentCreateOrConnectWithoutCandidateAvatarInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateAvatarInput}),
});
export const AttachmentCreateOrConnectWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutCandidateAvatarInput>>('AttachmentCreateOrConnectWithoutCandidateAvatarInput').implement({
  fields: AttachmentCreateOrConnectWithoutCandidateAvatarInputFields,
});

export const AttachmentCreateWithoutCandidateCoverLetterInputFields = (t: any) => ({
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  userProfilePhoto: t.field({"required":false,"type":UserCreateNestedOneWithoutPhotoInput}),
  candidateCv: t.field({"required":false,"type":CandidateCreateNestedOneWithoutCvInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateCreateNestedOneWithoutAvatarInput}),
  companyLogo: t.field({"required":false,"type":CompanyCreateNestedOneWithoutLogoInput}),
  uploader: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAttachmentsInput}),
  offerFiles: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutAttachmentInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutAttachmentInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAttachmentsInput}),
});
export const AttachmentCreateWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateWithoutCandidateCoverLetterInput>>('AttachmentCreateWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentCreateWithoutCandidateCoverLetterInputFields,
});

export const AttachmentCreateOrConnectWithoutCandidateCoverLetterInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AttachmentWhereUniqueInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateCoverLetterInput}),
});
export const AttachmentCreateOrConnectWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateOrConnectWithoutCandidateCoverLetterInput>>('AttachmentCreateOrConnectWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentCreateOrConnectWithoutCandidateCoverLetterInputFields,
});

export const OfferCreateWithoutHiredInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutHiredInput>>('OfferCreateWithoutHiredInput').implement({
  fields: OfferCreateWithoutHiredInputFields,
});

export const OfferCreateOrConnectWithoutHiredInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutHiredInput}),
});
export const OfferCreateOrConnectWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutHiredInput>>('OfferCreateOrConnectWithoutHiredInput').implement({
  fields: OfferCreateOrConnectWithoutHiredInputFields,
});

export const HiringRoleCreateWithoutHiredCandidatesInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutHiredCandidatesInput>>('HiringRoleCreateWithoutHiredCandidatesInput').implement({
  fields: HiringRoleCreateWithoutHiredCandidatesInputFields,
});

export const HiringRoleCreateOrConnectWithoutHiredCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutHiredCandidatesInput}),
});
export const HiringRoleCreateOrConnectWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutHiredCandidatesInput>>('HiringRoleCreateOrConnectWithoutHiredCandidatesInput').implement({
  fields: HiringRoleCreateOrConnectWithoutHiredCandidatesInputFields,
});

export const AuditLogCreateWithoutCandidateInputFields = (t: any) => ({
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutAuditLogsInput}),
  user: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutAuditLogsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutAuditLogsInput}),
});
export const AuditLogCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateWithoutCandidateInput>>('AuditLogCreateWithoutCandidateInput').implement({
  fields: AuditLogCreateWithoutCandidateInputFields,
});

export const AuditLogCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutCandidateInput}),
});
export const AuditLogCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateOrConnectWithoutCandidateInput>>('AuditLogCreateOrConnectWithoutCandidateInput').implement({
  fields: AuditLogCreateOrConnectWithoutCandidateInputFields,
});

export const AuditLogCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[AuditLogCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const AuditLogCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyCandidateInputEnvelope>>('AuditLogCreateManyCandidateInputEnvelope').implement({
  fields: AuditLogCreateManyCandidateInputEnvelopeFields,
});

export const MatchCreateWithoutCandidateInputFields = (t: any) => ({
  isHired: t.boolean({"required":false}),
  offer: t.field({"required":true,"type":OfferCreateNestedOneWithoutMatchesInput}),
  stage: t.field({"required":false,"type":StageCreateNestedOneWithoutMatchesInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonCreateNestedOneWithoutMatchesInput}),
});
export const MatchCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateWithoutCandidateInput>>('MatchCreateWithoutCandidateInput').implement({
  fields: MatchCreateWithoutCandidateInputFields,
});

export const MatchCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutCandidateInput}),
});
export const MatchCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateOrConnectWithoutCandidateInput>>('MatchCreateOrConnectWithoutCandidateInput').implement({
  fields: MatchCreateOrConnectWithoutCandidateInputFields,
});

export const MatchCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[MatchCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const MatchCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyCandidateInputEnvelope>>('MatchCreateManyCandidateInputEnvelope').implement({
  fields: MatchCreateManyCandidateInputEnvelopeFields,
});

export const TalentPoolMatchCreateWithoutCandidateInputFields = (t: any) => ({
  talentPool: t.field({"required":true,"type":TalentPoolCreateNestedOneWithoutMatchesInput}),
});
export const TalentPoolMatchCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateWithoutCandidateInput>>('TalentPoolMatchCreateWithoutCandidateInput').implement({
  fields: TalentPoolMatchCreateWithoutCandidateInputFields,
});

export const TalentPoolMatchCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolMatchCreateWithoutCandidateInput}),
});
export const TalentPoolMatchCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateOrConnectWithoutCandidateInput>>('TalentPoolMatchCreateOrConnectWithoutCandidateInput').implement({
  fields: TalentPoolMatchCreateOrConnectWithoutCandidateInputFields,
});

export const TalentPoolMatchCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TalentPoolMatchCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TalentPoolMatchCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateManyCandidateInputEnvelope>>('TalentPoolMatchCreateManyCandidateInputEnvelope').implement({
  fields: TalentPoolMatchCreateManyCandidateInputEnvelopeFields,
});

export const CandidateTagCreateWithoutCandidateInputFields = (t: any) => ({
  tag: t.field({"required":true,"type":TagSourceCreateNestedOneWithoutCandidateTagsInput}),
});
export const CandidateTagCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateWithoutCandidateInput>>('CandidateTagCreateWithoutCandidateInput').implement({
  fields: CandidateTagCreateWithoutCandidateInputFields,
});

export const CandidateTagCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateTagCreateWithoutCandidateInput}),
});
export const CandidateTagCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateOrConnectWithoutCandidateInput>>('CandidateTagCreateOrConnectWithoutCandidateInput').implement({
  fields: CandidateTagCreateOrConnectWithoutCandidateInputFields,
});

export const CandidateTagCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateTagCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateTagCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateManyCandidateInputEnvelope>>('CandidateTagCreateManyCandidateInputEnvelope').implement({
  fields: CandidateTagCreateManyCandidateInputEnvelopeFields,
});

export const CandidateCustomFieldCreateWithoutCandidateInputFields = (t: any) => ({
  value: t.string({"required":false}),
  customField: t.field({"required":true,"type":CustomFieldCreateNestedOneWithoutCandidateCustomFieldsInput}),
});
export const CandidateCustomFieldCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateWithoutCandidateInput>>('CandidateCustomFieldCreateWithoutCandidateInput').implement({
  fields: CandidateCustomFieldCreateWithoutCandidateInputFields,
});

export const CandidateCustomFieldCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCustomFieldCreateWithoutCandidateInput}),
});
export const CandidateCustomFieldCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateOrConnectWithoutCandidateInput>>('CandidateCustomFieldCreateOrConnectWithoutCandidateInput').implement({
  fields: CandidateCustomFieldCreateOrConnectWithoutCandidateInputFields,
});

export const CandidateCustomFieldCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCustomFieldCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCustomFieldCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateManyCandidateInputEnvelope>>('CandidateCustomFieldCreateManyCandidateInputEnvelope').implement({
  fields: CandidateCustomFieldCreateManyCandidateInputEnvelopeFields,
});

export const EvaluationCreateWithoutCandidateInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionCreateNestedManyWithoutEvaluationInput}),
});
export const EvaluationCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutCandidateInput>>('EvaluationCreateWithoutCandidateInput').implement({
  fields: EvaluationCreateWithoutCandidateInputFields,
});

export const EvaluationCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutCandidateInput}),
});
export const EvaluationCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutCandidateInput>>('EvaluationCreateOrConnectWithoutCandidateInput').implement({
  fields: EvaluationCreateOrConnectWithoutCandidateInputFields,
});

export const EvaluationCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyCandidateInputEnvelope>>('EvaluationCreateManyCandidateInputEnvelope').implement({
  fields: EvaluationCreateManyCandidateInputEnvelopeFields,
});

export const TaskCreateWithoutCandidateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTasksInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTaskInput}),
});
export const TaskCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateWithoutCandidateInput>>('TaskCreateWithoutCandidateInput').implement({
  fields: TaskCreateWithoutCandidateInputFields,
});

export const TaskCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutCandidateInput}),
});
export const TaskCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateOrConnectWithoutCandidateInput>>('TaskCreateOrConnectWithoutCandidateInput').implement({
  fields: TaskCreateOrConnectWithoutCandidateInputFields,
});

export const TaskCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TaskCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TaskCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateManyCandidateInputEnvelope>>('TaskCreateManyCandidateInputEnvelope').implement({
  fields: TaskCreateManyCandidateInputEnvelopeFields,
});

export const FollowCreateWithoutCandidateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutFollowsInput}),
  talentPool: t.field({"required":false,"type":TalentPoolCreateNestedOneWithoutFollowsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutFollowsInput}),
});
export const FollowCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateWithoutCandidateInput>>('FollowCreateWithoutCandidateInput').implement({
  fields: FollowCreateWithoutCandidateInputFields,
});

export const FollowCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutCandidateInput}),
});
export const FollowCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateOrConnectWithoutCandidateInput>>('FollowCreateOrConnectWithoutCandidateInput').implement({
  fields: FollowCreateOrConnectWithoutCandidateInputFields,
});

export const FollowCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[FollowCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const FollowCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyCandidateInputEnvelope>>('FollowCreateManyCandidateInputEnvelope').implement({
  fields: FollowCreateManyCandidateInputEnvelopeFields,
});

export const SharedCandidateLinkCreateWithoutCandidateInputFields = (t: any) => ({
  name: t.string({"required":true}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.string({"required":true}),
  expiration: t.field({"required":true,"type":DateTime}),
});
export const SharedCandidateLinkCreateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateWithoutCandidateInput>>('SharedCandidateLinkCreateWithoutCandidateInput').implement({
  fields: SharedCandidateLinkCreateWithoutCandidateInputFields,
});

export const SharedCandidateLinkCreateOrConnectWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SharedCandidateLinkWhereUniqueInput}),
  create: t.field({"required":true,"type":SharedCandidateLinkCreateWithoutCandidateInput}),
});
export const SharedCandidateLinkCreateOrConnectWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateOrConnectWithoutCandidateInput>>('SharedCandidateLinkCreateOrConnectWithoutCandidateInput').implement({
  fields: SharedCandidateLinkCreateOrConnectWithoutCandidateInputFields,
});

export const SharedCandidateLinkCreateManyCandidateInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[SharedCandidateLinkCreateManyCandidateInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const SharedCandidateLinkCreateManyCandidateInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateManyCandidateInputEnvelope>>('SharedCandidateLinkCreateManyCandidateInputEnvelope').implement({
  fields: SharedCandidateLinkCreateManyCandidateInputEnvelopeFields,
});

export const CompanyCreateWithoutCandidatesInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutCandidatesInput>>('CompanyCreateWithoutCandidatesInput').implement({
  fields: CompanyCreateWithoutCandidatesInputFields,
});

export const CompanyCreateOrConnectWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutCandidatesInput}),
});
export const CompanyCreateOrConnectWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutCandidatesInput>>('CompanyCreateOrConnectWithoutCandidatesInput').implement({
  fields: CompanyCreateOrConnectWithoutCandidatesInputFields,
});

export const EventCreateWithoutCandidatesInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutEventInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutCandidatesInput>>('EventCreateWithoutCandidatesInput').implement({
  fields: EventCreateWithoutCandidatesInputFields,
});

export const EventCreateOrConnectWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCandidatesInput}),
});
export const EventCreateOrConnectWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutCandidatesInput>>('EventCreateOrConnectWithoutCandidatesInput').implement({
  fields: EventCreateOrConnectWithoutCandidatesInputFields,
});

export const TagSourceUpsertWithoutCandidateReferrerInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TagSourceUpdateWithoutCandidateReferrerInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCandidateReferrerInput}),
  where: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceUpsertWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpsertWithoutCandidateReferrerInput>>('TagSourceUpsertWithoutCandidateReferrerInput').implement({
  fields: TagSourceUpsertWithoutCandidateReferrerInputFields,
});

export const TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TagSourceWhereInput}),
  data: t.field({"required":true,"type":TagSourceUpdateWithoutCandidateReferrerInput}),
});
export const TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInput>>('TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInput').implement({
  fields: TagSourceUpdateToOneWithWhereWithoutCandidateReferrerInputFields,
});

export const TagSourceUpdateWithoutCandidateReferrerInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTagSourcesNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutTagNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutTagNestedInput}),
});
export const TagSourceUpdateWithoutCandidateReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateWithoutCandidateReferrerInput>>('TagSourceUpdateWithoutCandidateReferrerInput').implement({
  fields: TagSourceUpdateWithoutCandidateReferrerInputFields,
});

export const AttachmentUpsertWithoutCandidateCvInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateCvInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateCvInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutCandidateCvInput>>('AttachmentUpsertWithoutCandidateCvInput').implement({
  fields: AttachmentUpsertWithoutCandidateCvInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutCandidateCvInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateCvInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutCandidateCvInput>>('AttachmentUpdateToOneWithWhereWithoutCandidateCvInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutCandidateCvInputFields,
});

export const AttachmentUpdateWithoutCandidateCvInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutCandidateCvInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutCandidateCvInput>>('AttachmentUpdateWithoutCandidateCvInput').implement({
  fields: AttachmentUpdateWithoutCandidateCvInputFields,
});

export const AttachmentUpsertWithoutCandidateAvatarInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateAvatarInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateAvatarInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutCandidateAvatarInput>>('AttachmentUpsertWithoutCandidateAvatarInput').implement({
  fields: AttachmentUpsertWithoutCandidateAvatarInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateAvatarInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInput>>('AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutCandidateAvatarInputFields,
});

export const AttachmentUpdateWithoutCandidateAvatarInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutCandidateAvatarInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutCandidateAvatarInput>>('AttachmentUpdateWithoutCandidateAvatarInput').implement({
  fields: AttachmentUpdateWithoutCandidateAvatarInputFields,
});

export const AttachmentUpsertWithoutCandidateCoverLetterInputFields = (t: any) => ({
  update: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateCoverLetterInput}),
  create: t.field({"required":true,"type":AttachmentCreateWithoutCandidateCoverLetterInput}),
  where: t.field({"required":false,"type":AttachmentWhereInput}),
});
export const AttachmentUpsertWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpsertWithoutCandidateCoverLetterInput>>('AttachmentUpsertWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentUpsertWithoutCandidateCoverLetterInputFields,
});

export const AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInputFields = (t: any) => ({
  where: t.field({"required":false,"type":AttachmentWhereInput}),
  data: t.field({"required":true,"type":AttachmentUpdateWithoutCandidateCoverLetterInput}),
});
export const AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInput>>('AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentUpdateToOneWithWhereWithoutCandidateCoverLetterInputFields,
});

export const AttachmentUpdateWithoutCandidateCoverLetterInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutCandidateCoverLetterInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutCandidateCoverLetterInput>>('AttachmentUpdateWithoutCandidateCoverLetterInput').implement({
  fields: AttachmentUpdateWithoutCandidateCoverLetterInputFields,
});

export const OfferUpsertWithoutHiredInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutHiredInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutHiredInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutHiredInput>>('OfferUpsertWithoutHiredInput').implement({
  fields: OfferUpsertWithoutHiredInputFields,
});

export const OfferUpdateToOneWithWhereWithoutHiredInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutHiredInput}),
});
export const OfferUpdateToOneWithWhereWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutHiredInput>>('OfferUpdateToOneWithWhereWithoutHiredInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutHiredInputFields,
});

export const OfferUpdateWithoutHiredInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutHiredInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutHiredInput>>('OfferUpdateWithoutHiredInput').implement({
  fields: OfferUpdateWithoutHiredInputFields,
});

export const HiringRoleUpsertWithoutHiredCandidatesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutHiredCandidatesInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutHiredCandidatesInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutHiredCandidatesInput>>('HiringRoleUpsertWithoutHiredCandidatesInput').implement({
  fields: HiringRoleUpsertWithoutHiredCandidatesInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutHiredCandidatesInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInput>>('HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutHiredCandidatesInputFields,
});

export const HiringRoleUpdateWithoutHiredCandidatesInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutHiredCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutHiredCandidatesInput>>('HiringRoleUpdateWithoutHiredCandidatesInput').implement({
  fields: HiringRoleUpdateWithoutHiredCandidatesInputFields,
});

export const AuditLogUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  update: t.field({"required":true,"type":AuditLogUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":AuditLogCreateWithoutCandidateInput}),
});
export const AuditLogUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpsertWithWhereUniqueWithoutCandidateInput>>('AuditLogUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: AuditLogUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const AuditLogUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogWhereUniqueInput}),
  data: t.field({"required":true,"type":AuditLogUpdateWithoutCandidateInput}),
});
export const AuditLogUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithWhereUniqueWithoutCandidateInput>>('AuditLogUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: AuditLogUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const AuditLogUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":AuditLogScalarWhereInput}),
  data: t.field({"required":true,"type":AuditLogUpdateManyMutationInput}),
});
export const AuditLogUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateManyWithWhereWithoutCandidateInput>>('AuditLogUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: AuditLogUpdateManyWithWhereWithoutCandidateInputFields,
});

export const MatchUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  update: t.field({"required":true,"type":MatchUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":MatchCreateWithoutCandidateInput}),
});
export const MatchUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpsertWithWhereUniqueWithoutCandidateInput>>('MatchUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: MatchUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const MatchUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchWhereUniqueInput}),
  data: t.field({"required":true,"type":MatchUpdateWithoutCandidateInput}),
});
export const MatchUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithWhereUniqueWithoutCandidateInput>>('MatchUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: MatchUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const MatchUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":MatchScalarWhereInput}),
  data: t.field({"required":true,"type":MatchUpdateManyMutationInput}),
});
export const MatchUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateManyWithWhereWithoutCandidateInput>>('MatchUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: MatchUpdateManyWithWhereWithoutCandidateInputFields,
});

export const TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  update: t.field({"required":true,"type":TalentPoolMatchUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":TalentPoolMatchCreateWithoutCandidateInput}),
});
export const TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInput>>('TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: TalentPoolMatchUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchWhereUniqueInput}),
  data: t.field({"required":true,"type":TalentPoolMatchUpdateWithoutCandidateInput}),
});
export const TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInput>>('TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: TalentPoolMatchUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const TalentPoolMatchUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolMatchScalarWhereInput}),
  data: t.field({"required":true,"type":TalentPoolMatchUpdateManyMutationInput}),
});
export const TalentPoolMatchUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateManyWithWhereWithoutCandidateInput>>('TalentPoolMatchUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: TalentPoolMatchUpdateManyWithWhereWithoutCandidateInputFields,
});

export const CandidateTagUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateTagUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":CandidateTagCreateWithoutCandidateInput}),
});
export const CandidateTagUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpsertWithWhereUniqueWithoutCandidateInput>>('CandidateTagUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: CandidateTagUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const CandidateTagUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateTagUpdateWithoutCandidateInput}),
});
export const CandidateTagUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateWithWhereUniqueWithoutCandidateInput>>('CandidateTagUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: CandidateTagUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const CandidateTagUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateTagScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateTagUpdateManyMutationInput}),
});
export const CandidateTagUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateManyWithWhereWithoutCandidateInput>>('CandidateTagUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: CandidateTagUpdateManyWithWhereWithoutCandidateInputFields,
});

export const CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateCustomFieldUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":CandidateCustomFieldCreateWithoutCandidateInput}),
});
export const CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInput>>('CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: CandidateCustomFieldUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateCustomFieldUpdateWithoutCandidateInput}),
});
export const CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInput>>('CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: CandidateCustomFieldUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateCustomFieldUpdateManyMutationInput}),
});
export const CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInput>>('CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: CandidateCustomFieldUpdateManyWithWhereWithoutCandidateInputFields,
});

export const CandidateCustomFieldScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereInput]}),
  OR: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[CandidateCustomFieldScalarWhereInput]}),
  candidateId: t.field({"required":false,"type":IntFilter}),
  customFieldId: t.field({"required":false,"type":IntFilter}),
  value: t.field({"required":false,"type":StringNullableFilter}),
});
export const CandidateCustomFieldScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldScalarWhereInput>>('CandidateCustomFieldScalarWhereInput').implement({
  fields: CandidateCustomFieldScalarWhereInputFields,
});

export const EvaluationUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutCandidateInput}),
});
export const EvaluationUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithWhereUniqueWithoutCandidateInput>>('EvaluationUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: EvaluationUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const EvaluationUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutCandidateInput}),
});
export const EvaluationUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithWhereUniqueWithoutCandidateInput>>('EvaluationUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: EvaluationUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const EvaluationUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateManyMutationInput}),
});
export const EvaluationUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateManyWithWhereWithoutCandidateInput>>('EvaluationUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: EvaluationUpdateManyWithWhereWithoutCandidateInputFields,
});

export const TaskUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  update: t.field({"required":true,"type":TaskUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutCandidateInput}),
});
export const TaskUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpsertWithWhereUniqueWithoutCandidateInput>>('TaskUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: TaskUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const TaskUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  data: t.field({"required":true,"type":TaskUpdateWithoutCandidateInput}),
});
export const TaskUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateWithWhereUniqueWithoutCandidateInput>>('TaskUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: TaskUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const TaskUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskScalarWhereInput}),
  data: t.field({"required":true,"type":TaskUpdateManyMutationInput}),
});
export const TaskUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateManyWithWhereWithoutCandidateInput>>('TaskUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: TaskUpdateManyWithWhereWithoutCandidateInputFields,
});

export const FollowUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  update: t.field({"required":true,"type":FollowUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":FollowCreateWithoutCandidateInput}),
});
export const FollowUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpsertWithWhereUniqueWithoutCandidateInput>>('FollowUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: FollowUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const FollowUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowWhereUniqueInput}),
  data: t.field({"required":true,"type":FollowUpdateWithoutCandidateInput}),
});
export const FollowUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithWhereUniqueWithoutCandidateInput>>('FollowUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: FollowUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const FollowUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":FollowScalarWhereInput}),
  data: t.field({"required":true,"type":FollowUpdateManyMutationInput}),
});
export const FollowUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateManyWithWhereWithoutCandidateInput>>('FollowUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: FollowUpdateManyWithWhereWithoutCandidateInputFields,
});

export const SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SharedCandidateLinkWhereUniqueInput}),
  update: t.field({"required":true,"type":SharedCandidateLinkUpdateWithoutCandidateInput}),
  create: t.field({"required":true,"type":SharedCandidateLinkCreateWithoutCandidateInput}),
});
export const SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInput>>('SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInput').implement({
  fields: SharedCandidateLinkUpsertWithWhereUniqueWithoutCandidateInputFields,
});

export const SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SharedCandidateLinkWhereUniqueInput}),
  data: t.field({"required":true,"type":SharedCandidateLinkUpdateWithoutCandidateInput}),
});
export const SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInput>>('SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInput').implement({
  fields: SharedCandidateLinkUpdateWithWhereUniqueWithoutCandidateInputFields,
});

export const SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInputFields = (t: any) => ({
  where: t.field({"required":true,"type":SharedCandidateLinkScalarWhereInput}),
  data: t.field({"required":true,"type":SharedCandidateLinkUpdateManyMutationInput}),
});
export const SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInput>>('SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInput').implement({
  fields: SharedCandidateLinkUpdateManyWithWhereWithoutCandidateInputFields,
});

export const SharedCandidateLinkScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereInput]}),
  OR: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[SharedCandidateLinkScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  name: t.field({"required":false,"type":StringFilter}),
  visibleSections: t.field({"required":false,"type":StringNullableListFilter}),
  editModelSections: t.field({"required":false,"type":StringNullableListFilter}),
  link: t.field({"required":false,"type":StringFilter}),
  expiration: t.field({"required":false,"type":DateTimeFilter}),
  candidateId: t.field({"required":false,"type":IntFilter}),
});
export const SharedCandidateLinkScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkScalarWhereInput>>('SharedCandidateLinkScalarWhereInput').implement({
  fields: SharedCandidateLinkScalarWhereInputFields,
});

export const CompanyUpsertWithoutCandidatesInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutCandidatesInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutCandidatesInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutCandidatesInput>>('CompanyUpsertWithoutCandidatesInput').implement({
  fields: CompanyUpsertWithoutCandidatesInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutCandidatesInput}),
});
export const CompanyUpdateToOneWithWhereWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutCandidatesInput>>('CompanyUpdateToOneWithWhereWithoutCandidatesInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutCandidatesInputFields,
});

export const CompanyUpdateWithoutCandidatesInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutCandidatesInput>>('CompanyUpdateWithoutCandidatesInput').implement({
  fields: CompanyUpdateWithoutCandidatesInputFields,
});

export const EventUpsertWithWhereUniqueWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  update: t.field({"required":true,"type":EventUpdateWithoutCandidatesInput}),
  create: t.field({"required":true,"type":EventCreateWithoutCandidatesInput}),
});
export const EventUpsertWithWhereUniqueWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithWhereUniqueWithoutCandidatesInput>>('EventUpsertWithWhereUniqueWithoutCandidatesInput').implement({
  fields: EventUpsertWithWhereUniqueWithoutCandidatesInputFields,
});

export const EventUpdateWithWhereUniqueWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutCandidatesInput}),
});
export const EventUpdateWithWhereUniqueWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithWhereUniqueWithoutCandidatesInput>>('EventUpdateWithWhereUniqueWithoutCandidatesInput').implement({
  fields: EventUpdateWithWhereUniqueWithoutCandidatesInputFields,
});

export const EventUpdateManyWithWhereWithoutCandidatesInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScalarWhereInput}),
  data: t.field({"required":true,"type":EventUpdateManyMutationInput}),
});
export const EventUpdateManyWithWhereWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateManyWithWhereWithoutCandidatesInput>>('EventUpdateManyWithWhereWithoutCandidatesInput').implement({
  fields: EventUpdateManyWithWhereWithoutCandidatesInputFields,
});

export const CandidateCreateWithoutCandidateTagsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutCandidateTagsInput>>('CandidateCreateWithoutCandidateTagsInput').implement({
  fields: CandidateCreateWithoutCandidateTagsInputFields,
});

export const CandidateCreateOrConnectWithoutCandidateTagsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCandidateTagsInput}),
});
export const CandidateCreateOrConnectWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutCandidateTagsInput>>('CandidateCreateOrConnectWithoutCandidateTagsInput').implement({
  fields: CandidateCreateOrConnectWithoutCandidateTagsInputFields,
});

export const TagSourceCreateWithoutCandidateTagsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTagSourcesInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutTagInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateCreateNestedManyWithoutReferrerInput}),
});
export const TagSourceCreateWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateWithoutCandidateTagsInput>>('TagSourceCreateWithoutCandidateTagsInput').implement({
  fields: TagSourceCreateWithoutCandidateTagsInputFields,
});

export const TagSourceCreateOrConnectWithoutCandidateTagsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TagSourceWhereUniqueInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCandidateTagsInput}),
});
export const TagSourceCreateOrConnectWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateOrConnectWithoutCandidateTagsInput>>('TagSourceCreateOrConnectWithoutCandidateTagsInput').implement({
  fields: TagSourceCreateOrConnectWithoutCandidateTagsInputFields,
});

export const CandidateUpsertWithoutCandidateTagsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutCandidateTagsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCandidateTagsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutCandidateTagsInput>>('CandidateUpsertWithoutCandidateTagsInput').implement({
  fields: CandidateUpsertWithoutCandidateTagsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutCandidateTagsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutCandidateTagsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutCandidateTagsInput>>('CandidateUpdateToOneWithWhereWithoutCandidateTagsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutCandidateTagsInputFields,
});

export const CandidateUpdateWithoutCandidateTagsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutCandidateTagsInput>>('CandidateUpdateWithoutCandidateTagsInput').implement({
  fields: CandidateUpdateWithoutCandidateTagsInputFields,
});

export const TagSourceUpsertWithoutCandidateTagsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TagSourceUpdateWithoutCandidateTagsInput}),
  create: t.field({"required":true,"type":TagSourceCreateWithoutCandidateTagsInput}),
  where: t.field({"required":false,"type":TagSourceWhereInput}),
});
export const TagSourceUpsertWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpsertWithoutCandidateTagsInput>>('TagSourceUpsertWithoutCandidateTagsInput').implement({
  fields: TagSourceUpsertWithoutCandidateTagsInputFields,
});

export const TagSourceUpdateToOneWithWhereWithoutCandidateTagsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TagSourceWhereInput}),
  data: t.field({"required":true,"type":TagSourceUpdateWithoutCandidateTagsInput}),
});
export const TagSourceUpdateToOneWithWhereWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateToOneWithWhereWithoutCandidateTagsInput>>('TagSourceUpdateToOneWithWhereWithoutCandidateTagsInput').implement({
  fields: TagSourceUpdateToOneWithWhereWithoutCandidateTagsInputFields,
});

export const TagSourceUpdateWithoutCandidateTagsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTagSourcesNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutTagNestedInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateUpdateManyWithoutReferrerNestedInput}),
});
export const TagSourceUpdateWithoutCandidateTagsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateWithoutCandidateTagsInput>>('TagSourceUpdateWithoutCandidateTagsInput').implement({
  fields: TagSourceUpdateWithoutCandidateTagsInputFields,
});

export const CandidateCreateWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutCandidateCustomFieldsInput>>('CandidateCreateWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateCreateWithoutCandidateCustomFieldsInputFields,
});

export const CandidateCreateOrConnectWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCandidateCustomFieldsInput}),
});
export const CandidateCreateOrConnectWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutCandidateCustomFieldsInput>>('CandidateCreateOrConnectWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateCreateOrConnectWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldCreateWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  type: t.string({"required":false}),
  key: t.string({"required":true}),
  defaultValue: t.string({"required":false}),
  settings: t.field({"required":false,"type":Json}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCustomFieldsInput}),
});
export const CustomFieldCreateWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateWithoutCandidateCustomFieldsInput>>('CustomFieldCreateWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldCreateWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CustomFieldWhereUniqueInput}),
  create: t.field({"required":true,"type":CustomFieldCreateWithoutCandidateCustomFieldsInput}),
});
export const CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInput>>('CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldCreateOrConnectWithoutCandidateCustomFieldsInputFields,
});

export const CandidateUpsertWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutCandidateCustomFieldsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutCandidateCustomFieldsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutCandidateCustomFieldsInput>>('CandidateUpsertWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateUpsertWithoutCandidateCustomFieldsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutCandidateCustomFieldsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInput>>('CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutCandidateCustomFieldsInputFields,
});

export const CandidateUpdateWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutCandidateCustomFieldsInput>>('CandidateUpdateWithoutCandidateCustomFieldsInput').implement({
  fields: CandidateUpdateWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldUpsertWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CustomFieldUpdateWithoutCandidateCustomFieldsInput}),
  create: t.field({"required":true,"type":CustomFieldCreateWithoutCandidateCustomFieldsInput}),
  where: t.field({"required":false,"type":CustomFieldWhereInput}),
});
export const CustomFieldUpsertWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpsertWithoutCandidateCustomFieldsInput>>('CustomFieldUpsertWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldUpsertWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CustomFieldWhereInput}),
  data: t.field({"required":true,"type":CustomFieldUpdateWithoutCandidateCustomFieldsInput}),
});
export const CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInput>>('CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldUpdateToOneWithWhereWithoutCandidateCustomFieldsInputFields,
});

export const CustomFieldUpdateWithoutCandidateCustomFieldsInputFields = (t: any) => ({
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  defaultValue: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCustomFieldsNestedInput}),
});
export const CustomFieldUpdateWithoutCandidateCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateWithoutCandidateCustomFieldsInput>>('CustomFieldUpdateWithoutCandidateCustomFieldsInput').implement({
  fields: CustomFieldUpdateWithoutCandidateCustomFieldsInputFields,
});

export const CompanyCreateWithoutCustomFieldsInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutCustomFieldsInput>>('CompanyCreateWithoutCustomFieldsInput').implement({
  fields: CompanyCreateWithoutCustomFieldsInputFields,
});

export const CompanyCreateOrConnectWithoutCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutCustomFieldsInput}),
});
export const CompanyCreateOrConnectWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutCustomFieldsInput>>('CompanyCreateOrConnectWithoutCustomFieldsInput').implement({
  fields: CompanyCreateOrConnectWithoutCustomFieldsInputFields,
});

export const CandidateCustomFieldCreateWithoutCustomFieldInputFields = (t: any) => ({
  value: t.string({"required":false}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutCandidateCustomFieldsInput}),
});
export const CandidateCustomFieldCreateWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateWithoutCustomFieldInput>>('CandidateCustomFieldCreateWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldCreateWithoutCustomFieldInputFields,
});

export const CandidateCustomFieldCreateOrConnectWithoutCustomFieldInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCustomFieldCreateWithoutCustomFieldInput}),
});
export const CandidateCustomFieldCreateOrConnectWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateOrConnectWithoutCustomFieldInput>>('CandidateCustomFieldCreateOrConnectWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldCreateOrConnectWithoutCustomFieldInputFields,
});

export const CandidateCustomFieldCreateManyCustomFieldInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[CandidateCustomFieldCreateManyCustomFieldInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const CandidateCustomFieldCreateManyCustomFieldInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateManyCustomFieldInputEnvelope>>('CandidateCustomFieldCreateManyCustomFieldInputEnvelope').implement({
  fields: CandidateCustomFieldCreateManyCustomFieldInputEnvelopeFields,
});

export const CompanyUpsertWithoutCustomFieldsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutCustomFieldsInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutCustomFieldsInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutCustomFieldsInput>>('CompanyUpsertWithoutCustomFieldsInput').implement({
  fields: CompanyUpsertWithoutCustomFieldsInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutCustomFieldsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutCustomFieldsInput}),
});
export const CompanyUpdateToOneWithWhereWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutCustomFieldsInput>>('CompanyUpdateToOneWithWhereWithoutCustomFieldsInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutCustomFieldsInputFields,
});

export const CompanyUpdateWithoutCustomFieldsInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutCustomFieldsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutCustomFieldsInput>>('CompanyUpdateWithoutCustomFieldsInput').implement({
  fields: CompanyUpdateWithoutCustomFieldsInputFields,
});

export const CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  update: t.field({"required":true,"type":CandidateCustomFieldUpdateWithoutCustomFieldInput}),
  create: t.field({"required":true,"type":CandidateCustomFieldCreateWithoutCustomFieldInput}),
});
export const CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInput>>('CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldUpsertWithWhereUniqueWithoutCustomFieldInputFields,
});

export const CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldWhereUniqueInput}),
  data: t.field({"required":true,"type":CandidateCustomFieldUpdateWithoutCustomFieldInput}),
});
export const CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInput>>('CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldUpdateWithWhereUniqueWithoutCustomFieldInputFields,
});

export const CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateCustomFieldScalarWhereInput}),
  data: t.field({"required":true,"type":CandidateCustomFieldUpdateManyMutationInput}),
});
export const CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInput>>('CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldUpdateManyWithWhereWithoutCustomFieldInputFields,
});

export const TemplateCreateWithoutEvaluationsInputFields = (t: any) => ({
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTemplatesInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferCreateNestedManyWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferCreateNestedManyWithoutAutoConfirmationEmailInput}),
  stages: t.field({"required":false,"type":StageCreateNestedManyWithoutTemplateInput}),
});
export const TemplateCreateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateWithoutEvaluationsInput>>('TemplateCreateWithoutEvaluationsInput').implement({
  fields: TemplateCreateWithoutEvaluationsInputFields,
});

export const TemplateCreateOrConnectWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TemplateWhereUniqueInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutEvaluationsInput}),
});
export const TemplateCreateOrConnectWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateOrConnectWithoutEvaluationsInput>>('TemplateCreateOrConnectWithoutEvaluationsInput').implement({
  fields: TemplateCreateOrConnectWithoutEvaluationsInputFields,
});

export const OfferCreateWithoutEvaluationsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutEvaluationsInput>>('OfferCreateWithoutEvaluationsInput').implement({
  fields: OfferCreateWithoutEvaluationsInputFields,
});

export const OfferCreateOrConnectWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutEvaluationsInput}),
});
export const OfferCreateOrConnectWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutEvaluationsInput>>('OfferCreateOrConnectWithoutEvaluationsInput').implement({
  fields: OfferCreateOrConnectWithoutEvaluationsInputFields,
});

export const CandidateCreateWithoutEvaluationsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutEvaluationsInput>>('CandidateCreateWithoutEvaluationsInput').implement({
  fields: CandidateCreateWithoutEvaluationsInputFields,
});

export const CandidateCreateOrConnectWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutEvaluationsInput}),
});
export const CandidateCreateOrConnectWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutEvaluationsInput>>('CandidateCreateOrConnectWithoutEvaluationsInput').implement({
  fields: CandidateCreateOrConnectWithoutEvaluationsInputFields,
});

export const HiringRoleCreateWithoutEvaluationsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutEvaluationsInput>>('HiringRoleCreateWithoutEvaluationsInput').implement({
  fields: HiringRoleCreateWithoutEvaluationsInputFields,
});

export const HiringRoleCreateOrConnectWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEvaluationsInput}),
});
export const HiringRoleCreateOrConnectWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutEvaluationsInput>>('HiringRoleCreateOrConnectWithoutEvaluationsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutEvaluationsInputFields,
});

export const EventScheduleEvaluationCreateWithoutEvaluationInputFields = (t: any) => ({
  eventSchedule: t.field({"required":true,"type":EventScheduleCreateNestedOneWithoutEventScheduleEvaluationsInput}),
});
export const EventScheduleEvaluationCreateWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateWithoutEvaluationInput>>('EventScheduleEvaluationCreateWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationCreateWithoutEvaluationInputFields,
});

export const EventScheduleEvaluationCreateOrConnectWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EventScheduleEvaluationCreateWithoutEvaluationInput}),
});
export const EventScheduleEvaluationCreateOrConnectWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateOrConnectWithoutEvaluationInput>>('EventScheduleEvaluationCreateOrConnectWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationCreateOrConnectWithoutEvaluationInputFields,
});

export const EventScheduleEvaluationCreateManyEvaluationInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EventScheduleEvaluationCreateManyEvaluationInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EventScheduleEvaluationCreateManyEvaluationInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateManyEvaluationInputEnvelope>>('EventScheduleEvaluationCreateManyEvaluationInputEnvelope').implement({
  fields: EventScheduleEvaluationCreateManyEvaluationInputEnvelopeFields,
});

export const EventCreateWithoutEvaluationsInputFields = (t: any) => ({
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutEventsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutInterviewerEventsInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutEventsInput}),
  createdBy: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutCreatedEventsInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutEventInput}),
});
export const EventCreateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateWithoutEvaluationsInput>>('EventCreateWithoutEvaluationsInput').implement({
  fields: EventCreateWithoutEvaluationsInputFields,
});

export const EventCreateOrConnectWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventWhereUniqueInput}),
  create: t.field({"required":true,"type":EventCreateWithoutEvaluationsInput}),
});
export const EventCreateOrConnectWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateOrConnectWithoutEvaluationsInput>>('EventCreateOrConnectWithoutEvaluationsInput').implement({
  fields: EventCreateOrConnectWithoutEvaluationsInputFields,
});

export const EvaluationQuestionCreateWithoutEvaluationInputFields = (t: any) => ({
  inputType: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  question: t.string({"required":false}),
  answer: t.string({"required":true}),
});
export const EvaluationQuestionCreateWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateWithoutEvaluationInput>>('EvaluationQuestionCreateWithoutEvaluationInput').implement({
  fields: EvaluationQuestionCreateWithoutEvaluationInputFields,
});

export const EvaluationQuestionCreateOrConnectWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationQuestionWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationQuestionCreateWithoutEvaluationInput}),
});
export const EvaluationQuestionCreateOrConnectWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateOrConnectWithoutEvaluationInput>>('EvaluationQuestionCreateOrConnectWithoutEvaluationInput').implement({
  fields: EvaluationQuestionCreateOrConnectWithoutEvaluationInputFields,
});

export const EvaluationQuestionCreateManyEvaluationInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[EvaluationQuestionCreateManyEvaluationInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const EvaluationQuestionCreateManyEvaluationInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateManyEvaluationInputEnvelope>>('EvaluationQuestionCreateManyEvaluationInputEnvelope').implement({
  fields: EvaluationQuestionCreateManyEvaluationInputEnvelopeFields,
});

export const TemplateUpsertWithoutEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TemplateUpdateWithoutEvaluationsInput}),
  create: t.field({"required":true,"type":TemplateCreateWithoutEvaluationsInput}),
  where: t.field({"required":false,"type":TemplateWhereInput}),
});
export const TemplateUpsertWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpsertWithoutEvaluationsInput>>('TemplateUpsertWithoutEvaluationsInput').implement({
  fields: TemplateUpsertWithoutEvaluationsInputFields,
});

export const TemplateUpdateToOneWithWhereWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TemplateWhereInput}),
  data: t.field({"required":true,"type":TemplateUpdateWithoutEvaluationsInput}),
});
export const TemplateUpdateToOneWithWhereWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateToOneWithWhereWithoutEvaluationsInput>>('TemplateUpdateToOneWithWhereWithoutEvaluationsInput').implement({
  fields: TemplateUpdateToOneWithWhereWithoutEvaluationsInputFields,
});

export const TemplateUpdateWithoutEvaluationsInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTemplatesNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutEvaluationsInput>>('TemplateUpdateWithoutEvaluationsInput').implement({
  fields: TemplateUpdateWithoutEvaluationsInputFields,
});

export const OfferUpsertWithoutEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutEvaluationsInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutEvaluationsInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutEvaluationsInput>>('OfferUpsertWithoutEvaluationsInput').implement({
  fields: OfferUpsertWithoutEvaluationsInputFields,
});

export const OfferUpdateToOneWithWhereWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutEvaluationsInput}),
});
export const OfferUpdateToOneWithWhereWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutEvaluationsInput>>('OfferUpdateToOneWithWhereWithoutEvaluationsInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutEvaluationsInputFields,
});

export const OfferUpdateWithoutEvaluationsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutEvaluationsInput>>('OfferUpdateWithoutEvaluationsInput').implement({
  fields: OfferUpdateWithoutEvaluationsInputFields,
});

export const CandidateUpsertWithoutEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutEvaluationsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutEvaluationsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutEvaluationsInput>>('CandidateUpsertWithoutEvaluationsInput').implement({
  fields: CandidateUpsertWithoutEvaluationsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutEvaluationsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutEvaluationsInput>>('CandidateUpdateToOneWithWhereWithoutEvaluationsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutEvaluationsInputFields,
});

export const CandidateUpdateWithoutEvaluationsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutEvaluationsInput>>('CandidateUpdateWithoutEvaluationsInput').implement({
  fields: CandidateUpdateWithoutEvaluationsInputFields,
});

export const HiringRoleUpsertWithoutEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutEvaluationsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutEvaluationsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutEvaluationsInput>>('HiringRoleUpsertWithoutEvaluationsInput').implement({
  fields: HiringRoleUpsertWithoutEvaluationsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutEvaluationsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutEvaluationsInput>>('HiringRoleUpdateToOneWithWhereWithoutEvaluationsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutEvaluationsInputFields,
});

export const HiringRoleUpdateWithoutEvaluationsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutEvaluationsInput>>('HiringRoleUpdateWithoutEvaluationsInput').implement({
  fields: HiringRoleUpdateWithoutEvaluationsInputFields,
});

export const EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  update: t.field({"required":true,"type":EventScheduleEvaluationUpdateWithoutEvaluationInput}),
  create: t.field({"required":true,"type":EventScheduleEvaluationCreateWithoutEvaluationInput}),
});
export const EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInput>>('EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationUpsertWithWhereUniqueWithoutEvaluationInputFields,
});

export const EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationWhereUniqueInput}),
  data: t.field({"required":true,"type":EventScheduleEvaluationUpdateWithoutEvaluationInput}),
});
export const EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInput>>('EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationUpdateWithWhereUniqueWithoutEvaluationInputFields,
});

export const EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EventScheduleEvaluationScalarWhereInput}),
  data: t.field({"required":true,"type":EventScheduleEvaluationUpdateManyMutationInput}),
});
export const EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInput>>('EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationUpdateManyWithWhereWithoutEvaluationInputFields,
});

export const EventUpsertWithoutEvaluationsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EventUpdateWithoutEvaluationsInput}),
  create: t.field({"required":true,"type":EventCreateWithoutEvaluationsInput}),
  where: t.field({"required":false,"type":EventWhereInput}),
});
export const EventUpsertWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpsertWithoutEvaluationsInput>>('EventUpsertWithoutEvaluationsInput').implement({
  fields: EventUpsertWithoutEvaluationsInputFields,
});

export const EventUpdateToOneWithWhereWithoutEvaluationsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EventWhereInput}),
  data: t.field({"required":true,"type":EventUpdateWithoutEvaluationsInput}),
});
export const EventUpdateToOneWithWhereWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateToOneWithWhereWithoutEvaluationsInput>>('EventUpdateToOneWithWhereWithoutEvaluationsInput').implement({
  fields: EventUpdateToOneWithWhereWithoutEvaluationsInputFields,
});

export const EventUpdateWithoutEvaluationsInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateWithoutEvaluationsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutEvaluationsInput>>('EventUpdateWithoutEvaluationsInput').implement({
  fields: EventUpdateWithoutEvaluationsInputFields,
});

export const EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationQuestionWhereUniqueInput}),
  update: t.field({"required":true,"type":EvaluationQuestionUpdateWithoutEvaluationInput}),
  create: t.field({"required":true,"type":EvaluationQuestionCreateWithoutEvaluationInput}),
});
export const EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInput>>('EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInput').implement({
  fields: EvaluationQuestionUpsertWithWhereUniqueWithoutEvaluationInputFields,
});

export const EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationQuestionWhereUniqueInput}),
  data: t.field({"required":true,"type":EvaluationQuestionUpdateWithoutEvaluationInput}),
});
export const EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInput>>('EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInput').implement({
  fields: EvaluationQuestionUpdateWithWhereUniqueWithoutEvaluationInputFields,
});

export const EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationQuestionScalarWhereInput}),
  data: t.field({"required":true,"type":EvaluationQuestionUpdateManyMutationInput}),
});
export const EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInput>>('EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInput').implement({
  fields: EvaluationQuestionUpdateManyWithWhereWithoutEvaluationInputFields,
});

export const EvaluationQuestionScalarWhereInputFields = (t: any) => ({
  AND: t.field({"required":false,"type":[EvaluationQuestionScalarWhereInput]}),
  OR: t.field({"required":false,"type":[EvaluationQuestionScalarWhereInput]}),
  NOT: t.field({"required":false,"type":[EvaluationQuestionScalarWhereInput]}),
  id: t.field({"required":false,"type":IntFilter}),
  evaluationId: t.field({"required":false,"type":IntFilter}),
  inputType: t.field({"required":false,"type":StringFilter}),
  settings: t.field({"required":false,"type":JsonNullableFilter}),
  question: t.field({"required":false,"type":StringNullableFilter}),
  answer: t.field({"required":false,"type":StringFilter}),
});
export const EvaluationQuestionScalarWhereInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionScalarWhereInput>>('EvaluationQuestionScalarWhereInput').implement({
  fields: EvaluationQuestionScalarWhereInputFields,
});

export const EvaluationCreateWithoutAnswersInputFields = (t: any) => ({
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  template: t.field({"required":false,"type":TemplateCreateNestedOneWithoutEvaluationsInput}),
  offer: t.field({"required":false,"type":OfferCreateNestedOneWithoutEvaluationsInput}),
  candidate: t.field({"required":true,"type":CandidateCreateNestedOneWithoutEvaluationsInput}),
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutEvaluationsInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationCreateNestedManyWithoutEvaluationInput}),
  event: t.field({"required":false,"type":EventCreateNestedOneWithoutEvaluationsInput}),
});
export const EvaluationCreateWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateWithoutAnswersInput>>('EvaluationCreateWithoutAnswersInput').implement({
  fields: EvaluationCreateWithoutAnswersInputFields,
});

export const EvaluationCreateOrConnectWithoutAnswersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":EvaluationWhereUniqueInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutAnswersInput}),
});
export const EvaluationCreateOrConnectWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateOrConnectWithoutAnswersInput>>('EvaluationCreateOrConnectWithoutAnswersInput').implement({
  fields: EvaluationCreateOrConnectWithoutAnswersInputFields,
});

export const EvaluationUpsertWithoutAnswersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":EvaluationUpdateWithoutAnswersInput}),
  create: t.field({"required":true,"type":EvaluationCreateWithoutAnswersInput}),
  where: t.field({"required":false,"type":EvaluationWhereInput}),
});
export const EvaluationUpsertWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpsertWithoutAnswersInput>>('EvaluationUpsertWithoutAnswersInput').implement({
  fields: EvaluationUpsertWithoutAnswersInputFields,
});

export const EvaluationUpdateToOneWithWhereWithoutAnswersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":EvaluationWhereInput}),
  data: t.field({"required":true,"type":EvaluationUpdateWithoutAnswersInput}),
});
export const EvaluationUpdateToOneWithWhereWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateToOneWithWhereWithoutAnswersInput>>('EvaluationUpdateToOneWithWhereWithoutAnswersInput').implement({
  fields: EvaluationUpdateToOneWithWhereWithoutAnswersInputFields,
});

export const EvaluationUpdateWithoutAnswersInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
});
export const EvaluationUpdateWithoutAnswersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutAnswersInput>>('EvaluationUpdateWithoutAnswersInput').implement({
  fields: EvaluationUpdateWithoutAnswersInputFields,
});

export const CandidateCreateWithoutSharedCandidateLinkInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutSharedCandidateLinkInput>>('CandidateCreateWithoutSharedCandidateLinkInput').implement({
  fields: CandidateCreateWithoutSharedCandidateLinkInputFields,
});

export const CandidateCreateOrConnectWithoutSharedCandidateLinkInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutSharedCandidateLinkInput}),
});
export const CandidateCreateOrConnectWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutSharedCandidateLinkInput>>('CandidateCreateOrConnectWithoutSharedCandidateLinkInput').implement({
  fields: CandidateCreateOrConnectWithoutSharedCandidateLinkInputFields,
});

export const CandidateUpsertWithoutSharedCandidateLinkInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutSharedCandidateLinkInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutSharedCandidateLinkInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutSharedCandidateLinkInput>>('CandidateUpsertWithoutSharedCandidateLinkInput').implement({
  fields: CandidateUpsertWithoutSharedCandidateLinkInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutSharedCandidateLinkInput}),
});
export const CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInput>>('CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutSharedCandidateLinkInputFields,
});

export const CandidateUpdateWithoutSharedCandidateLinkInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutSharedCandidateLinkInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutSharedCandidateLinkInput>>('CandidateUpdateWithoutSharedCandidateLinkInput').implement({
  fields: CandidateUpdateWithoutSharedCandidateLinkInputFields,
});

export const CompanyCreateWithoutTasksInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  roles: t.field({"required":false,"type":RoleCreateNestedManyWithoutCompanyInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataCreateNestedOneWithoutCompanyInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomCreateNestedManyWithoutCompanyInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataCreateNestedManyWithoutCompanyInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleCreateNestedManyWithoutCompanyInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCompanyInput}),
  departments: t.field({"required":false,"type":DepartmentCreateNestedManyWithoutCompanyInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonCreateNestedManyWithoutCompanyInput}),
  tagSources: t.field({"required":false,"type":TagSourceCreateNestedManyWithoutCompanyInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCompanyInput}),
  offers: t.field({"required":false,"type":OfferCreateNestedManyWithoutCompanyInput}),
  templates: t.field({"required":false,"type":TemplateCreateNestedManyWithoutCompanyInput}),
  owner: t.field({"required":true,"type":UserCreateNestedOneWithoutCompaniesOwnedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleCreateNestedManyWithoutCompanyInput}),
  candidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutCompanyInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolCreateNestedManyWithoutCompanyInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldCreateNestedManyWithoutCompanyInput}),
  logo: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCompanyLogoInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutCompanyInput}),
});
export const CompanyCreateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateWithoutTasksInput>>('CompanyCreateWithoutTasksInput').implement({
  fields: CompanyCreateWithoutTasksInputFields,
});

export const CompanyCreateOrConnectWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CompanyWhereUniqueInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTasksInput}),
});
export const CompanyCreateOrConnectWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateOrConnectWithoutTasksInput>>('CompanyCreateOrConnectWithoutTasksInput').implement({
  fields: CompanyCreateOrConnectWithoutTasksInputFields,
});

export const TaskMemberCreateWithoutTaskInputFields = (t: any) => ({
  teamMember: t.field({"required":true,"type":HiringRoleCreateNestedOneWithoutTasksInput}),
});
export const TaskMemberCreateWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateWithoutTaskInput>>('TaskMemberCreateWithoutTaskInput').implement({
  fields: TaskMemberCreateWithoutTaskInputFields,
});

export const TaskMemberCreateOrConnectWithoutTaskInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  create: t.field({"required":true,"type":TaskMemberCreateWithoutTaskInput}),
});
export const TaskMemberCreateOrConnectWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateOrConnectWithoutTaskInput>>('TaskMemberCreateOrConnectWithoutTaskInput').implement({
  fields: TaskMemberCreateOrConnectWithoutTaskInputFields,
});

export const TaskMemberCreateManyTaskInputEnvelopeFields = (t: any) => ({
  data: t.field({"required":true,"type":[TaskMemberCreateManyTaskInput]}),
  skipDuplicates: t.boolean({"required":false}),
});
export const TaskMemberCreateManyTaskInputEnvelope = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateManyTaskInputEnvelope>>('TaskMemberCreateManyTaskInputEnvelope').implement({
  fields: TaskMemberCreateManyTaskInputEnvelopeFields,
});

export const CandidateCreateWithoutTasksInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutTasksInput>>('CandidateCreateWithoutTasksInput').implement({
  fields: CandidateCreateWithoutTasksInputFields,
});

export const CandidateCreateOrConnectWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutTasksInput}),
});
export const CandidateCreateOrConnectWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutTasksInput>>('CandidateCreateOrConnectWithoutTasksInput').implement({
  fields: CandidateCreateOrConnectWithoutTasksInputFields,
});

export const CompanyUpsertWithoutTasksInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CompanyUpdateWithoutTasksInput}),
  create: t.field({"required":true,"type":CompanyCreateWithoutTasksInput}),
  where: t.field({"required":false,"type":CompanyWhereInput}),
});
export const CompanyUpsertWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpsertWithoutTasksInput>>('CompanyUpsertWithoutTasksInput').implement({
  fields: CompanyUpsertWithoutTasksInputFields,
});

export const CompanyUpdateToOneWithWhereWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CompanyWhereInput}),
  data: t.field({"required":true,"type":CompanyUpdateWithoutTasksInput}),
});
export const CompanyUpdateToOneWithWhereWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateToOneWithWhereWithoutTasksInput>>('CompanyUpdateToOneWithWhereWithoutTasksInput').implement({
  fields: CompanyUpdateToOneWithWhereWithoutTasksInputFields,
});

export const CompanyUpdateWithoutTasksInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  owner: t.field({"required":false,"type":UserUpdateOneRequiredWithoutCompaniesOwnedNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutTasksInput>>('CompanyUpdateWithoutTasksInput').implement({
  fields: CompanyUpdateWithoutTasksInputFields,
});

export const TaskMemberUpsertWithWhereUniqueWithoutTaskInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  update: t.field({"required":true,"type":TaskMemberUpdateWithoutTaskInput}),
  create: t.field({"required":true,"type":TaskMemberCreateWithoutTaskInput}),
});
export const TaskMemberUpsertWithWhereUniqueWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpsertWithWhereUniqueWithoutTaskInput>>('TaskMemberUpsertWithWhereUniqueWithoutTaskInput').implement({
  fields: TaskMemberUpsertWithWhereUniqueWithoutTaskInputFields,
});

export const TaskMemberUpdateWithWhereUniqueWithoutTaskInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberWhereUniqueInput}),
  data: t.field({"required":true,"type":TaskMemberUpdateWithoutTaskInput}),
});
export const TaskMemberUpdateWithWhereUniqueWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateWithWhereUniqueWithoutTaskInput>>('TaskMemberUpdateWithWhereUniqueWithoutTaskInput').implement({
  fields: TaskMemberUpdateWithWhereUniqueWithoutTaskInputFields,
});

export const TaskMemberUpdateManyWithWhereWithoutTaskInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskMemberScalarWhereInput}),
  data: t.field({"required":true,"type":TaskMemberUpdateManyMutationInput}),
});
export const TaskMemberUpdateManyWithWhereWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateManyWithWhereWithoutTaskInput>>('TaskMemberUpdateManyWithWhereWithoutTaskInput').implement({
  fields: TaskMemberUpdateManyWithWhereWithoutTaskInputFields,
});

export const CandidateUpsertWithoutTasksInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutTasksInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutTasksInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutTasksInput>>('CandidateUpsertWithoutTasksInput').implement({
  fields: CandidateUpsertWithoutTasksInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutTasksInput}),
});
export const CandidateUpdateToOneWithWhereWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutTasksInput>>('CandidateUpdateToOneWithWhereWithoutTasksInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutTasksInputFields,
});

export const CandidateUpdateWithoutTasksInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutTasksInput>>('CandidateUpdateWithoutTasksInput').implement({
  fields: CandidateUpdateWithoutTasksInputFields,
});

export const TaskCreateWithoutTaskMembersInputFields = (t: any) => ({
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTasksInput}),
  Candidate: t.field({"required":false,"type":CandidateCreateNestedOneWithoutTasksInput}),
});
export const TaskCreateWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateWithoutTaskMembersInput>>('TaskCreateWithoutTaskMembersInput').implement({
  fields: TaskCreateWithoutTaskMembersInputFields,
});

export const TaskCreateOrConnectWithoutTaskMembersInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TaskWhereUniqueInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutTaskMembersInput}),
});
export const TaskCreateOrConnectWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateOrConnectWithoutTaskMembersInput>>('TaskCreateOrConnectWithoutTaskMembersInput').implement({
  fields: TaskCreateOrConnectWithoutTaskMembersInputFields,
});

export const HiringRoleCreateWithoutTasksInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  follows: t.field({"required":false,"type":FollowCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutTasksInput>>('HiringRoleCreateWithoutTasksInput').implement({
  fields: HiringRoleCreateWithoutTasksInputFields,
});

export const HiringRoleCreateOrConnectWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutTasksInput}),
});
export const HiringRoleCreateOrConnectWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutTasksInput>>('HiringRoleCreateOrConnectWithoutTasksInput').implement({
  fields: HiringRoleCreateOrConnectWithoutTasksInputFields,
});

export const TaskUpsertWithoutTaskMembersInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TaskUpdateWithoutTaskMembersInput}),
  create: t.field({"required":true,"type":TaskCreateWithoutTaskMembersInput}),
  where: t.field({"required":false,"type":TaskWhereInput}),
});
export const TaskUpsertWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpsertWithoutTaskMembersInput>>('TaskUpsertWithoutTaskMembersInput').implement({
  fields: TaskUpsertWithoutTaskMembersInputFields,
});

export const TaskUpdateToOneWithWhereWithoutTaskMembersInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TaskWhereInput}),
  data: t.field({"required":true,"type":TaskUpdateWithoutTaskMembersInput}),
});
export const TaskUpdateToOneWithWhereWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateToOneWithWhereWithoutTaskMembersInput>>('TaskUpdateToOneWithWhereWithoutTaskMembersInput').implement({
  fields: TaskUpdateToOneWithWhereWithoutTaskMembersInputFields,
});

export const TaskUpdateWithoutTaskMembersInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dueDate: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTasksNestedInput}),
  Candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutTasksNestedInput}),
});
export const TaskUpdateWithoutTaskMembersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateWithoutTaskMembersInput>>('TaskUpdateWithoutTaskMembersInput').implement({
  fields: TaskUpdateWithoutTaskMembersInputFields,
});

export const HiringRoleUpsertWithoutTasksInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutTasksInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutTasksInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutTasksInput>>('HiringRoleUpsertWithoutTasksInput').implement({
  fields: HiringRoleUpsertWithoutTasksInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutTasksInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutTasksInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutTasksInput>>('HiringRoleUpdateToOneWithWhereWithoutTasksInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutTasksInputFields,
});

export const HiringRoleUpdateWithoutTasksInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutTasksInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutTasksInput>>('HiringRoleUpdateWithoutTasksInput').implement({
  fields: HiringRoleUpdateWithoutTasksInputFields,
});

export const OfferCreateWithoutFollowsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutOffersInput}),
  department: t.field({"required":false,"type":DepartmentCreateNestedOneWithoutOffersInput}),
  recruiter: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferRecruiterInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutOfferHiringManagerInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutScreeningQuestionsTemplateInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateCreateNestedOneWithoutPipelineTemplateInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateCreateNestedOneWithoutAutoConfirmationEmailInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutOfferInput}),
  files: t.field({"required":false,"type":OfferFileCreateNestedManyWithoutOfferInput}),
  offerTags: t.field({"required":false,"type":OfferTagCreateNestedManyWithoutOfferInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutOfferInput}),
  matches: t.field({"required":false,"type":MatchCreateNestedManyWithoutOfferInput}),
  hired: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredAtInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutOfferInput}),
});
export const OfferCreateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateWithoutFollowsInput>>('OfferCreateWithoutFollowsInput').implement({
  fields: OfferCreateWithoutFollowsInputFields,
});

export const OfferCreateOrConnectWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":OfferWhereUniqueInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutFollowsInput}),
});
export const OfferCreateOrConnectWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateOrConnectWithoutFollowsInput>>('OfferCreateOrConnectWithoutFollowsInput').implement({
  fields: OfferCreateOrConnectWithoutFollowsInputFields,
});

export const CandidateCreateWithoutFollowsInputFields = (t: any) => ({
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  referrer: t.field({"required":false,"type":TagSourceCreateNestedOneWithoutCandidateReferrerInput}),
  cv: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCvInput}),
  avatar: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateAvatarInput}),
  coverLetter: t.field({"required":false,"type":AttachmentCreateNestedOneWithoutCandidateCoverLetterInput}),
  hiredAt: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiredInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleCreateNestedOneWithoutHiredCandidatesInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutCandidateInput}),
  offers: t.field({"required":false,"type":MatchCreateNestedManyWithoutCandidateInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutCandidateInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagCreateNestedManyWithoutCandidateInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldCreateNestedManyWithoutCandidateInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutCandidateInput}),
  tasks: t.field({"required":false,"type":TaskCreateNestedManyWithoutCandidateInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkCreateNestedManyWithoutCandidateInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutCandidatesInput}),
  events: t.field({"required":false,"type":EventCreateNestedManyWithoutCandidatesInput}),
});
export const CandidateCreateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateWithoutFollowsInput>>('CandidateCreateWithoutFollowsInput').implement({
  fields: CandidateCreateWithoutFollowsInputFields,
});

export const CandidateCreateOrConnectWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":CandidateWhereUniqueInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutFollowsInput}),
});
export const CandidateCreateOrConnectWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateOrConnectWithoutFollowsInput>>('CandidateCreateOrConnectWithoutFollowsInput').implement({
  fields: CandidateCreateOrConnectWithoutFollowsInputFields,
});

export const TalentPoolCreateWithoutFollowsInputFields = (t: any) => ({
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  files: t.field({"required":false,"type":TalentPoolFileCreateNestedManyWithoutTalentPoolInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchCreateNestedManyWithoutTalentPoolInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutTalentPoolInput}),
});
export const TalentPoolCreateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateWithoutFollowsInput>>('TalentPoolCreateWithoutFollowsInput').implement({
  fields: TalentPoolCreateWithoutFollowsInputFields,
});

export const TalentPoolCreateOrConnectWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":TalentPoolWhereUniqueInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutFollowsInput}),
});
export const TalentPoolCreateOrConnectWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateOrConnectWithoutFollowsInput>>('TalentPoolCreateOrConnectWithoutFollowsInput').implement({
  fields: TalentPoolCreateOrConnectWithoutFollowsInputFields,
});

export const HiringRoleCreateWithoutFollowsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  user: t.field({"required":true,"type":UserCreateNestedOneWithoutHiringRolesInput}),
  role: t.field({"required":true,"type":RoleCreateNestedOneWithoutHiringRolesInput}),
  company: t.field({"required":true,"type":CompanyCreateNestedOneWithoutHiringRolesInput}),
  attachments: t.field({"required":false,"type":AttachmentCreateNestedManyWithoutUploaderInput}),
  auditLogs: t.field({"required":false,"type":AuditLogCreateNestedManyWithoutUserInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerCreateNestedManyWithoutTeamMemberInput}),
  createdEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutCreatedByInput}),
  offerRecruiter: t.field({"required":false,"type":OfferCreateNestedOneWithoutRecruiterInput}),
  offerHiringManager: t.field({"required":false,"type":OfferCreateNestedOneWithoutHiringManagerInput}),
  memberships: t.field({"required":false,"type":MembershipCreateNestedManyWithoutTeamMemberInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityCreateNestedManyWithoutTeamMemberInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateCreateNestedManyWithoutHiredByInput}),
  evaluations: t.field({"required":false,"type":EvaluationCreateNestedManyWithoutTeamMemberInput}),
  tasks: t.field({"required":false,"type":TaskMemberCreateNestedManyWithoutTeamMemberInput}),
  interviewerEvents: t.field({"required":false,"type":EventCreateNestedManyWithoutInterviewersInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerCreateNestedManyWithoutTeamMemberInput}),
});
export const HiringRoleCreateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateWithoutFollowsInput>>('HiringRoleCreateWithoutFollowsInput').implement({
  fields: HiringRoleCreateWithoutFollowsInputFields,
});

export const HiringRoleCreateOrConnectWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":true,"type":HiringRoleWhereUniqueInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutFollowsInput}),
});
export const HiringRoleCreateOrConnectWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateOrConnectWithoutFollowsInput>>('HiringRoleCreateOrConnectWithoutFollowsInput').implement({
  fields: HiringRoleCreateOrConnectWithoutFollowsInputFields,
});

export const OfferUpsertWithoutFollowsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":OfferUpdateWithoutFollowsInput}),
  create: t.field({"required":true,"type":OfferCreateWithoutFollowsInput}),
  where: t.field({"required":false,"type":OfferWhereInput}),
});
export const OfferUpsertWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpsertWithoutFollowsInput>>('OfferUpsertWithoutFollowsInput').implement({
  fields: OfferUpsertWithoutFollowsInputFields,
});

export const OfferUpdateToOneWithWhereWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":OfferWhereInput}),
  data: t.field({"required":true,"type":OfferUpdateWithoutFollowsInput}),
});
export const OfferUpdateToOneWithWhereWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateToOneWithWhereWithoutFollowsInput>>('OfferUpdateToOneWithWhereWithoutFollowsInput').implement({
  fields: OfferUpdateToOneWithWhereWithoutFollowsInputFields,
});

export const OfferUpdateWithoutFollowsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutFollowsInput>>('OfferUpdateWithoutFollowsInput').implement({
  fields: OfferUpdateWithoutFollowsInputFields,
});

export const CandidateUpsertWithoutFollowsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":CandidateUpdateWithoutFollowsInput}),
  create: t.field({"required":true,"type":CandidateCreateWithoutFollowsInput}),
  where: t.field({"required":false,"type":CandidateWhereInput}),
});
export const CandidateUpsertWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpsertWithoutFollowsInput>>('CandidateUpsertWithoutFollowsInput').implement({
  fields: CandidateUpsertWithoutFollowsInputFields,
});

export const CandidateUpdateToOneWithWhereWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":CandidateWhereInput}),
  data: t.field({"required":true,"type":CandidateUpdateWithoutFollowsInput}),
});
export const CandidateUpdateToOneWithWhereWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateToOneWithWhereWithoutFollowsInput>>('CandidateUpdateToOneWithWhereWithoutFollowsInput').implement({
  fields: CandidateUpdateToOneWithWhereWithoutFollowsInputFields,
});

export const CandidateUpdateWithoutFollowsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutFollowsInput>>('CandidateUpdateWithoutFollowsInput').implement({
  fields: CandidateUpdateWithoutFollowsInputFields,
});

export const TalentPoolUpsertWithoutFollowsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":TalentPoolUpdateWithoutFollowsInput}),
  create: t.field({"required":true,"type":TalentPoolCreateWithoutFollowsInput}),
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
});
export const TalentPoolUpsertWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpsertWithoutFollowsInput>>('TalentPoolUpsertWithoutFollowsInput').implement({
  fields: TalentPoolUpsertWithoutFollowsInputFields,
});

export const TalentPoolUpdateToOneWithWhereWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":TalentPoolWhereInput}),
  data: t.field({"required":true,"type":TalentPoolUpdateWithoutFollowsInput}),
});
export const TalentPoolUpdateToOneWithWhereWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateToOneWithWhereWithoutFollowsInput>>('TalentPoolUpdateToOneWithWhereWithoutFollowsInput').implement({
  fields: TalentPoolUpdateToOneWithWhereWithoutFollowsInputFields,
});

export const TalentPoolUpdateWithoutFollowsInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  files: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutTalentPoolNestedInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTalentPoolNestedInput}),
});
export const TalentPoolUpdateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateWithoutFollowsInput>>('TalentPoolUpdateWithoutFollowsInput').implement({
  fields: TalentPoolUpdateWithoutFollowsInputFields,
});

export const HiringRoleUpsertWithoutFollowsInputFields = (t: any) => ({
  update: t.field({"required":true,"type":HiringRoleUpdateWithoutFollowsInput}),
  create: t.field({"required":true,"type":HiringRoleCreateWithoutFollowsInput}),
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
});
export const HiringRoleUpsertWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpsertWithoutFollowsInput>>('HiringRoleUpsertWithoutFollowsInput').implement({
  fields: HiringRoleUpsertWithoutFollowsInputFields,
});

export const HiringRoleUpdateToOneWithWhereWithoutFollowsInputFields = (t: any) => ({
  where: t.field({"required":false,"type":HiringRoleWhereInput}),
  data: t.field({"required":true,"type":HiringRoleUpdateWithoutFollowsInput}),
});
export const HiringRoleUpdateToOneWithWhereWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateToOneWithWhereWithoutFollowsInput>>('HiringRoleUpdateToOneWithWhereWithoutFollowsInput').implement({
  fields: HiringRoleUpdateToOneWithWhereWithoutFollowsInputFields,
});

export const HiringRoleUpdateWithoutFollowsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutFollowsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutFollowsInput>>('HiringRoleUpdateWithoutFollowsInput').implement({
  fields: HiringRoleUpdateWithoutFollowsInputFields,
});

export const AccountCreateManyUserInputFields = (t: any) => ({
  id: t.string({"required":false}),
  type: t.string({"required":true}),
  provider: t.string({"required":true}),
  providerAccountId: t.string({"required":true}),
  refresh_token: t.string({"required":false}),
  access_token: t.string({"required":false}),
  expires_at: t.int({"required":false}),
  token_type: t.string({"required":false}),
  scope: t.string({"required":false}),
  id_token: t.string({"required":false}),
  session_state: t.string({"required":false}),
});
export const AccountCreateManyUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountCreateManyUserInput>>('AccountCreateManyUserInput').implement({
  fields: AccountCreateManyUserInputFields,
});

export const SessionCreateManyUserInputFields = (t: any) => ({
  id: t.string({"required":false}),
  sessionToken: t.string({"required":true}),
  expires: t.field({"required":true,"type":DateTime}),
});
export const SessionCreateManyUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionCreateManyUserInput>>('SessionCreateManyUserInput').implement({
  fields: SessionCreateManyUserInputFields,
});

export const HiringRoleCreateManyUserInputFields = (t: any) => ({
  id: t.int({"required":false}),
  roleId: t.int({"required":true}),
  companyId: t.string({"required":true}),
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const HiringRoleCreateManyUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyUserInput>>('HiringRoleCreateManyUserInput').implement({
  fields: HiringRoleCreateManyUserInputFields,
});

export const CompanyCreateManyOwnerInputFields = (t: any) => ({
  id: t.string({"required":false}),
  name: t.string({"required":true}),
  phone: t.string({"required":false}),
  address: t.string({"required":false}),
  city: t.string({"required":false}),
  state: t.string({"required":false}),
  country: t.string({"required":false}),
  companyInbox: t.string({"required":false}),
  subdomain: t.string({"required":false}),
  gdprEnable: t.boolean({"required":false}),
  gdprRetention: t.int({"required":false}),
  gdprPrivacyPolicyLink: t.string({"required":false}),
  gdprEmailFooter: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  logoId: t.int({"required":false}),
});
export const CompanyCreateManyOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyCreateManyOwnerInput>>('CompanyCreateManyOwnerInput').implement({
  fields: CompanyCreateManyOwnerInputFields,
});

export const AccountUpdateWithoutUserInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  provider: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  providerAccountId: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  refresh_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  access_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  expires_at: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  token_type: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  scope: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  id_token: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  session_state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
});
export const AccountUpdateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AccountUpdateWithoutUserInput>>('AccountUpdateWithoutUserInput').implement({
  fields: AccountUpdateWithoutUserInputFields,
});

export const SessionUpdateWithoutUserInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  sessionToken: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expires: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const SessionUpdateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SessionUpdateWithoutUserInput>>('SessionUpdateWithoutUserInput').implement({
  fields: SessionUpdateWithoutUserInputFields,
});

export const HiringRoleUpdateWithoutUserInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutUserInput>>('HiringRoleUpdateWithoutUserInput').implement({
  fields: HiringRoleUpdateWithoutUserInputFields,
});

export const CompanyUpdateWithoutOwnerInputFields = (t: any) => ({
  id: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  address: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  city: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  state: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  country: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  companyInbox: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  subdomain: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEnable: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  gdprRetention: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  gdprPrivacyPolicyLink: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  gdprEmailFooter: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  roles: t.field({"required":false,"type":RoleUpdateManyWithoutCompanyNestedInput}),
  subscription: t.field({"required":false,"type":SubscriptionDataUpdateOneWithoutCompanyNestedInput}),
  meetingRooms: t.field({"required":false,"type":MeetingRoomUpdateManyWithoutCompanyNestedInput}),
  metadata: t.field({"required":false,"type":CompanyMetadataUpdateManyWithoutCompanyNestedInput}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateManyWithoutCompanyNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCompanyNestedInput}),
  departments: t.field({"required":false,"type":DepartmentUpdateManyWithoutCompanyNestedInput}),
  disqualifyReasons: t.field({"required":false,"type":DisqualifyReasonUpdateManyWithoutCompanyNestedInput}),
  tagSources: t.field({"required":false,"type":TagSourceUpdateManyWithoutCompanyNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCompanyNestedInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutCompanyNestedInput}),
  templates: t.field({"required":false,"type":TemplateUpdateManyWithoutCompanyNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCompanyNestedInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutCompanyNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutCompanyNestedInput}),
  TalentPool: t.field({"required":false,"type":TalentPoolUpdateManyWithoutCompanyNestedInput}),
  CustomFields: t.field({"required":false,"type":CustomFieldUpdateManyWithoutCompanyNestedInput}),
  logo: t.field({"required":false,"type":AttachmentUpdateOneWithoutCompanyLogoNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutCompanyNestedInput}),
});
export const CompanyUpdateWithoutOwnerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyUpdateWithoutOwnerInput>>('CompanyUpdateWithoutOwnerInput').implement({
  fields: CompanyUpdateWithoutOwnerInputFields,
});

export const OfferFileCreateManyAttachmentInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
});
export const OfferFileCreateManyAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateManyAttachmentInput>>('OfferFileCreateManyAttachmentInput').implement({
  fields: OfferFileCreateManyAttachmentInputFields,
});

export const TalentPoolFileCreateManyAttachmentInputFields = (t: any) => ({
  id: t.int({"required":false}),
  talentPoolId: t.int({"required":true}),
});
export const TalentPoolFileCreateManyAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateManyAttachmentInput>>('TalentPoolFileCreateManyAttachmentInput').implement({
  fields: TalentPoolFileCreateManyAttachmentInputFields,
});

export const OfferFileUpdateWithoutAttachmentInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutFilesNestedInput}),
});
export const OfferFileUpdateWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateWithoutAttachmentInput>>('OfferFileUpdateWithoutAttachmentInput').implement({
  fields: OfferFileUpdateWithoutAttachmentInputFields,
});

export const TalentPoolFileUpdateWithoutAttachmentInputFields = (t: any) => ({
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneRequiredWithoutFilesNestedInput}),
});
export const TalentPoolFileUpdateWithoutAttachmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateWithoutAttachmentInput>>('TalentPoolFileUpdateWithoutAttachmentInput').implement({
  fields: TalentPoolFileUpdateWithoutAttachmentInputFields,
});

export const AttachmentCreateManyUploaderInputFields = (t: any) => ({
  id: t.int({"required":false}),
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  companyId: t.string({"required":true}),
});
export const AttachmentCreateManyUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateManyUploaderInput>>('AttachmentCreateManyUploaderInput').implement({
  fields: AttachmentCreateManyUploaderInputFields,
});

export const AuditLogCreateManyUserInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
});
export const AuditLogCreateManyUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyUserInput>>('AuditLogCreateManyUserInput').implement({
  fields: AuditLogCreateManyUserInputFields,
});

export const EventScheduleInterviewerCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventScheduleId: t.int({"required":true}),
  availability: t.field({"required":true,"type":Json}),
});
export const EventScheduleInterviewerCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateManyTeamMemberInput>>('EventScheduleInterviewerCreateManyTeamMemberInput').implement({
  fields: EventScheduleInterviewerCreateManyTeamMemberInputFields,
});

export const EventCreateManyCreatedByInputFields = (t: any) => ({
  id: t.int({"required":false}),
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EventCreateManyCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateManyCreatedByInput>>('EventCreateManyCreatedByInput').implement({
  fields: EventCreateManyCreatedByInputFields,
});

export const MembershipCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  roleId: t.int({"required":false}),
  offerId: t.int({"required":true}),
});
export const MembershipCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyTeamMemberInput>>('MembershipCreateManyTeamMemberInput').implement({
  fields: MembershipCreateManyTeamMemberInputFields,
});

export const StageVisibilityCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  roleId: t.int({"required":false}),
  stageId: t.int({"required":true}),
});
export const StageVisibilityCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyTeamMemberInput>>('StageVisibilityCreateManyTeamMemberInput').implement({
  fields: StageVisibilityCreateManyTeamMemberInputFields,
});

export const CandidateCreateManyHiredByInputFields = (t: any) => ({
  id: t.int({"required":false}),
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  referrerId: t.int({"required":false}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  hiredAtId: t.int({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const CandidateCreateManyHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyHiredByInput>>('CandidateCreateManyHiredByInput').implement({
  fields: CandidateCreateManyHiredByInputFields,
});

export const EvaluationCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  templateId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  eventId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyTeamMemberInput>>('EvaluationCreateManyTeamMemberInput').implement({
  fields: EvaluationCreateManyTeamMemberInputFields,
});

export const TaskMemberCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  taskId: t.int({"required":true}),
});
export const TaskMemberCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateManyTeamMemberInput>>('TaskMemberCreateManyTeamMemberInput').implement({
  fields: TaskMemberCreateManyTeamMemberInputFields,
});

export const FollowCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  talentPoolId: t.int({"required":false}),
});
export const FollowCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyTeamMemberInput>>('FollowCreateManyTeamMemberInput').implement({
  fields: FollowCreateManyTeamMemberInputFields,
});

export const EventInterviewerCreateManyTeamMemberInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventId: t.int({"required":true}),
});
export const EventInterviewerCreateManyTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateManyTeamMemberInput>>('EventInterviewerCreateManyTeamMemberInput').implement({
  fields: EventInterviewerCreateManyTeamMemberInputFields,
});

export const AttachmentUpdateWithoutUploaderInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAttachmentsNestedInput}),
});
export const AttachmentUpdateWithoutUploaderInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutUploaderInput>>('AttachmentUpdateWithoutUploaderInput').implement({
  fields: AttachmentUpdateWithoutUploaderInputFields,
});

export const AuditLogUpdateWithoutUserInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAuditLogsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutAuditLogsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutAuditLogsNestedInput}),
});
export const AuditLogUpdateWithoutUserInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithoutUserInput>>('AuditLogUpdateWithoutUserInput').implement({
  fields: AuditLogUpdateWithoutUserInputFields,
});

export const EventScheduleInterviewerUpdateWithoutTeamMemberInputFields = (t: any) => ({
  availability: t.field({"required":false,"type":Json}),
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput}),
});
export const EventScheduleInterviewerUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateWithoutTeamMemberInput>>('EventScheduleInterviewerUpdateWithoutTeamMemberInput').implement({
  fields: EventScheduleInterviewerUpdateWithoutTeamMemberInputFields,
});

export const EventUpdateWithoutCreatedByInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateWithoutCreatedByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutCreatedByInput>>('EventUpdateWithoutCreatedByInput').implement({
  fields: EventUpdateWithoutCreatedByInputFields,
});

export const MembershipUpdateWithoutTeamMemberInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutMembershipsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMembershipsNestedInput}),
});
export const MembershipUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithoutTeamMemberInput>>('MembershipUpdateWithoutTeamMemberInput').implement({
  fields: MembershipUpdateWithoutTeamMemberInputFields,
});

export const StageVisibilityUpdateWithoutTeamMemberInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutStageVisibilityNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneRequiredWithoutVisibilityNestedInput}),
});
export const StageVisibilityUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithoutTeamMemberInput>>('StageVisibilityUpdateWithoutTeamMemberInput').implement({
  fields: StageVisibilityUpdateWithoutTeamMemberInputFields,
});

export const CandidateUpdateWithoutHiredByInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutHiredByInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutHiredByInput>>('CandidateUpdateWithoutHiredByInput').implement({
  fields: CandidateUpdateWithoutHiredByInputFields,
});

export const EvaluationUpdateWithoutTeamMemberInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutTeamMemberInput>>('EvaluationUpdateWithoutTeamMemberInput').implement({
  fields: EvaluationUpdateWithoutTeamMemberInputFields,
});

export const TaskMemberUpdateWithoutTeamMemberInputFields = (t: any) => ({
  task: t.field({"required":false,"type":TaskUpdateOneRequiredWithoutTaskMembersNestedInput}),
});
export const TaskMemberUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateWithoutTeamMemberInput>>('TaskMemberUpdateWithoutTeamMemberInput').implement({
  fields: TaskMemberUpdateWithoutTeamMemberInputFields,
});

export const FollowUpdateWithoutTeamMemberInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutFollowsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutFollowsNestedInput}),
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneWithoutFollowsNestedInput}),
});
export const FollowUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithoutTeamMemberInput>>('FollowUpdateWithoutTeamMemberInput').implement({
  fields: FollowUpdateWithoutTeamMemberInputFields,
});

export const EventUpdateWithoutInterviewersInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateWithoutInterviewersInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutInterviewersInput>>('EventUpdateWithoutInterviewersInput').implement({
  fields: EventUpdateWithoutInterviewersInputFields,
});

export const EventInterviewerUpdateWithoutTeamMemberInputFields = (t: any) => ({
  event: t.field({"required":false,"type":EventUpdateOneRequiredWithoutEventInterviewerNestedInput}),
});
export const EventInterviewerUpdateWithoutTeamMemberInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateWithoutTeamMemberInput>>('EventInterviewerUpdateWithoutTeamMemberInput').implement({
  fields: EventInterviewerUpdateWithoutTeamMemberInputFields,
});

export const HiringRoleCreateManyRoleInputFields = (t: any) => ({
  id: t.int({"required":false}),
  userId: t.string({"required":true}),
  companyId: t.string({"required":true}),
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const HiringRoleCreateManyRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyRoleInput>>('HiringRoleCreateManyRoleInput').implement({
  fields: HiringRoleCreateManyRoleInputFields,
});

export const MembershipCreateManyRoleInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  offerId: t.int({"required":true}),
});
export const MembershipCreateManyRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyRoleInput>>('MembershipCreateManyRoleInput').implement({
  fields: MembershipCreateManyRoleInputFields,
});

export const StageVisibilityCreateManyRoleInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  stageId: t.int({"required":true}),
});
export const StageVisibilityCreateManyRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyRoleInput>>('StageVisibilityCreateManyRoleInput').implement({
  fields: StageVisibilityCreateManyRoleInputFields,
});

export const HiringRoleUpdateWithoutRoleInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutRoleInput>>('HiringRoleUpdateWithoutRoleInput').implement({
  fields: HiringRoleUpdateWithoutRoleInputFields,
});

export const MembershipUpdateWithoutRoleInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutMembershipsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMembershipsNestedInput}),
});
export const MembershipUpdateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithoutRoleInput>>('MembershipUpdateWithoutRoleInput').implement({
  fields: MembershipUpdateWithoutRoleInputFields,
});

export const StageVisibilityUpdateWithoutRoleInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneRequiredWithoutVisibilityNestedInput}),
});
export const StageVisibilityUpdateWithoutRoleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithoutRoleInput>>('StageVisibilityUpdateWithoutRoleInput').implement({
  fields: StageVisibilityUpdateWithoutRoleInputFields,
});

export const RoleCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const RoleCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleCreateManyCompanyInput>>('RoleCreateManyCompanyInput').implement({
  fields: RoleCreateManyCompanyInputFields,
});

export const MeetingRoomCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  type: t.string({"required":true}),
  link: t.string({"required":true}),
});
export const MeetingRoomCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomCreateManyCompanyInput>>('MeetingRoomCreateManyCompanyInput').implement({
  fields: MeetingRoomCreateManyCompanyInputFields,
});

export const CompanyMetadataCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  key: t.string({"required":true}),
  value: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  type: t.string({"required":false}),
});
export const CompanyMetadataCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataCreateManyCompanyInput>>('CompanyMetadataCreateManyCompanyInput').implement({
  fields: CompanyMetadataCreateManyCompanyInputFields,
});

export const EventScheduleCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  dateRange: t.int({"required":true}),
  expiresAfter: t.int({"required":true}),
  inviteAll: t.boolean({"required":true}),
  bufferTime: t.int({"required":true}),
  ignoreDayEvents: t.boolean({"required":true}),
  meetingLimit: t.int({"required":true}),
  duration: t.int({"required":true}),
  Interval: t.int({"required":true}),
  type: t.string({"required":true}),
  timezone: t.string({"required":true}),
  location: t.string({"required":true}),
  note: t.string({"required":true}),
  privateNote: t.string({"required":true}),
  link: t.string({"required":true}),
});
export const EventScheduleCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleCreateManyCompanyInput>>('EventScheduleCreateManyCompanyInput').implement({
  fields: EventScheduleCreateManyCompanyInputFields,
});

export const EventCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  date: t.field({"required":true,"type":DateTime}),
  duration: t.int({"required":false}),
  type: t.string({"required":true}),
  location: t.string({"required":false}),
  note: t.string({"required":false}),
  privateNote: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
  createdById: t.int({"required":true}),
});
export const EventCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventCreateManyCompanyInput>>('EventCreateManyCompanyInput').implement({
  fields: EventCreateManyCompanyInputFields,
});

export const DepartmentCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
});
export const DepartmentCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentCreateManyCompanyInput>>('DepartmentCreateManyCompanyInput').implement({
  fields: DepartmentCreateManyCompanyInputFields,
});

export const DisqualifyReasonCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  action: t.field({"required":true,"type":Json}),
});
export const DisqualifyReasonCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonCreateManyCompanyInput>>('DisqualifyReasonCreateManyCompanyInput').implement({
  fields: DisqualifyReasonCreateManyCompanyInputFields,
});

export const TagSourceCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  type: t.field({"required":true,"type":TagSourceType}),
});
export const TagSourceCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceCreateManyCompanyInput>>('TagSourceCreateManyCompanyInput').implement({
  fields: TagSourceCreateManyCompanyInputFields,
});

export const AuditLogCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  userId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
});
export const AuditLogCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyCompanyInput>>('AuditLogCreateManyCompanyInput').implement({
  fields: AuditLogCreateManyCompanyInputFields,
});

export const OfferCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  departmentId: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  screeningQuestionsTemplateId: t.int({"required":false}),
  pipelineTemplateId: t.int({"required":false}),
  autoConfirmationEmailId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyCompanyInput>>('OfferCreateManyCompanyInput').implement({
  fields: OfferCreateManyCompanyInputFields,
});

export const TemplateCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  isCompanyWide: t.boolean({"required":false}),
  type: t.field({"required":true,"type":TemplateTypes}),
  name: t.string({"required":true}),
  category: t.string({"required":false}),
});
export const TemplateCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateCreateManyCompanyInput>>('TemplateCreateManyCompanyInput').implement({
  fields: TemplateCreateManyCompanyInputFields,
});

export const TaskCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
  candidateId: t.int({"required":false}),
});
export const TaskCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateManyCompanyInput>>('TaskCreateManyCompanyInput').implement({
  fields: TaskCreateManyCompanyInputFields,
});

export const HiringRoleCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  userId: t.string({"required":true}),
  roleId: t.int({"required":true}),
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const HiringRoleCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleCreateManyCompanyInput>>('HiringRoleCreateManyCompanyInput').implement({
  fields: HiringRoleCreateManyCompanyInputFields,
});

export const CandidateCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  referrerId: t.int({"required":false}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  hiredAtId: t.int({"required":false}),
  hiredById: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const CandidateCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyCompanyInput>>('CandidateCreateManyCompanyInput').implement({
  fields: CandidateCreateManyCompanyInputFields,
});

export const TalentPoolCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  description: t.string({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const TalentPoolCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolCreateManyCompanyInput>>('TalentPoolCreateManyCompanyInput').implement({
  fields: TalentPoolCreateManyCompanyInputFields,
});

export const CustomFieldCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.string({"required":false}),
  key: t.string({"required":true}),
  defaultValue: t.string({"required":false}),
  settings: t.field({"required":false,"type":Json}),
});
export const CustomFieldCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldCreateManyCompanyInput>>('CustomFieldCreateManyCompanyInput').implement({
  fields: CustomFieldCreateManyCompanyInputFields,
});

export const AttachmentCreateManyCompanyInputFields = (t: any) => ({
  id: t.int({"required":false}),
  contentType: t.string({"required":true}),
  filename: t.string({"required":true}),
  path: t.string({"required":true}),
  size: t.int({"required":false}),
  uploaderId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const AttachmentCreateManyCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentCreateManyCompanyInput>>('AttachmentCreateManyCompanyInput').implement({
  fields: AttachmentCreateManyCompanyInputFields,
});

export const RoleUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  abilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  hiringRoles: t.field({"required":false,"type":HiringRoleUpdateManyWithoutRoleNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutRoleNestedInput}),
  stageVisibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutRoleNestedInput}),
});
export const RoleUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.RoleUpdateWithoutCompanyInput>>('RoleUpdateWithoutCompanyInput').implement({
  fields: RoleUpdateWithoutCompanyInputFields,
});

export const MeetingRoomUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const MeetingRoomUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MeetingRoomUpdateWithoutCompanyInput>>('MeetingRoomUpdateWithoutCompanyInput').implement({
  fields: MeetingRoomUpdateWithoutCompanyInputFields,
});

export const CompanyMetadataUpdateWithoutCompanyInputFields = (t: any) => ({
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const CompanyMetadataUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CompanyMetadataUpdateWithoutCompanyInput>>('CompanyMetadataUpdateWithoutCompanyInput').implement({
  fields: CompanyMetadataUpdateWithoutCompanyInputFields,
});

export const EventScheduleUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dateRange: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  expiresAfter: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  inviteAll: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  bufferTime: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  ignoreDayEvents: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  meetingLimit: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  Interval: t.field({"required":false,"type":IntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  timezone: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutEventScheduleNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEventScheduleNestedInput}),
});
export const EventScheduleUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleUpdateWithoutCompanyInput>>('EventScheduleUpdateWithoutCompanyInput').implement({
  fields: EventScheduleUpdateWithoutCompanyInputFields,
});

export const EventUpdateWithoutCompanyInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  candidates: t.field({"required":false,"type":CandidateUpdateManyWithoutEventsNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutCompanyInput>>('EventUpdateWithoutCompanyInput').implement({
  fields: EventUpdateWithoutCompanyInputFields,
});

export const DepartmentUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  offers: t.field({"required":false,"type":OfferUpdateManyWithoutDepartmentNestedInput}),
});
export const DepartmentUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DepartmentUpdateWithoutCompanyInput>>('DepartmentUpdateWithoutCompanyInput').implement({
  fields: DepartmentUpdateWithoutCompanyInputFields,
});

export const DisqualifyReasonUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":Json}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutDisqualifyReasonNestedInput}),
});
export const DisqualifyReasonUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.DisqualifyReasonUpdateWithoutCompanyInput>>('DisqualifyReasonUpdateWithoutCompanyInput').implement({
  fields: DisqualifyReasonUpdateWithoutCompanyInputFields,
});

export const TagSourceUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTagSourceTypeFieldUpdateOperationsInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutTagNestedInput}),
  candidateReferrer: t.field({"required":false,"type":CandidateUpdateManyWithoutReferrerNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutTagNestedInput}),
});
export const TagSourceUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TagSourceUpdateWithoutCompanyInput>>('TagSourceUpdateWithoutCompanyInput').implement({
  fields: TagSourceUpdateWithoutCompanyInputFields,
});

export const AuditLogUpdateWithoutCompanyInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAuditLogsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutAuditLogsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutAuditLogsNestedInput}),
});
export const AuditLogUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithoutCompanyInput>>('AuditLogUpdateWithoutCompanyInput').implement({
  fields: AuditLogUpdateWithoutCompanyInputFields,
});

export const OfferUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutCompanyInput>>('OfferUpdateWithoutCompanyInput').implement({
  fields: OfferUpdateWithoutCompanyInputFields,
});

export const TemplateUpdateWithoutCompanyInputFields = (t: any) => ({
  isCompanyWide: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":EnumTemplateTypesFieldUpdateOperationsInput}),
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":OfferUpdateManyWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":OfferUpdateManyWithoutAutoConfirmationEmailNestedInput}),
  stages: t.field({"required":false,"type":StageUpdateManyWithoutTemplateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTemplateNestedInput}),
});
export const TemplateUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TemplateUpdateWithoutCompanyInput>>('TemplateUpdateWithoutCompanyInput').implement({
  fields: TemplateUpdateWithoutCompanyInputFields,
});

export const TaskUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dueDate: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTaskNestedInput}),
  Candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutTasksNestedInput}),
});
export const TaskUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateWithoutCompanyInput>>('TaskUpdateWithoutCompanyInput').implement({
  fields: TaskUpdateWithoutCompanyInputFields,
});

export const HiringRoleUpdateWithoutCompanyInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  interviewerEvents: t.field({"required":false,"type":EventUpdateManyWithoutInterviewersNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutCompanyInput>>('HiringRoleUpdateWithoutCompanyInput').implement({
  fields: HiringRoleUpdateWithoutCompanyInputFields,
});

export const CandidateUpdateWithoutCompanyInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutCompanyInput>>('CandidateUpdateWithoutCompanyInput').implement({
  fields: CandidateUpdateWithoutCompanyInputFields,
});

export const TalentPoolUpdateWithoutCompanyInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  files: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutTalentPoolNestedInput}),
  matches: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutTalentPoolNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTalentPoolNestedInput}),
});
export const TalentPoolUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolUpdateWithoutCompanyInput>>('TalentPoolUpdateWithoutCompanyInput').implement({
  fields: TalentPoolUpdateWithoutCompanyInputFields,
});

export const CustomFieldUpdateWithoutCompanyInputFields = (t: any) => ({
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  key: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  defaultValue: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCustomFieldNestedInput}),
});
export const CustomFieldUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CustomFieldUpdateWithoutCompanyInput>>('CustomFieldUpdateWithoutCompanyInput').implement({
  fields: CustomFieldUpdateWithoutCompanyInputFields,
});

export const AttachmentUpdateWithoutCompanyInputFields = (t: any) => ({
  contentType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  filename: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  path: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  size: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  userProfilePhoto: t.field({"required":false,"type":UserUpdateOneWithoutPhotoNestedInput}),
  candidateCv: t.field({"required":false,"type":CandidateUpdateOneWithoutCvNestedInput}),
  candidateAvatar: t.field({"required":false,"type":CandidateUpdateOneWithoutAvatarNestedInput}),
  candidateCoverLetter: t.field({"required":false,"type":CandidateUpdateOneWithoutCoverLetterNestedInput}),
  companyLogo: t.field({"required":false,"type":CompanyUpdateOneWithoutLogoNestedInput}),
  uploader: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAttachmentsNestedInput}),
  offerFiles: t.field({"required":false,"type":OfferFileUpdateManyWithoutAttachmentNestedInput}),
  talentPoolFiles: t.field({"required":false,"type":TalentPoolFileUpdateManyWithoutAttachmentNestedInput}),
});
export const AttachmentUpdateWithoutCompanyInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AttachmentUpdateWithoutCompanyInput>>('AttachmentUpdateWithoutCompanyInput').implement({
  fields: AttachmentUpdateWithoutCompanyInputFields,
});

export const OfferCreateManyDepartmentInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  screeningQuestionsTemplateId: t.int({"required":false}),
  pipelineTemplateId: t.int({"required":false}),
  autoConfirmationEmailId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyDepartmentInput>>('OfferCreateManyDepartmentInput').implement({
  fields: OfferCreateManyDepartmentInputFields,
});

export const OfferUpdateWithoutDepartmentInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutDepartmentInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutDepartmentInput>>('OfferUpdateWithoutDepartmentInput').implement({
  fields: OfferUpdateWithoutDepartmentInputFields,
});

export const MatchCreateManyDisqualifyReasonInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
  candidateId: t.int({"required":true}),
  stageId: t.int({"required":false}),
  isHired: t.boolean({"required":false}),
});
export const MatchCreateManyDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyDisqualifyReasonInput>>('MatchCreateManyDisqualifyReasonInput').implement({
  fields: MatchCreateManyDisqualifyReasonInputFields,
});

export const MatchUpdateWithoutDisqualifyReasonInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMatchesNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutOffersNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneWithoutMatchesNestedInput}),
});
export const MatchUpdateWithoutDisqualifyReasonInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithoutDisqualifyReasonInput>>('MatchUpdateWithoutDisqualifyReasonInput').implement({
  fields: MatchUpdateWithoutDisqualifyReasonInputFields,
});

export const OfferTagCreateManyTagInputFields = (t: any) => ({
  offerId: t.int({"required":true}),
});
export const OfferTagCreateManyTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateManyTagInput>>('OfferTagCreateManyTagInput').implement({
  fields: OfferTagCreateManyTagInputFields,
});

export const CandidateCreateManyReferrerInputFields = (t: any) => ({
  id: t.int({"required":false}),
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  hiredAtId: t.int({"required":false}),
  hiredById: t.int({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const CandidateCreateManyReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyReferrerInput>>('CandidateCreateManyReferrerInput').implement({
  fields: CandidateCreateManyReferrerInputFields,
});

export const CandidateTagCreateManyTagInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
});
export const CandidateTagCreateManyTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateManyTagInput>>('CandidateTagCreateManyTagInput').implement({
  fields: CandidateTagCreateManyTagInputFields,
});

export const OfferTagUpdateWithoutTagInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutOfferTagsNestedInput}),
});
export const OfferTagUpdateWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateWithoutTagInput>>('OfferTagUpdateWithoutTagInput').implement({
  fields: OfferTagUpdateWithoutTagInputFields,
});

export const CandidateUpdateWithoutReferrerInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutReferrerInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutReferrerInput>>('CandidateUpdateWithoutReferrerInput').implement({
  fields: CandidateUpdateWithoutReferrerInputFields,
});

export const CandidateTagUpdateWithoutTagInputFields = (t: any) => ({
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutCandidateTagsNestedInput}),
});
export const CandidateTagUpdateWithoutTagInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateWithoutTagInput>>('CandidateTagUpdateWithoutTagInput').implement({
  fields: CandidateTagUpdateWithoutTagInputFields,
});

export const EventScheduleInterviewerCreateManyEventScheduleInputFields = (t: any) => ({
  id: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
  availability: t.field({"required":true,"type":Json}),
});
export const EventScheduleInterviewerCreateManyEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerCreateManyEventScheduleInput>>('EventScheduleInterviewerCreateManyEventScheduleInput').implement({
  fields: EventScheduleInterviewerCreateManyEventScheduleInputFields,
});

export const EventScheduleEvaluationCreateManyEventScheduleInputFields = (t: any) => ({
  id: t.int({"required":false}),
  evaluationId: t.int({"required":true}),
});
export const EventScheduleEvaluationCreateManyEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateManyEventScheduleInput>>('EventScheduleEvaluationCreateManyEventScheduleInput').implement({
  fields: EventScheduleEvaluationCreateManyEventScheduleInputFields,
});

export const EventScheduleInterviewerUpdateWithoutEventScheduleInputFields = (t: any) => ({
  availability: t.field({"required":false,"type":Json}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEventScheduleInterviewersNestedInput}),
});
export const EventScheduleInterviewerUpdateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleInterviewerUpdateWithoutEventScheduleInput>>('EventScheduleInterviewerUpdateWithoutEventScheduleInput').implement({
  fields: EventScheduleInterviewerUpdateWithoutEventScheduleInputFields,
});

export const EventScheduleEvaluationUpdateWithoutEventScheduleInputFields = (t: any) => ({
  evaluation: t.field({"required":false,"type":EvaluationUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput}),
});
export const EventScheduleEvaluationUpdateWithoutEventScheduleInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateWithoutEventScheduleInput>>('EventScheduleEvaluationUpdateWithoutEventScheduleInput').implement({
  fields: EventScheduleEvaluationUpdateWithoutEventScheduleInputFields,
});

export const EvaluationCreateManyEventInputFields = (t: any) => ({
  id: t.int({"required":false}),
  templateId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyEventInput>>('EvaluationCreateManyEventInput').implement({
  fields: EvaluationCreateManyEventInputFields,
});

export const EventInterviewerCreateManyEventInputFields = (t: any) => ({
  id: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const EventInterviewerCreateManyEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerCreateManyEventInput>>('EventInterviewerCreateManyEventInput').implement({
  fields: EventInterviewerCreateManyEventInputFields,
});

export const HiringRoleUpdateWithoutInterviewerEventsInputFields = (t: any) => ({
  extraAbilities: t.stringList({"required":false}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  user: t.field({"required":false,"type":UserUpdateOneRequiredWithoutHiringRolesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneRequiredWithoutHiringRolesNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutHiringRolesNestedInput}),
  attachments: t.field({"required":false,"type":AttachmentUpdateManyWithoutUploaderNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutUserNestedInput}),
  eventScheduleInterviewers: t.field({"required":false,"type":EventScheduleInterviewerUpdateManyWithoutTeamMemberNestedInput}),
  createdEvents: t.field({"required":false,"type":EventUpdateManyWithoutCreatedByNestedInput}),
  offerRecruiter: t.field({"required":false,"type":OfferUpdateOneWithoutRecruiterNestedInput}),
  offerHiringManager: t.field({"required":false,"type":OfferUpdateOneWithoutHiringManagerNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutTeamMemberNestedInput}),
  stageVisibilities: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutTeamMemberNestedInput}),
  hiredCandidates: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredByNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutTeamMemberNestedInput}),
  tasks: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTeamMemberNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutTeamMemberNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutTeamMemberNestedInput}),
});
export const HiringRoleUpdateWithoutInterviewerEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.HiringRoleUpdateWithoutInterviewerEventsInput>>('HiringRoleUpdateWithoutInterviewerEventsInput').implement({
  fields: HiringRoleUpdateWithoutInterviewerEventsInputFields,
});

export const EvaluationUpdateWithoutEventInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutEventInput>>('EvaluationUpdateWithoutEventInput').implement({
  fields: EvaluationUpdateWithoutEventInputFields,
});

export const CandidateUpdateWithoutEventsInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredAt: t.field({"required":false,"type":OfferUpdateOneWithoutHiredNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutEventsInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutEventsInput>>('CandidateUpdateWithoutEventsInput').implement({
  fields: CandidateUpdateWithoutEventsInputFields,
});

export const EventInterviewerUpdateWithoutEventInputFields = (t: any) => ({
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEventInterviewerNestedInput}),
});
export const EventInterviewerUpdateWithoutEventInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventInterviewerUpdateWithoutEventInput>>('EventInterviewerUpdateWithoutEventInput').implement({
  fields: EventInterviewerUpdateWithoutEventInputFields,
});

export const AuditLogCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  userId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
});
export const AuditLogCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyOfferInput>>('AuditLogCreateManyOfferInput').implement({
  fields: AuditLogCreateManyOfferInputFields,
});

export const OfferFileCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  attachmentId: t.int({"required":true}),
});
export const OfferFileCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileCreateManyOfferInput>>('OfferFileCreateManyOfferInput').implement({
  fields: OfferFileCreateManyOfferInputFields,
});

export const OfferTagCreateManyOfferInputFields = (t: any) => ({
  tagId: t.int({"required":true}),
});
export const OfferTagCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagCreateManyOfferInput>>('OfferTagCreateManyOfferInput').implement({
  fields: OfferTagCreateManyOfferInputFields,
});

export const MembershipCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  roleId: t.int({"required":false}),
});
export const MembershipCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipCreateManyOfferInput>>('MembershipCreateManyOfferInput').implement({
  fields: MembershipCreateManyOfferInputFields,
});

export const MatchCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  stageId: t.int({"required":false}),
  isHired: t.boolean({"required":false}),
  disqualifyReasonId: t.int({"required":false}),
});
export const MatchCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyOfferInput>>('MatchCreateManyOfferInput').implement({
  fields: MatchCreateManyOfferInputFields,
});

export const CandidateCreateManyHiredAtInputFields = (t: any) => ({
  id: t.int({"required":false}),
  firstName: t.string({"required":true}),
  lastName: t.string({"required":true}),
  email: t.string({"required":true}),
  phone: t.string({"required":false}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.string({"required":false}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.string({"required":false}),
  birthday: t.field({"required":false,"type":DateTime}),
  referrerId: t.int({"required":false}),
  cvId: t.int({"required":false}),
  avatarId: t.int({"required":false}),
  coverLetterId: t.int({"required":false}),
  educationLevel: t.string({"required":false}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.int({"required":false}),
  hiredById: t.int({"required":false}),
  companyId: t.string({"required":true}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const CandidateCreateManyHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCreateManyHiredAtInput>>('CandidateCreateManyHiredAtInput').implement({
  fields: CandidateCreateManyHiredAtInputFields,
});

export const EvaluationCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  templateId: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  eventId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyOfferInput>>('EvaluationCreateManyOfferInput').implement({
  fields: EvaluationCreateManyOfferInputFields,
});

export const FollowCreateManyOfferInputFields = (t: any) => ({
  id: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  talentPoolId: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const FollowCreateManyOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyOfferInput>>('FollowCreateManyOfferInput').implement({
  fields: FollowCreateManyOfferInputFields,
});

export const AuditLogUpdateWithoutOfferInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAuditLogsNestedInput}),
  user: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAuditLogsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutAuditLogsNestedInput}),
});
export const AuditLogUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithoutOfferInput>>('AuditLogUpdateWithoutOfferInput').implement({
  fields: AuditLogUpdateWithoutOfferInputFields,
});

export const OfferFileUpdateWithoutOfferInputFields = (t: any) => ({
  attachment: t.field({"required":false,"type":AttachmentUpdateOneRequiredWithoutOfferFilesNestedInput}),
});
export const OfferFileUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferFileUpdateWithoutOfferInput>>('OfferFileUpdateWithoutOfferInput').implement({
  fields: OfferFileUpdateWithoutOfferInputFields,
});

export const OfferTagUpdateWithoutOfferInputFields = (t: any) => ({
  tag: t.field({"required":false,"type":TagSourceUpdateOneRequiredWithoutOfferTagsNestedInput}),
});
export const OfferTagUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferTagUpdateWithoutOfferInput>>('OfferTagUpdateWithoutOfferInput').implement({
  fields: OfferTagUpdateWithoutOfferInputFields,
});

export const MembershipUpdateWithoutOfferInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutMembershipsNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutMembershipsNestedInput}),
});
export const MembershipUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MembershipUpdateWithoutOfferInput>>('MembershipUpdateWithoutOfferInput').implement({
  fields: MembershipUpdateWithoutOfferInputFields,
});

export const MatchUpdateWithoutOfferInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutOffersNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneWithoutMatchesNestedInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonUpdateOneWithoutMatchesNestedInput}),
});
export const MatchUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithoutOfferInput>>('MatchUpdateWithoutOfferInput').implement({
  fields: MatchUpdateWithoutOfferInputFields,
});

export const CandidateUpdateWithoutHiredAtInputFields = (t: any) => ({
  firstName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  lastName: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  email: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  phone: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  skills: t.stringList({"required":false}),
  mainLanguage: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  languages: t.stringList({"required":false}),
  coverLetterText: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  birthday: t.field({"required":false,"type":NullableDateTimeFieldUpdateOperationsInput}),
  educationLevel: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  socials: t.stringList({"required":false}),
  links: t.stringList({"required":false}),
  salaryExpectation: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  referrer: t.field({"required":false,"type":TagSourceUpdateOneWithoutCandidateReferrerNestedInput}),
  cv: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCvNestedInput}),
  avatar: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateAvatarNestedInput}),
  coverLetter: t.field({"required":false,"type":AttachmentUpdateOneWithoutCandidateCoverLetterNestedInput}),
  hiredBy: t.field({"required":false,"type":HiringRoleUpdateOneWithoutHiredCandidatesNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutCandidateNestedInput}),
  offers: t.field({"required":false,"type":MatchUpdateManyWithoutCandidateNestedInput}),
  talentPools: t.field({"required":false,"type":TalentPoolMatchUpdateManyWithoutCandidateNestedInput}),
  candidateTags: t.field({"required":false,"type":CandidateTagUpdateManyWithoutCandidateNestedInput}),
  candidateCustomFields: t.field({"required":false,"type":CandidateCustomFieldUpdateManyWithoutCandidateNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutCandidateNestedInput}),
  tasks: t.field({"required":false,"type":TaskUpdateManyWithoutCandidateNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutCandidateNestedInput}),
  SharedCandidateLink: t.field({"required":false,"type":SharedCandidateLinkUpdateManyWithoutCandidateNestedInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutCandidatesNestedInput}),
  events: t.field({"required":false,"type":EventUpdateManyWithoutCandidatesNestedInput}),
});
export const CandidateUpdateWithoutHiredAtInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateUpdateWithoutHiredAtInput>>('CandidateUpdateWithoutHiredAtInput').implement({
  fields: CandidateUpdateWithoutHiredAtInputFields,
});

export const EvaluationUpdateWithoutOfferInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutOfferInput>>('EvaluationUpdateWithoutOfferInput').implement({
  fields: EvaluationUpdateWithoutOfferInputFields,
});

export const FollowUpdateWithoutOfferInputFields = (t: any) => ({
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutFollowsNestedInput}),
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneWithoutFollowsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutFollowsNestedInput}),
});
export const FollowUpdateWithoutOfferInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithoutOfferInput>>('FollowUpdateWithoutOfferInput').implement({
  fields: FollowUpdateWithoutOfferInputFields,
});

export const TalentPoolFileCreateManyTalentPoolInputFields = (t: any) => ({
  id: t.int({"required":false}),
  attachmentId: t.int({"required":true}),
});
export const TalentPoolFileCreateManyTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileCreateManyTalentPoolInput>>('TalentPoolFileCreateManyTalentPoolInput').implement({
  fields: TalentPoolFileCreateManyTalentPoolInputFields,
});

export const TalentPoolMatchCreateManyTalentPoolInputFields = (t: any) => ({
  id: t.int({"required":false}),
  candidateId: t.int({"required":true}),
});
export const TalentPoolMatchCreateManyTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateManyTalentPoolInput>>('TalentPoolMatchCreateManyTalentPoolInput').implement({
  fields: TalentPoolMatchCreateManyTalentPoolInputFields,
});

export const FollowCreateManyTalentPoolInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const FollowCreateManyTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyTalentPoolInput>>('FollowCreateManyTalentPoolInput').implement({
  fields: FollowCreateManyTalentPoolInputFields,
});

export const TalentPoolFileUpdateWithoutTalentPoolInputFields = (t: any) => ({
  attachment: t.field({"required":false,"type":AttachmentUpdateOneRequiredWithoutTalentPoolFilesNestedInput}),
});
export const TalentPoolFileUpdateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolFileUpdateWithoutTalentPoolInput>>('TalentPoolFileUpdateWithoutTalentPoolInput').implement({
  fields: TalentPoolFileUpdateWithoutTalentPoolInputFields,
});

export const TalentPoolMatchUpdateWithoutTalentPoolInputFields = (t: any) => ({
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutTalentPoolsNestedInput}),
});
export const TalentPoolMatchUpdateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateWithoutTalentPoolInput>>('TalentPoolMatchUpdateWithoutTalentPoolInput').implement({
  fields: TalentPoolMatchUpdateWithoutTalentPoolInputFields,
});

export const FollowUpdateWithoutTalentPoolInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutFollowsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneWithoutFollowsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutFollowsNestedInput}),
});
export const FollowUpdateWithoutTalentPoolInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithoutTalentPoolInput>>('FollowUpdateWithoutTalentPoolInput').implement({
  fields: FollowUpdateWithoutTalentPoolInputFields,
});

export const OfferCreateManyScreeningQuestionsTemplateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
  departmentId: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  pipelineTemplateId: t.int({"required":false}),
  autoConfirmationEmailId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyScreeningQuestionsTemplateInput>>('OfferCreateManyScreeningQuestionsTemplateInput').implement({
  fields: OfferCreateManyScreeningQuestionsTemplateInputFields,
});

export const OfferCreateManyPipelineTemplateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
  departmentId: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  screeningQuestionsTemplateId: t.int({"required":false}),
  autoConfirmationEmailId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyPipelineTemplateInput>>('OfferCreateManyPipelineTemplateInput').implement({
  fields: OfferCreateManyPipelineTemplateInputFields,
});

export const OfferCreateManyAutoConfirmationEmailInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  companyId: t.string({"required":true}),
  departmentId: t.int({"required":false}),
  recruiterId: t.int({"required":false}),
  hiringManagerId: t.int({"required":false}),
  description: t.string({"required":false}),
  requirements: t.string({"required":false}),
  locationCountry: t.string({"required":false}),
  locationState: t.string({"required":false}),
  locationCity: t.string({"required":false}),
  locationStreet: t.string({"required":false}),
  zipcode: t.string({"required":false}),
  remote: t.boolean({"required":false}),
  jobType: t.string({"required":false}),
  jobCategory: t.string({"required":false}),
  jobReqEducation: t.string({"required":false}),
  jobReqExperience: t.string({"required":false}),
  jobHoursMin: t.int({"required":false}),
  jobHoursMax: t.int({"required":false}),
  jobSalaryMin: t.int({"required":false}),
  jobSalaryMax: t.int({"required":false}),
  jobSalaryPeriod: t.string({"required":false}),
  jobSalaryCurrency: t.string({"required":false}),
  personalInfoCv: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoCoverLetter: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhoto: t.field({"required":false,"type":OfferPersonalItems}),
  personalInfoPhone: t.field({"required":false,"type":OfferPersonalItems}),
  screeningQuestionsTemplateId: t.int({"required":false}),
  pipelineTemplateId: t.int({"required":false}),
  isPublished: t.boolean({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const OfferCreateManyAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferCreateManyAutoConfirmationEmailInput>>('OfferCreateManyAutoConfirmationEmailInput').implement({
  fields: OfferCreateManyAutoConfirmationEmailInputFields,
});

export const StageCreateManyTemplateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  position: t.int({"required":false}),
  category: t.string({"required":true}),
  inputType: t.string({"required":false}),
  value: t.string({"required":false}),
  isProtected: t.boolean({"required":false}),
});
export const StageCreateManyTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageCreateManyTemplateInput>>('StageCreateManyTemplateInput').implement({
  fields: StageCreateManyTemplateInputFields,
});

export const EvaluationCreateManyTemplateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":false}),
  candidateId: t.int({"required":true}),
  teamMemberId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  eventId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyTemplateInput>>('EvaluationCreateManyTemplateInput').implement({
  fields: EvaluationCreateManyTemplateInputFields,
});

export const OfferUpdateWithoutScreeningQuestionsTemplateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutScreeningQuestionsTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutScreeningQuestionsTemplateInput>>('OfferUpdateWithoutScreeningQuestionsTemplateInput').implement({
  fields: OfferUpdateWithoutScreeningQuestionsTemplateInputFields,
});

export const OfferUpdateWithoutPipelineTemplateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  autoConfirmationEmail: t.field({"required":false,"type":TemplateUpdateOneWithoutAutoConfirmationEmailNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutPipelineTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutPipelineTemplateInput>>('OfferUpdateWithoutPipelineTemplateInput').implement({
  fields: OfferUpdateWithoutPipelineTemplateInputFields,
});

export const OfferUpdateWithoutAutoConfirmationEmailInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  requirements: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCountry: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationState: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationCity: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  locationStreet: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  zipcode: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  remote: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  jobType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobCategory: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqEducation: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobReqExperience: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobHoursMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobHoursMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMin: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryMax: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  jobSalaryPeriod: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  jobSalaryCurrency: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  personalInfoCv: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoCoverLetter: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhoto: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  personalInfoPhone: t.field({"required":false,"type":EnumOfferPersonalItemsFieldUpdateOperationsInput}),
  isPublished: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutOffersNestedInput}),
  department: t.field({"required":false,"type":DepartmentUpdateOneWithoutOffersNestedInput}),
  recruiter: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferRecruiterNestedInput}),
  hiringManager: t.field({"required":false,"type":HiringRoleUpdateOneWithoutOfferHiringManagerNestedInput}),
  screeningQuestionsTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutScreeningQuestionsTemplateNestedInput}),
  pipelineTemplate: t.field({"required":false,"type":TemplateUpdateOneWithoutPipelineTemplateNestedInput}),
  auditLogs: t.field({"required":false,"type":AuditLogUpdateManyWithoutOfferNestedInput}),
  files: t.field({"required":false,"type":OfferFileUpdateManyWithoutOfferNestedInput}),
  offerTags: t.field({"required":false,"type":OfferTagUpdateManyWithoutOfferNestedInput}),
  memberships: t.field({"required":false,"type":MembershipUpdateManyWithoutOfferNestedInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutOfferNestedInput}),
  hired: t.field({"required":false,"type":CandidateUpdateManyWithoutHiredAtNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutOfferNestedInput}),
  follows: t.field({"required":false,"type":FollowUpdateManyWithoutOfferNestedInput}),
});
export const OfferUpdateWithoutAutoConfirmationEmailInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.OfferUpdateWithoutAutoConfirmationEmailInput>>('OfferUpdateWithoutAutoConfirmationEmailInput').implement({
  fields: OfferUpdateWithoutAutoConfirmationEmailInputFields,
});

export const StageUpdateWithoutTemplateInputFields = (t: any) => ({
  position: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  category: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  inputType: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  isProtected: t.field({"required":false,"type":NullableBoolFieldUpdateOperationsInput}),
  matches: t.field({"required":false,"type":MatchUpdateManyWithoutStageNestedInput}),
  visibility: t.field({"required":false,"type":StageVisibilityUpdateManyWithoutStageNestedInput}),
  metadata: t.field({"required":false,"type":StageMetadataUpdateManyWithoutStageNestedInput}),
});
export const StageUpdateWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageUpdateWithoutTemplateInput>>('StageUpdateWithoutTemplateInput').implement({
  fields: StageUpdateWithoutTemplateInputFields,
});

export const EvaluationUpdateWithoutTemplateInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutTemplateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutTemplateInput>>('EvaluationUpdateWithoutTemplateInput').implement({
  fields: EvaluationUpdateWithoutTemplateInputFields,
});

export const MatchCreateManyStageInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
  candidateId: t.int({"required":true}),
  isHired: t.boolean({"required":false}),
  disqualifyReasonId: t.int({"required":false}),
});
export const MatchCreateManyStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyStageInput>>('MatchCreateManyStageInput').implement({
  fields: MatchCreateManyStageInputFields,
});

export const StageVisibilityCreateManyStageInputFields = (t: any) => ({
  id: t.int({"required":false}),
  type: t.field({"required":true,"type":MembershipTypes}),
  teamMemberId: t.int({"required":false}),
  roleId: t.int({"required":false}),
});
export const StageVisibilityCreateManyStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityCreateManyStageInput>>('StageVisibilityCreateManyStageInput').implement({
  fields: StageVisibilityCreateManyStageInputFields,
});

export const StageMetadataCreateManyStageInputFields = (t: any) => ({
  id: t.int({"required":false}),
  metaKey: t.string({"required":true}),
  metaValue: t.string({"required":true}),
});
export const StageMetadataCreateManyStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataCreateManyStageInput>>('StageMetadataCreateManyStageInput').implement({
  fields: StageMetadataCreateManyStageInputFields,
});

export const MatchUpdateWithoutStageInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMatchesNestedInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutOffersNestedInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonUpdateOneWithoutMatchesNestedInput}),
});
export const MatchUpdateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithoutStageInput>>('MatchUpdateWithoutStageInput').implement({
  fields: MatchUpdateWithoutStageInputFields,
});

export const StageVisibilityUpdateWithoutStageInputFields = (t: any) => ({
  type: t.field({"required":false,"type":EnumMembershipTypesFieldUpdateOperationsInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneWithoutStageVisibilitiesNestedInput}),
  role: t.field({"required":false,"type":RoleUpdateOneWithoutStageVisibilityNestedInput}),
});
export const StageVisibilityUpdateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageVisibilityUpdateWithoutStageInput>>('StageVisibilityUpdateWithoutStageInput').implement({
  fields: StageVisibilityUpdateWithoutStageInputFields,
});

export const StageMetadataUpdateWithoutStageInputFields = (t: any) => ({
  metaKey: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  metaValue: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const StageMetadataUpdateWithoutStageInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.StageMetadataUpdateWithoutStageInput>>('StageMetadataUpdateWithoutStageInput').implement({
  fields: StageMetadataUpdateWithoutStageInputFields,
});

export const AuditLogCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  userId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  actor: t.string({"required":true}),
  actorType: t.string({"required":true}),
  ip: t.string({"required":true}),
  action: t.string({"required":true}),
  eventDetails: t.field({"required":true,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTime}),
});
export const AuditLogCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogCreateManyCandidateInput>>('AuditLogCreateManyCandidateInput').implement({
  fields: AuditLogCreateManyCandidateInputFields,
});

export const MatchCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":true}),
  stageId: t.int({"required":false}),
  isHired: t.boolean({"required":false}),
  disqualifyReasonId: t.int({"required":false}),
});
export const MatchCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchCreateManyCandidateInput>>('MatchCreateManyCandidateInput').implement({
  fields: MatchCreateManyCandidateInputFields,
});

export const TalentPoolMatchCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  talentPoolId: t.int({"required":true}),
});
export const TalentPoolMatchCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchCreateManyCandidateInput>>('TalentPoolMatchCreateManyCandidateInput').implement({
  fields: TalentPoolMatchCreateManyCandidateInputFields,
});

export const CandidateTagCreateManyCandidateInputFields = (t: any) => ({
  tagId: t.int({"required":true}),
});
export const CandidateTagCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagCreateManyCandidateInput>>('CandidateTagCreateManyCandidateInput').implement({
  fields: CandidateTagCreateManyCandidateInputFields,
});

export const CandidateCustomFieldCreateManyCandidateInputFields = (t: any) => ({
  customFieldId: t.int({"required":true}),
  value: t.string({"required":false}),
});
export const CandidateCustomFieldCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateManyCandidateInput>>('CandidateCustomFieldCreateManyCandidateInput').implement({
  fields: CandidateCustomFieldCreateManyCandidateInputFields,
});

export const EvaluationCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  templateId: t.int({"required":false}),
  offerId: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
  isQuickEval: t.boolean({"required":false}),
  description: t.string({"required":false}),
  score: t.field({"required":true,"type":SCORE_TYPES}),
  eventId: t.int({"required":false}),
  createdAt: t.field({"required":false,"type":DateTime}),
  updatedAt: t.field({"required":false,"type":DateTime}),
});
export const EvaluationCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationCreateManyCandidateInput>>('EvaluationCreateManyCandidateInput').implement({
  fields: EvaluationCreateManyCandidateInputFields,
});

export const TaskCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  companyId: t.string({"required":true}),
  name: t.string({"required":true}),
  status: t.string({"required":true}),
  dueDate: t.field({"required":true,"type":DateTime}),
  note: t.string({"required":true}),
});
export const TaskCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskCreateManyCandidateInput>>('TaskCreateManyCandidateInput').implement({
  fields: TaskCreateManyCandidateInputFields,
});

export const FollowCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  offerId: t.int({"required":false}),
  talentPoolId: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const FollowCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowCreateManyCandidateInput>>('FollowCreateManyCandidateInput').implement({
  fields: FollowCreateManyCandidateInputFields,
});

export const SharedCandidateLinkCreateManyCandidateInputFields = (t: any) => ({
  id: t.int({"required":false}),
  name: t.string({"required":true}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.string({"required":true}),
  expiration: t.field({"required":true,"type":DateTime}),
});
export const SharedCandidateLinkCreateManyCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkCreateManyCandidateInput>>('SharedCandidateLinkCreateManyCandidateInput').implement({
  fields: SharedCandidateLinkCreateManyCandidateInputFields,
});

export const AuditLogUpdateWithoutCandidateInputFields = (t: any) => ({
  actor: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  actorType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  ip: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  action: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  eventDetails: t.field({"required":false,"type":Json}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutAuditLogsNestedInput}),
  user: t.field({"required":false,"type":HiringRoleUpdateOneWithoutAuditLogsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutAuditLogsNestedInput}),
});
export const AuditLogUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.AuditLogUpdateWithoutCandidateInput>>('AuditLogUpdateWithoutCandidateInput').implement({
  fields: AuditLogUpdateWithoutCandidateInputFields,
});

export const MatchUpdateWithoutCandidateInputFields = (t: any) => ({
  isHired: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneRequiredWithoutMatchesNestedInput}),
  stage: t.field({"required":false,"type":StageUpdateOneWithoutMatchesNestedInput}),
  disqualifyReason: t.field({"required":false,"type":DisqualifyReasonUpdateOneWithoutMatchesNestedInput}),
});
export const MatchUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.MatchUpdateWithoutCandidateInput>>('MatchUpdateWithoutCandidateInput').implement({
  fields: MatchUpdateWithoutCandidateInputFields,
});

export const TalentPoolMatchUpdateWithoutCandidateInputFields = (t: any) => ({
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneRequiredWithoutMatchesNestedInput}),
});
export const TalentPoolMatchUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TalentPoolMatchUpdateWithoutCandidateInput>>('TalentPoolMatchUpdateWithoutCandidateInput').implement({
  fields: TalentPoolMatchUpdateWithoutCandidateInputFields,
});

export const CandidateTagUpdateWithoutCandidateInputFields = (t: any) => ({
  tag: t.field({"required":false,"type":TagSourceUpdateOneRequiredWithoutCandidateTagsNestedInput}),
});
export const CandidateTagUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateTagUpdateWithoutCandidateInput>>('CandidateTagUpdateWithoutCandidateInput').implement({
  fields: CandidateTagUpdateWithoutCandidateInputFields,
});

export const CandidateCustomFieldUpdateWithoutCandidateInputFields = (t: any) => ({
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  customField: t.field({"required":false,"type":CustomFieldUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput}),
});
export const CandidateCustomFieldUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateWithoutCandidateInput>>('CandidateCustomFieldUpdateWithoutCandidateInput').implement({
  fields: CandidateCustomFieldUpdateWithoutCandidateInputFields,
});

export const EvaluationUpdateWithoutCandidateInputFields = (t: any) => ({
  isQuickEval: t.field({"required":false,"type":BoolFieldUpdateOperationsInput}),
  description: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  score: t.field({"required":false,"type":EnumSCORE_TYPESFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  template: t.field({"required":false,"type":TemplateUpdateOneWithoutEvaluationsNestedInput}),
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutEvaluationsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutEvaluationsNestedInput}),
  eventScheduleEvaluations: t.field({"required":false,"type":EventScheduleEvaluationUpdateManyWithoutEvaluationNestedInput}),
  event: t.field({"required":false,"type":EventUpdateOneWithoutEvaluationsNestedInput}),
  answers: t.field({"required":false,"type":EvaluationQuestionUpdateManyWithoutEvaluationNestedInput}),
});
export const EvaluationUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationUpdateWithoutCandidateInput>>('EvaluationUpdateWithoutCandidateInput').implement({
  fields: EvaluationUpdateWithoutCandidateInputFields,
});

export const TaskUpdateWithoutCandidateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  status: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  dueDate: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutTasksNestedInput}),
  taskMembers: t.field({"required":false,"type":TaskMemberUpdateManyWithoutTaskNestedInput}),
});
export const TaskUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskUpdateWithoutCandidateInput>>('TaskUpdateWithoutCandidateInput').implement({
  fields: TaskUpdateWithoutCandidateInputFields,
});

export const FollowUpdateWithoutCandidateInputFields = (t: any) => ({
  offer: t.field({"required":false,"type":OfferUpdateOneWithoutFollowsNestedInput}),
  talentPool: t.field({"required":false,"type":TalentPoolUpdateOneWithoutFollowsNestedInput}),
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutFollowsNestedInput}),
});
export const FollowUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.FollowUpdateWithoutCandidateInput>>('FollowUpdateWithoutCandidateInput').implement({
  fields: FollowUpdateWithoutCandidateInputFields,
});

export const SharedCandidateLinkUpdateWithoutCandidateInputFields = (t: any) => ({
  name: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  visibleSections: t.stringList({"required":false}),
  editModelSections: t.stringList({"required":false}),
  link: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  expiration: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
});
export const SharedCandidateLinkUpdateWithoutCandidateInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.SharedCandidateLinkUpdateWithoutCandidateInput>>('SharedCandidateLinkUpdateWithoutCandidateInput').implement({
  fields: SharedCandidateLinkUpdateWithoutCandidateInputFields,
});

export const EventUpdateWithoutCandidatesInputFields = (t: any) => ({
  date: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  duration: t.field({"required":false,"type":NullableIntFieldUpdateOperationsInput}),
  type: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  location: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  note: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  privateNote: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  createdAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  updatedAt: t.field({"required":false,"type":DateTimeFieldUpdateOperationsInput}),
  company: t.field({"required":false,"type":CompanyUpdateOneRequiredWithoutEventsNestedInput}),
  interviewers: t.field({"required":false,"type":HiringRoleUpdateManyWithoutInterviewerEventsNestedInput}),
  evaluations: t.field({"required":false,"type":EvaluationUpdateManyWithoutEventNestedInput}),
  createdBy: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutCreatedEventsNestedInput}),
  EventInterviewer: t.field({"required":false,"type":EventInterviewerUpdateManyWithoutEventNestedInput}),
});
export const EventUpdateWithoutCandidatesInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventUpdateWithoutCandidatesInput>>('EventUpdateWithoutCandidatesInput').implement({
  fields: EventUpdateWithoutCandidatesInputFields,
});

export const CandidateCustomFieldCreateManyCustomFieldInputFields = (t: any) => ({
  candidateId: t.int({"required":true}),
  value: t.string({"required":false}),
});
export const CandidateCustomFieldCreateManyCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldCreateManyCustomFieldInput>>('CandidateCustomFieldCreateManyCustomFieldInput').implement({
  fields: CandidateCustomFieldCreateManyCustomFieldInputFields,
});

export const CandidateCustomFieldUpdateWithoutCustomFieldInputFields = (t: any) => ({
  value: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  candidate: t.field({"required":false,"type":CandidateUpdateOneRequiredWithoutCandidateCustomFieldsNestedInput}),
});
export const CandidateCustomFieldUpdateWithoutCustomFieldInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.CandidateCustomFieldUpdateWithoutCustomFieldInput>>('CandidateCustomFieldUpdateWithoutCustomFieldInput').implement({
  fields: CandidateCustomFieldUpdateWithoutCustomFieldInputFields,
});

export const EventScheduleEvaluationCreateManyEvaluationInputFields = (t: any) => ({
  id: t.int({"required":false}),
  eventScheduleId: t.int({"required":true}),
});
export const EventScheduleEvaluationCreateManyEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationCreateManyEvaluationInput>>('EventScheduleEvaluationCreateManyEvaluationInput').implement({
  fields: EventScheduleEvaluationCreateManyEvaluationInputFields,
});

export const EvaluationQuestionCreateManyEvaluationInputFields = (t: any) => ({
  id: t.int({"required":false}),
  inputType: t.string({"required":true}),
  settings: t.field({"required":false,"type":Json}),
  question: t.string({"required":false}),
  answer: t.string({"required":true}),
});
export const EvaluationQuestionCreateManyEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionCreateManyEvaluationInput>>('EvaluationQuestionCreateManyEvaluationInput').implement({
  fields: EvaluationQuestionCreateManyEvaluationInputFields,
});

export const EventScheduleEvaluationUpdateWithoutEvaluationInputFields = (t: any) => ({
  eventSchedule: t.field({"required":false,"type":EventScheduleUpdateOneRequiredWithoutEventScheduleEvaluationsNestedInput}),
});
export const EventScheduleEvaluationUpdateWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EventScheduleEvaluationUpdateWithoutEvaluationInput>>('EventScheduleEvaluationUpdateWithoutEvaluationInput').implement({
  fields: EventScheduleEvaluationUpdateWithoutEvaluationInputFields,
});

export const EvaluationQuestionUpdateWithoutEvaluationInputFields = (t: any) => ({
  inputType: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
  settings: t.field({"required":false,"type":Json}),
  question: t.field({"required":false,"type":NullableStringFieldUpdateOperationsInput}),
  answer: t.field({"required":false,"type":StringFieldUpdateOperationsInput}),
});
export const EvaluationQuestionUpdateWithoutEvaluationInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.EvaluationQuestionUpdateWithoutEvaluationInput>>('EvaluationQuestionUpdateWithoutEvaluationInput').implement({
  fields: EvaluationQuestionUpdateWithoutEvaluationInputFields,
});

export const TaskMemberCreateManyTaskInputFields = (t: any) => ({
  id: t.int({"required":false}),
  teamMemberId: t.int({"required":true}),
});
export const TaskMemberCreateManyTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberCreateManyTaskInput>>('TaskMemberCreateManyTaskInput').implement({
  fields: TaskMemberCreateManyTaskInputFields,
});

export const TaskMemberUpdateWithoutTaskInputFields = (t: any) => ({
  teamMember: t.field({"required":false,"type":HiringRoleUpdateOneRequiredWithoutTasksNestedInput}),
});
export const TaskMemberUpdateWithoutTaskInput = builder.inputRef<PrismaUpdateOperationsInputFilter<Prisma.TaskMemberUpdateWithoutTaskInput>>('TaskMemberUpdateWithoutTaskInput').implement({
  fields: TaskMemberUpdateWithoutTaskInputFields,
});